<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>服务器远程辅助下载文件</title>
      <link href="/posts/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%BE%85%E5%8A%A9%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/posts/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E8%BE%85%E5%8A%A9%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>最近在做深度学习发现下载模型时速度太慢，可能是外网的原因。所以做了一个小插件，利用远程服务器辅助下载文件。</p><blockquote><p>你需要准备：<br>远程服务器（具备TCP接口）、本地电脑（python环境）<br>所需知识：<br>1、PYQT基础知识<br>2、TCP知识<br>3、QT多线程知识</p></blockquote><h3 id="PYQT做界面-amp-多线程"><a href="#PYQT做界面-amp-多线程" class="headerlink" title="PYQT做界面 &amp; 多线程"></a>PYQT做界面 &amp; 多线程</h3><p>如果你对PYQT不太了解，参考可以<a href="https://blog.csdn.net/CLOUD_J/article/details/104795612">五分钟掌握</a>。</p><p>如图所示，我们搭建了我们的UI界面，主要三个部分：端口号，下载链接，日志。<br><img src="https://img-blog.csdnimg.cn/20200309151053106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码可以参考：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(QWidget)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.ok = <span class="literal">False</span></span><br><span class="line">        self.port_default = <span class="number">0</span></span><br><span class="line">        self.content_tmp = <span class="string">''</span></span><br><span class="line">        self.initUI()</span><br><span class="line">    <span class="comment">#UI界面涉及</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#1 说明内容</span></span><br><span class="line">        self.lbl2 = QLabel(self)</span><br><span class="line">        self.lbl2.setText(</span><br><span class="line">            <span class="string">"1、You should input Port first.\n2、Enter the URL and click the download button\n3、If you have some problem, send email to\n menglingjun@cloudcver.com"</span>)</span><br><span class="line">        self.lbl2.move(<span class="number">30</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="comment">#2 下载区</span></span><br><span class="line">        <span class="comment">#2.1 文本URL</span></span><br><span class="line">        self.lbl = QLabel(self)</span><br><span class="line">        self.lbl.setText(<span class="string">"Url:"</span>)</span><br><span class="line">        self.lbl.move(<span class="number">30</span>, <span class="number">93</span>)</span><br><span class="line">        <span class="comment">#2.2 链接URL</span></span><br><span class="line">        self.file_url = QLineEdit(self)</span><br><span class="line">        self.file_url.move(<span class="number">50</span>, <span class="number">90</span>)</span><br><span class="line">        self.file_url.setGeometry(<span class="number">50</span>, <span class="number">90</span>, <span class="number">250</span>, <span class="number">23</span>)</span><br><span class="line">        <span class="comment">#2.3 下载按钮</span></span><br><span class="line">        download_button = QPushButton(<span class="string">'Download'</span>, self)</span><br><span class="line">        download_button.clicked.connect(self.download)</span><br><span class="line">        download_button.move(<span class="number">320</span>, <span class="number">90</span>)</span><br><span class="line">        <span class="comment">#3 端口号按钮</span></span><br><span class="line">        self.download_button = QPushButton(<span class="string">'No Port'</span>, self)</span><br><span class="line">        self.download_button.clicked.connect(self.login)</span><br><span class="line">        self.download_button.move(<span class="number">400</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="comment">#4 日志</span></span><br><span class="line">        self.tmp = QTextEdit(self)</span><br><span class="line">        self.tmp.move(<span class="number">50</span>, <span class="number">120</span>)</span><br><span class="line">        self.tmp.setGeometry(<span class="number">50</span>, <span class="number">120</span>, <span class="number">350</span>, <span class="number">70</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#5 标题</span></span><br><span class="line">        self.setGeometry(<span class="number">300</span>, <span class="number">300</span>, <span class="number">500</span>, <span class="number">200</span>)</span><br><span class="line">        self.setWindowTitle(<span class="string">'服务器加速下载器@cloudcver'</span>)</span><br><span class="line">        self.show()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self)</span>:</span></span><br><span class="line">        text, ok = QInputDialog.getText(self, <span class="string">'Set Port'</span>,</span><br><span class="line">                                        <span class="string">'Enter your port:'</span>)</span><br><span class="line">        <span class="keyword">if</span> ok:</span><br><span class="line">            self.port_default = int(text)</span><br><span class="line">            self.download_button.setText(text)</span><br><span class="line">            self.content_tmp = self.content_tmp + <span class="string">"%s:Set port at %s\n"</span>%(time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime()),text)</span><br><span class="line">            self.tmp.setText(self.content_tmp)</span><br><span class="line">            self.ok = <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.ok:</span><br><span class="line">            self.content_tmp = self.content_tmp + <span class="string">"%s:Send the task to server\n"</span> % (</span><br><span class="line">                time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime()))</span><br><span class="line">            self.tmp.setText(self.content_tmp)</span><br><span class="line">            self.thread = DownloadThread()</span><br><span class="line">            self.thread.set_port_url(self.port_default,self.file_url.text())  <span class="comment"># 创建</span></span><br><span class="line">            self.thread.trigger.connect(self.finish)  <span class="comment"># 连接信号</span></span><br><span class="line">            self.thread.start()  <span class="comment"># 开始线程</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            reply = QMessageBox.question(self, <span class="string">'Message'</span>,</span><br><span class="line">                                         <span class="string">"You should set port first"</span>, QMessageBox.Yes)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.content_tmp = self.content_tmp + <span class="string">"%s:Finish!\n"</span> % (time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime()))</span><br><span class="line">        self.tmp.setText(self.content_tmp)</span><br></pre></td></tr></table></figure><br>界面很简单就不说了，主要说一下多线程内容！<br><strong>重点看一下这里！<br>重点看一下这里！<br>重点看一下这里！</strong></p><blockquote><p>1、看download函数，ok这个参数代表已经设定好端口号。初始ok是False，在Port按钮输入后就变为True了。<br>2、这里我们启动了一个多线程DownloadThread()，其定义了一个线程类，这个类下面有几个方法：<br>2.1 set_port_url()是我们自己定义的方法，为了设定一些参数。<br>2.2 run是一个父类的函数，我们需要重构一下，这就是当执行线程时需要执行的函数。也就是self.thread.start() 后就开始执行run这个函数。<br>2.3 trigger是我们创建的一个pyqt信号，我们可以让它连接一个函数，然后在run执行完后传递退出的信号，代表推出后执行它连接的函数。<br><strong>具体的代码可以看：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class DownloadThread(QThread):</span><br><span class="line">    trigger = pyqtSignal()</span><br><span class="line"></span><br><span class="line">    def __int__(self):</span><br><span class="line">        super(DownloadThread, self).__init__()</span><br><span class="line">    def set_port_url(self,port_default,url):</span><br><span class="line">        self.port_default = port_default</span><br><span class="line">        self.url = url</span><br><span class="line">    def run(self):</span><br><span class="line">##一会补充！</span><br><span class="line">        # # 循环完毕后发出信号</span><br><span class="line">        # print(&apos;1线程运行完了&apos;)</span><br><span class="line">        self.trigger.emit()</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h3><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><p>服务器端：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">reload(sys)</span><br><span class="line"></span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br><span class="line"><span class="comment">#testurl = "http://download.tensorflow.org/models/resnet_v1_101_2016_08_28.tar.gz"</span></span><br><span class="line"><span class="comment">#subprocess.call('wget -P  ./tmp/ %s'%testurl,shell = True)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_file_to_client</span><span class="params">(new_client_socket, client_addr)</span>:</span></span><br><span class="line">    <span class="comment"># 1.接收客户端发过来需要下载的文件名</span></span><br><span class="line">    file_name = new_client_socket.recv(<span class="number">1024</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    print(<span class="string">"客户端(%s)需要下载的文件是：%s"</span>%(str(client_addr),file_name))</span><br><span class="line">    file_time = time.time()</span><br><span class="line">    subprocess.call(<span class="string">'wget -P ./tmp/%s/ %s'</span>%(file_time,file_name),shell = <span class="literal">True</span>)</span><br><span class="line">    file_content = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 2.打开这个文件，读取数据</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        index = os.listdir(<span class="string">'./tmp/%s/'</span>%file_time)</span><br><span class="line">        new_client_socket.send(index[<span class="number">0</span>])</span><br><span class="line">        filesize = str(os.path.getsize(os.path.join(<span class="string">'./tmp/%s/'</span>%file_time,index[<span class="number">0</span>])))</span><br><span class="line">        print(os.path.join(<span class="string">'./tmp/%s/'</span>%file_time,index[<span class="number">0</span>]))</span><br><span class="line">        print(filesize)</span><br><span class="line">        <span class="comment">#new_client_socket.send('12345')</span></span><br><span class="line">        new_client_socket.send(filesize)</span><br><span class="line">        print(<span class="string">'wait'</span>)</span><br><span class="line">        data = new_client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        f = open(os.path.join(<span class="string">'./tmp/%s/'</span>%file_time,index[<span class="number">0</span>]), <span class="string">"rb"</span>)</span><br><span class="line">        print(<span class="string">'open!'</span>)</span><br><span class="line">        new_client_socket.sendall(f.read())</span><br><span class="line">        print(<span class="string">'send!ok'</span>)</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        while True:</span></span><br><span class="line"><span class="string">            for line in f:</span></span><br><span class="line"><span class="string">                new_client_socket.send(line)</span></span><br><span class="line"><span class="string">                #print('sending...')</span></span><br><span class="line"><span class="string">            #new_client_socket.send('end')</span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">        print('ok')</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        f.close()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> ret:</span><br><span class="line">        print(<span class="string">"没有要下载的文件(%s)"</span> % file_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1.创建套接字 socket</span></span><br><span class="line">    tcp_sever_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.绑定本地信息 bind</span></span><br><span class="line">    tcp_sever_socket.bind((<span class="string">""</span>,<span class="number">70</span>))<span class="comment"># 7890))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.让默认的套接字由主动变为被动 listen</span></span><br><span class="line">    tcp_sever_socket.listen(<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4.等待客户端的链接 accept</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'wait'</span>)</span><br><span class="line">        new_client_socket, client_addr = tcp_sever_socket.accept()</span><br><span class="line">        print(<span class="string">'connect!'</span>)</span><br><span class="line">        <span class="comment"># 5.调用发送文件函数，完成客户端服务</span></span><br><span class="line"></span><br><span class="line">        send_file_to_client(new_client_socket, client_addr)</span><br><span class="line">        print(<span class="string">'send!'</span>)</span><br><span class="line">    <span class="comment"># 6.关闭套接字</span></span><br><span class="line">    new_client_socket.close()</span><br><span class="line">    tcp_sever_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>客户端：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># download from fuwuqi</span></span><br><span class="line"><span class="comment"># Author: menglingjun@cloudcver.com</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#package</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QWidget, QPushButton, QApplication,QLabel,QLineEdit,QMessageBox,QInputDialog,QTextEdit</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QCoreApplication</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> Qt, QThread,pyqtSignal</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadThread</span><span class="params">(QThread)</span>:</span></span><br><span class="line">    trigger = pyqtSignal(int,str)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(DownloadThread, self).__init__()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_port_url</span><span class="params">(self,port_default,url)</span>:</span></span><br><span class="line">        self.port_default = port_default</span><br><span class="line">        self.url = url</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 1.创建套接字</span></span><br><span class="line">            tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">            IP_default = <span class="string">'39.97.178.93'</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 2.获取服务器的ip port</span></span><br><span class="line">            <span class="comment"># dest_ip = input("请输入下载服务器的ip：")</span></span><br><span class="line">            <span class="comment"># dest_port = int(input("请输入下载服务器的port:"))</span></span><br><span class="line">            print(<span class="number">3</span>)</span><br><span class="line">            <span class="comment"># 3.链接服务器</span></span><br><span class="line">            tcp_socket.connect((IP_default, self.port_default))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 4.获取文件下载的文件名</span></span><br><span class="line">            <span class="comment"># download_file_name = input("请输入要下载的文件名字：")</span></span><br><span class="line">            download_file_name = self.url</span><br><span class="line">            <span class="comment"># 'http://download.tensorflow.org/models/resnet_v1_101_2016_08_28.tar.gz'</span></span><br><span class="line">            <span class="comment"># 5.将文件名字发送到服务器</span></span><br><span class="line"></span><br><span class="line">            tcp_socket.send(download_file_name.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">            print(<span class="number">4</span>)</span><br><span class="line">            <span class="comment"># 6.接收文件中的数据</span></span><br><span class="line">            filename = tcp_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            print(filename)</span><br><span class="line">            data1 = tcp_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            tcp_socket.send(data1)</span><br><span class="line">            <span class="comment">#data2 = tcp_socket.recv(1024)</span></span><br><span class="line">            print(data1)</span><br><span class="line">            <span class="comment">#print(data2)</span></span><br><span class="line">            file_total_size = int(data1.decode())</span><br><span class="line">            print(file_total_size)</span><br><span class="line">            received_size = <span class="number">0</span></span><br><span class="line">            f = open(filename, <span class="string">'wb'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> received_size &lt; file_total_size:</span><br><span class="line">                data = tcp_socket.recv(<span class="number">2048000</span>)</span><br><span class="line">                f.write(data)</span><br><span class="line">                received_size += len(data)</span><br><span class="line">                print(<span class="string">'已接收 '</span>, received_size, <span class="string">' Byte'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#data = tcp_socket.recv(file_total_size)</span></span><br><span class="line">            <span class="comment">#f.write(data)</span></span><br><span class="line">            print(<span class="string">"---"</span>)</span><br><span class="line">            <span class="comment">#data = tcp_socket.recv(1024)</span></span><br><span class="line">            <span class="comment">#print("file save to %s" % filename)</span></span><br><span class="line">            <span class="comment"># 8.关闭套接字</span></span><br><span class="line">            tcp_socket.close()</span><br><span class="line">            <span class="comment"># 这一部分就可以写入你想要执行的代码就好</span></span><br><span class="line">            <span class="comment"># print('开始执行了run')</span></span><br><span class="line">            <span class="comment"># for i in range(2000000000):</span></span><br><span class="line">            <span class="comment">#     pass</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># # 循环完毕后发出信号</span></span><br><span class="line">            <span class="comment"># print('1线程运行完了')</span></span><br><span class="line">            <span class="comment">#self.trigger.emit()</span></span><br><span class="line">            self.trigger.emit(<span class="number">1</span>,str(filename))</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">"下载失败了"</span>)</span><br><span class="line">            self.trigger.emit(<span class="number">0</span>,<span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#http://download.tensorflow.org/models/resnet_v1_101_2016_08_28.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 窗口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(QWidget)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.ok = <span class="literal">False</span></span><br><span class="line">        self.port_default = <span class="number">0</span></span><br><span class="line">        self.content_tmp = <span class="string">''</span></span><br><span class="line">        self.initUI()</span><br><span class="line">    <span class="comment">#UI界面涉及</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#1 说明内容</span></span><br><span class="line">        self.lbl2 = QLabel(self)</span><br><span class="line">        self.lbl2.setText(</span><br><span class="line">            <span class="string">"1、You should input Port first.\n2、Enter the URL and click the download button\n3、If you have some problem, send email to\n menglingjun@cloudcver.com"</span>)</span><br><span class="line">        self.lbl2.move(<span class="number">30</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="comment">#2 下载区</span></span><br><span class="line">        <span class="comment">#2.1 文本URL</span></span><br><span class="line">        self.lbl = QLabel(self)</span><br><span class="line">        self.lbl.setText(<span class="string">"Url:"</span>)</span><br><span class="line">        self.lbl.move(<span class="number">30</span>, <span class="number">93</span>)</span><br><span class="line">        <span class="comment">#2.2 链接URL</span></span><br><span class="line">        self.file_url = QLineEdit(self)</span><br><span class="line">        self.file_url.move(<span class="number">50</span>, <span class="number">90</span>)</span><br><span class="line">        self.file_url.setGeometry(<span class="number">50</span>, <span class="number">90</span>, <span class="number">250</span>, <span class="number">23</span>)</span><br><span class="line">        <span class="comment">#2.3 下载按钮</span></span><br><span class="line">        download_button = QPushButton(<span class="string">'Download'</span>, self)</span><br><span class="line">        download_button.clicked.connect(self.download)</span><br><span class="line">        download_button.move(<span class="number">320</span>, <span class="number">90</span>)</span><br><span class="line">        <span class="comment">#3 端口号按钮</span></span><br><span class="line">        self.download_button = QPushButton(<span class="string">'No Port'</span>, self)</span><br><span class="line">        self.download_button.clicked.connect(self.login)</span><br><span class="line">        self.download_button.move(<span class="number">400</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="comment">#4 日志</span></span><br><span class="line">        self.tmp = QTextEdit(self)</span><br><span class="line">        self.tmp.move(<span class="number">50</span>, <span class="number">120</span>)</span><br><span class="line">        self.tmp.setGeometry(<span class="number">50</span>, <span class="number">120</span>, <span class="number">350</span>, <span class="number">70</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#5 标题</span></span><br><span class="line">        self.setGeometry(<span class="number">300</span>, <span class="number">300</span>, <span class="number">500</span>, <span class="number">200</span>)</span><br><span class="line">        self.setWindowTitle(<span class="string">'服务器加速下载器@cloudcver'</span>)</span><br><span class="line">        self.show()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self)</span>:</span></span><br><span class="line">        text, ok = QInputDialog.getText(self, <span class="string">'Set Port'</span>,</span><br><span class="line">                                        <span class="string">'Enter your port:'</span>)</span><br><span class="line">        <span class="keyword">if</span> ok:</span><br><span class="line">            self.port_default = int(text)</span><br><span class="line">            self.download_button.setText(text)</span><br><span class="line">            self.content_tmp = self.content_tmp + <span class="string">"%s:Set port at %s\n"</span>%(time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime()),text)</span><br><span class="line">            self.tmp.setText(self.content_tmp)</span><br><span class="line">            self.ok = <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.ok:</span><br><span class="line">            self.content_tmp = self.content_tmp + <span class="string">"%s:Send the task to server\n"</span> % (</span><br><span class="line">                time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime()))</span><br><span class="line">            self.tmp.setText(self.content_tmp)</span><br><span class="line">            self.thread = DownloadThread()</span><br><span class="line">            self.thread.set_port_url(self.port_default,self.file_url.text())  <span class="comment"># 创建</span></span><br><span class="line">            self.thread.trigger.connect(self.finish)  <span class="comment"># 连接信号</span></span><br><span class="line">            self.thread.start()  <span class="comment"># 开始线程</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            reply = QMessageBox.question(self, <span class="string">'Message'</span>,</span><br><span class="line">                                         <span class="string">"You should set port first"</span>, QMessageBox.Yes)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self,status,filename)</span>:</span></span><br><span class="line">        print(<span class="string">"sdsd"</span>)</span><br><span class="line">        <span class="keyword">if</span> status == <span class="number">1</span>:</span><br><span class="line">            self.content_tmp = self.content_tmp + <span class="string">"%s:Finish! file save to %s\n"</span> % ((time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime())),filename)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.content_tmp = self.content_tmp + <span class="string">"%s:Fail!\n"</span> % (time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime()))</span><br><span class="line">        self.tmp.setText(self.content_tmp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pyqt基础教程</title>
      <link href="/posts/pyqt%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/posts/pyqt%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>PYQT是python版本的QT界面程序包，大家写过C、C#都做过界面设计，python也一样，非常简单。跟着我的思路走，五分钟学会！</p><h3 id="1、主体框架-先造一个窗口"><a href="#1、主体框架-先造一个窗口" class="headerlink" title="1、主体框架=先造一个窗口"></a>1、主体框架=先造一个窗口</h3><p><strong>以下程序直接抄过去。<br>以下程序直接抄过去。<br>以下程序直接抄过去。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        </span><br><span class="line">        self.initUI() <span class="comment">#界面绘制交给InitUi方法</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#设置窗口的位置和大小</span></span><br><span class="line">        self.setGeometry(<span class="number">300</span>, <span class="number">300</span>, <span class="number">300</span>, <span class="number">220</span>)  </span><br><span class="line">        <span class="comment">#设置窗口的标题</span></span><br><span class="line">        self.setWindowTitle(<span class="string">'Icon'</span>)</span><br><span class="line">        <span class="comment">#设置窗口的图标，引用当前目录下的web.png图片</span></span><br><span class="line">        self.setWindowIcon(QIcon(<span class="string">'web.png'</span>))        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">#显示窗口</span></span><br><span class="line">        self.show()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#创建应用程序和对象</span></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    ex = Example()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/20200311141614384.png" alt="在这里插入图片描述"><br><strong>主函数不用动！<br>主要改initUI函数！<br>主要改initUI函数！<br>主要改initUI函数！</strong></p><h3 id="2-控件-加点功能"><a href="#2-控件-加点功能" class="headerlink" title="2 控件==加点功能"></a>2 控件==加点功能</h3><p>明白一个道理：</p><blockquote><p>1、界面上可以加一些按钮，文本框，输入框等等，都需要导入库，声明一个对象。<br>2、函数：点击按钮连接一个函数，输入框改变连接一个函数，逻辑自己写就行。<br>3、属性：都有属性.text()代表这个控件的文字。</p></blockquote><p>明白这个就可以了，一个一个看！</p><h4 id="2-1-按钮"><a href="#2-1-按钮" class="headerlink" title="2.1 按钮"></a>2.1 按钮</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.qbtn = QPushButton(<span class="string">'Quit'</span>, self)<span class="comment">#声明一个按钮</span></span><br><span class="line">self.qbtn.clicked.connect(self.download())<span class="comment">#点击按钮连接上一个函数</span></span><br><span class="line">self.qbtn.move(<span class="number">400</span>, <span class="number">10</span>)<span class="comment">#位置</span></span><br><span class="line">self.qbtn.setText(text)<span class="comment">#文字属性</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311163643195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-2-输入框"><a href="#2-2-输入框" class="headerlink" title="2.2 输入框"></a>2.2 输入框</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.file_url = QLineEdit(self)#声明一个输入框</span><br><span class="line">self.file_url.move(50, 90)#移动位置</span><br><span class="line">self.file_url.setGeometry(50, 90, 250, 23)#设置位置以及长宽。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311163658210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-3-文本标签"><a href="#2-3-文本标签" class="headerlink" title="2.3 文本标签"></a>2.3 文本标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.lbl = QLabel(self)</span><br><span class="line">self.lbl.setText(&quot;Url:&quot;)</span><br><span class="line">self.lbl.move(30, 93)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200311163711489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-4-文本编辑框"><a href="#2-4-文本编辑框" class="headerlink" title="2.4 文本编辑框"></a>2.4 文本编辑框</h3><p>我用它来输出日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.tmp = QTextEdit(self)</span><br><span class="line">self.tmp.move(50, 120)</span><br><span class="line">self.tmp.setGeometry(50, 120, 350, 70)</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/20200311163727703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-对话框-弹窗消息"><a href="#3-对话框-弹窗消息" class="headerlink" title="3 对话框==弹窗消息"></a>3 对话框==弹窗消息</h3><h4 id="3-1-弹窗输入"><a href="#3-1-弹窗输入" class="headerlink" title="3.1 弹窗输入"></a>3.1 弹窗输入</h4><p>能填一个内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text, ok = QInputDialog.getText(self, &apos;Input Dialog&apos;, </span><br><span class="line">            &apos;Enter your name:&apos;)</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/20200311163740256.png" alt="在这里插入图片描述"></p><h4 id="3-2-打开文件"><a href="#3-2-打开文件" class="headerlink" title="3.2 打开文件"></a>3.2 打开文件</h4><p>弹出打开文件提示框。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fname = QFileDialog.getOpenFileName(self, &apos;Open file&apos;, &apos;/home&apos;)</span><br><span class="line">if fname[0]:</span><br><span class="line">    f = open(fname[0], &apos;r&apos;)</span><br><span class="line">    with f:</span><br><span class="line">        data = f.read()</span><br><span class="line">        self.textEdit.setText(data)</span><br></pre></td></tr></table></figure></p><h3 id="4-更多…"><a href="#4-更多…" class="headerlink" title="4 更多…"></a>4 更多…</h3><p>五分钟了解这些就可以了。<br>更多控件，你可以用啥就百度啥。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>宝塔部署hexo博客到服务器</title>
      <link href="/posts/%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/posts/%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>总结如何部署hexo博客到服务器。<br><a id="more"></a></p><blockquote><p>先前条件：<br>1、域名<br>2、服务器ECS<br>3、本地写过博客</p></blockquote><h2 id="1、安装宝塔"><a href="#1、安装宝塔" class="headerlink" title="1、安装宝塔"></a>1、安装宝塔</h2><p>宝塔是一个服务器托管工具，可以一键部署很多工具。</p><h3 id="1-1开启8888端口"><a href="#1-1开启8888端口" class="headerlink" title="1.1开启8888端口"></a>1.1开启8888端口</h3><p>每个服务器不一样，去服务器设置一下安全端口，把8888打开。</p><h4 id="1-2-安装宝塔"><a href="#1-2-安装宝塔" class="headerlink" title="1.2 安装宝塔"></a>1.2 安装宝塔</h4><p>SSH登陆，参考<a href="https://www.bt.cn/download/linux.html">https://www.bt.cn/download/linux.html</a>安装宝塔</p><p>centos的话直接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure></p><p>….一大堆开始自己跑</p><p>安装完后出来一个网站和账户密码，登陆就可以了，此时不再用SSH了，直接用宝塔网站操作服务器即可。<br><img src="https://img-blog.csdnimg.cn/20200327143646851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意：首次登陆会推荐你安装点东西，安装就好了！！</p><h2 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2 安装git"></a>2 安装git</h2><p>宝塔上有个ssh登陆工具（大概等第一步骤安装完东西）</p><p>登陆SSH后开始操作</p><p>按照我这篇博客操作，记住不用安装和配置nginx了！！这些可以一键部署。</p><p>跳过步骤2即可</p><p><a href="https://blog.csdn.net/CLOUD_J/article/details/104697089">https://blog.csdn.net/CLOUD_J/article/details/104697089</a></p><h2 id="3上传hexo"><a href="#3上传hexo" class="headerlink" title="3上传hexo"></a>3上传hexo</h2><h2 id="4nginx配置"><a href="#4nginx配置" class="headerlink" title="4nginx配置"></a>4nginx配置</h2><p>宝塔-网站-添加网站，如下，域名写你的域名就可以，根目录写你的git/blog目录，就ok了。<br><img src="https://img-blog.csdnimg.cn/2020032714401825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>配置完成。</p><h2 id="5-改为HTTPS"><a href="#5-改为HTTPS" class="headerlink" title="5 改为HTTPS"></a>5 改为HTTPS</h2><p>这个需要加一个SSL证书，去你的域名提供商，搜下SSL，申请免费SSL证书，申请好了，会有个文件可以下载，下载后把那个文件的nginx信息写道宝塔上，<br><img src="https://img-blog.csdnimg.cn/2020032714434929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宝塔 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础问题；super；迭代器；copy；【秋招备战】</title>
      <link href="/posts/Python%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98%EF%BC%9Bsuper%EF%BC%9B%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9Bcopy%EF%BC%9B%E3%80%90%E7%A7%8B%E6%8B%9B%E5%A4%87%E6%88%98%E3%80%91/"/>
      <url>/posts/Python%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98%EF%BC%9Bsuper%EF%BC%9B%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9Bcopy%EF%BC%9B%E3%80%90%E7%A7%8B%E6%8B%9B%E5%A4%87%E6%88%98%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>Python基础问题；super的作用，解决了什么问题，为什么；迭代器，生成器；copy与deepcopy；【秋招备战】<br><a id="more"></a></p><h3 id="1、super的作用，解决了什么问题，为什么"><a href="#1、super的作用，解决了什么问题，为什么" class="headerlink" title="1、super的作用，解决了什么问题，为什么"></a>1、super的作用，解决了什么问题，为什么</h3><p>在类的继承中，如果我们在子类中重写了init函数，则创建子类对象时会调用子类的init函数，不会执行父类的函数。<br>这个时候，有些父类的操作就没法执行。</p><blockquote><p>super() 就是找爹super().<strong>init</strong>(…) 就是说：”爹，先执行一下你的<strong>init</strong>方法，等你干完了我再来做我的事。”用途就是，你继承一个父类了，原先父类的初始化方法里有很多东西，你又不打算自己重新写一遍，那就叫父类先执行原来的逻辑，再执行后边的。</p></blockquote><p><strong>注意：super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     ---&gt; B ---</span><br><span class="line">A --|          |--&gt; D</span><br><span class="line">     ---&gt; C ---</span><br></pre></td></tr></table></figure></p><h3 id="2、copy和deepcopy"><a href="#2、copy和deepcopy" class="headerlink" title="2、copy和deepcopy"></a>2、copy和deepcopy</h3><p>—–我们寻常意义的复制就是深复制，即将被复制对象完全再复制一遍作为独立的新个体单独存在。所以改变原有被复制对象不会对已经复制出来的新对象产生影响。<br>—–而浅复制并不会产生一个独立的对象单独存在，他只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。这就和我们寻常意义上的复制有所不同了。</p><p><strong>（注意：这两个函数都在copy模块中）</strong></p><h3 id="3、生成器、迭代器"><a href="#3、生成器、迭代器" class="headerlink" title="3、生成器、迭代器"></a>3、生成器、迭代器</h3><h4 id="3-1-生成器"><a href="#3-1-生成器" class="headerlink" title="3.1 生成器"></a>3.1 生成器</h4><p>就是一种自定义的迭代器,本质为迭代器，但凡函数内包含yield关键字,调用函数不会执行函数体代码,会得到一个返回值,该返回值就是生成器对象。</p><p>我们可以写一个函数，里面有yield，往外抛出东西，然后你用next可以遍历，一个yield一个执行，执行完了，再next就出错。。<br>例1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fun(index):</span><br><span class="line">yield index</span><br><span class="line">print(&quot;Hello, World!&quot;);</span><br><span class="line">a = fun(1)</span><br><span class="line">print(next(a))</span><br><span class="line">a = fun(100)</span><br><span class="line">print(next(a))</span><br></pre></td></tr></table></figure></p><blockquote><p>Hello, World!<br>1<br>100</p></blockquote><p>例2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">def fun(index):</span><br><span class="line">yield index</span><br><span class="line">yield 2</span><br><span class="line">print(&quot;Hello, World!&quot;);</span><br><span class="line">a = fun(1)</span><br><span class="line">print(next(a))</span><br><span class="line">print(next(a))</span><br><span class="line">a = fun(100)</span><br><span class="line">print(next(a))</span><br></pre></td></tr></table></figure></p><blockquote><p>Hello, World!<br>1<br>2<br>100</p></blockquote><h4 id="3-2迭代器"><a href="#3-2迭代器" class="headerlink" title="3.2迭代器"></a>3.2迭代器</h4><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本的方法：iter() 和 next()。<br>最简单可以这么用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list=[1,2,3,4]&gt;&gt;&gt; it = iter(list)    # 创建迭代器对象&gt;&gt;&gt; print (next(it))   # 输出迭代器的下一个元素</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print (next(it))</span><br><span class="line">2</span><br></pre></td></tr></table></figure><br>再者，你可以创建一个迭代器类，只要包括iter和next两个内定函数即可。<strong>iter</strong>返回迭代器对象，<strong>next</strong>返回迭代下一个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyNumbers: </span><br><span class="line">    def __iter__(self): </span><br><span class="line">        self.a = 1 </span><br><span class="line">        return self </span><br><span class="line">    def __next__(self): </span><br><span class="line">        x = self.a </span><br><span class="line">        self.a += 1 </span><br><span class="line">        return x</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>1、python中，任意对象，只要定义了<strong>next</strong>方法，它就是一个迭代器。<br>2、python中的容器如列表、元组、字典、集合、字符串都可以被称作迭代器。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pyqt多线程操作</title>
      <link href="/posts/pyqt%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C/"/>
      <url>/posts/pyqt%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>多线程是实现并发的一个重要手段。在GUI编程中，经常需要将耗费时间较多的任务分离出来成为一个线程，避免对主线程造成影响(造成界面无响应)。</p><a id="more"></a><p>在Qt中，最简单的多线程主要通过继承QThread类实现，重载虚函数run()。</p><p>1、一般我们先创建一个QThread子类，其中最主要的是run函数，当进程开始时会执行这个函数。<br>2、pyqtSignal()代表pyqt信号，我们在run的结束加一个结束退出信号。这个信号可以绑定connect一个函数，当结束时便会执行此函数。<br>注意：对于信号这个东西，emit也可以传递参数，如果想传递参数，那么绑定的函数也得有参数，并且pyqtSignal创建的时候也得带上参数类型。比如这里我们返回一个状态。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadThread</span><span class="params">(QThread)</span>:</span></span><br><span class="line">    trigger = pyqtSignal(str)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(DownloadThread, self).__init__()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_port_url</span><span class="params">(self,port_default,url)</span>:</span></span><br><span class="line">        self.port_default = port_default</span><br><span class="line">        self.url = url</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># # 循环完毕后发出信号</span></span><br><span class="line">            self.trigger.emit(<span class="string">"success!"</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            self.trigger.emit(<span class="string">"fail!"</span>)</span><br></pre></td></tr></table></figure><br>3、在pyqt界面中，我们会创建一个类，然后为它连接connect一个结束函数，并且通过set_val设定参数，最后start。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">win</span><span class="params">()</span>:</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.ok:</span><br><span class="line">            self.content_tmp = self.content_tmp + <span class="string">"%s:Send the task to server\n"</span> % (</span><br><span class="line">                time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime()))</span><br><span class="line">            self.tmp.setText(self.content_tmp)</span><br><span class="line">            self.thread = DownloadThread()</span><br><span class="line">            self.thread.set_port_url(self.port_default,self.file_url.text())  <span class="comment"># 创建</span></span><br><span class="line">            self.thread.trigger.connect(self.finish)  <span class="comment"># 连接信号</span></span><br><span class="line">            self.thread.start()  <span class="comment"># 开始线程</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            reply = QMessageBox.question(self, <span class="string">'Message'</span>,</span><br><span class="line">                                         <span class="string">"You should set port first"</span>, QMessageBox.Yes)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self,status)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> status == <span class="string">'success!'</span></span><br><span class="line">        self.content_tmp = self.content_tmp + <span class="string">"%s:Finish!\n"</span> % (time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime()))</span><br><span class="line">        self.tmp.setText(self.content_tmp)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">'fali!'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络方面一些基础知识</title>
      <link href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%96%B9%E9%9D%A2%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%96%B9%E9%9D%A2%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>本文总结了一些计算机网络方面的基础知识，包括TCP与UDP区别等等。<br><a id="more"></a></p><h3 id="1、TCP与UDP"><a href="#1、TCP与UDP" class="headerlink" title="1、TCP与UDP"></a>1、TCP与UDP</h3><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><blockquote><p>TCP（Transmission Control Protocol），传输控制协议。<br>UDP（User Data Protocol），用户数据报协议。</p><h4 id="1-2-区别"><a href="#1-2-区别" class="headerlink" title="1.2 区别"></a>1.2 区别</h4><p>简单的说：</p><ul><li>TCP传输可靠，UDP传输不可靠。 、</li><li>TCP传输数据稳定性好，但是速度慢，承受负载比较大；</li><li>UDP传输数据速度快，稳定性就差，承受负载小。<ul><li>TCP连接相当于两根管道（一个用于服务器到客户端，一个用于客户端到服务器），管道里面数据传输是通过字节码传输，传输是有序的，每个字节都是一个一个来传输。</li></ul></li></ul></blockquote><p>深层的说：</p><ul><li>TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。</li><li>TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。</li><li>TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。</li><li>TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制，吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。</li></ul><h4 id="1-3应用"><a href="#1-3应用" class="headerlink" title="1.3应用"></a>1.3应用</h4><ul><li>TCP一般应用在对于稳定性要求比较高的场合，比如传输文件、QQ聊天等。</li><li>UDP一般应用在对于实时性要求比较高的场合，比如视频聊天等等。<h4 id="1-4三次握手、四次挥手"><a href="#1-4三次握手、四次挥手" class="headerlink" title="1.4三次握手、四次挥手"></a>1.4三次握手、四次挥手</h4>TCP建立连接时需要进行三次握手：<blockquote><p>第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认；<br>SYN：同步序列编号(Synchronize Sequence Numbers)<br>第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.</p></blockquote></li></ul><p>四次挥手：终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</p><p>由于TCP是双通道的，两条通道都需要单独关闭，所以客户端向服务器发送FIN，关闭第一条通道（1），服务器接受到FIN后退出等待状态，会发一个ACK（2），服务器也会发送一个FIN，关闭第二条通道（3），客户端接受到后退出等待</p><blockquote><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。<br>  第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。<br>  第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。<br>  第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。<br><img src="https://img-blog.csdnimg.cn/20200310130735152.png" alt="在这里插入图片描述"></p><h4 id="1-5-为啥要三次握手？两次可以不？"><a href="#1-5-为啥要三次握手？两次可以不？" class="headerlink" title="1.5 为啥要三次握手？两次可以不？"></a>1.5 为啥要三次握手？两次可以不？</h4><p><strong>防止失效的连接请求报文段被服务端接收，从而产生错误。</strong></p></blockquote><p>Mark:失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。</p><p>解释：如果只有两次连接的话，客户端发送请求后，如果网络比较拥堵，客户端会再次发送请求，之前的请求就会失效。如果当客户端关闭连接后，那个请求被接受，服务器就会一直等待，消耗资源。</p><h3 id="2、HTTP-与HTTPS"><a href="#2、HTTP-与HTTPS" class="headerlink" title="2、HTTP 与HTTPS"></a>2、HTTP 与HTTPS</h3><p> 超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。<br>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。<br>HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全<br>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><blockquote><p>1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p></blockquote><h3 id="3、get-post-的区别"><a href="#3、get-post-的区别" class="headerlink" title="3、get post 的区别"></a>3、get post 的区别</h3><h3 id="4、输入一个网址到呈现一个界面流程"><a href="#4、输入一个网址到呈现一个界面流程" class="headerlink" title="4、输入一个网址到呈现一个界面流程"></a>4、输入一个网址到呈现一个界面流程</h3><p>第一步：首先你得在浏览器中输入网址，比如输入www.baidu.com。其中www为主机，baidu为域名，com为类型。但是有网址不能直接找到对应的响应主机，必须把网址，即域名转化为ip地址。</p><p>第二步：DNS解析，当在浏览器中输入一个URL，如“www.baidu.com”时，这个地址并不是百度网站真正意义的地址。每一台连上网计算机都有一个唯一标识即它的IP地址，DNS解析就将输入的网址解析成IP地址。<br>DNS解析是一个递归查询的过程，例如要解析“www.baidu.com”时，过程如下：</p><blockquote><p>在本地域名服务器中查询IP地址，未找到域名；<br>本地域名服务器会向根域名服务器发送请求，未找到域名；<br>本地域名服务器向.com顶级域名服务器发送请求，未找到域名；<br>本地域名服务器向.baidu.com域名服务器发送请求，找到该域名，将相应的IP返回给本地域名服务器；</p></blockquote><p>第三步：浏览器发送请求至服务器，假设我们现在输入的地址是www.baidu.com，那么浏览器默认将网址改成这样的形式，即<a href="http://www.baidu.com。进行TCP连接">http://www.baidu.com。进行TCP连接</a></p><p>第四步：渲染浏览器</p><p>第五步：断开TCP连接</p><h3 id="5七层OSI-五层网络"><a href="#5七层OSI-五层网络" class="headerlink" title="5七层OSI/五层网络"></a>5七层OSI/五层网络</h3><p>有篇文章讲的很白话，比较好！大家可以看一下。<br><a href="https://blog.csdn.net/taotongning/article/details/81352985">OSI七层协议大白话解读</a></p><p>然后我做一下我的总结：<br>OSI是网络通信的协议，人们把他分为七层，也有分为五层的。内容都是一样的。通信无非就是发送请求，接受请求。<br>下面这种图展示了五层和七层的关系。<br><img src="https://img-blog.csdnimg.cn/20200311173540208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发送请求的过程是从最顶层（应用层）出发，每一层负责封装属于自己的信息到请求中，最后将一整个请求发送给对方。<br>接收请求的过程是从最底层（网络接口层）开始，每一层的协议负责解析属于自己的东西。<br><img src="https://img-blog.csdnimg.cn/20200311173803830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以太网在解析请求时，先解析IP地址，路由器就干这个事。很厉害。找到IP后，需要根据MAC物理地址（<strong>物理层</strong>），找到局域网内的通信地址。计算机找到我们这台计算机后，还是不知道和哪个软件通信啊，就靠端口号，<strong>传输层</strong>有TCP协议规定着端口号。找到端口号后，HTTP数据就代表<strong>应用层数据</strong>，也可以是其他软件APP；</p><blockquote><p>IP和MAC地址这种映射关系由ARP（Address Resolution Protocol，地址解析协议）协议完成。</p></blockquote><p>（1）物理层：就是硬件地址，每个网卡出厂时都有一个唯一的MAC地址。<br>（3）网络层：IP地址<br>（2）数据链路层：把物理地址和IP数据包起来。控制网络层与物理层的通信。<br><img src="https://img-blog.csdnimg.cn/20200311171929848.png" alt="在这里插入图片描述"><br>（4）传输层：就是我们的TCP、UDP传输协议，你需要把数据按照传输格式传递给某个端口，定义了主机端到端的链接。一个主机有很多端口可以使用。<br>端口范围0-65535，0-1023为系统占用端口<br>（5）应用层：你的软件，QQ、视频、浏览器…<br>TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础知识学习及应用</title>
      <link href="/posts/SQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/posts/SQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本篇文章介绍了一些SQL方面的基础知识。<br><a id="more"></a></p><p>1、查询语法复习<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Select 查询语法复习</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, another_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> condition</span><br><span class="line">    <span class="keyword">AND</span>/<span class="keyword">OR</span> another_condition</span><br><span class="line">    <span class="keyword">AND</span>/<span class="keyword">OR</span> …;</span><br></pre></td></tr></table></figure><br>注意：条件语句</p><ul><li>= 是否相等</li><li>> &lt; &gt;= &lt;= </li><li>Between 1 and 2</li><li>AND OR NOT 与或非；</li><li>LIKE 一般后面接通配符；<br>col_name LIKE “%AT%” 百分号代表这里任意字符都行，也可以没有，_代表必须有一个字符。<br>比如：col_name LIKE “%AN%”此时AND、AN、PAN都是正例；<br>而col_name LIKE “%AN_“此时AND、TAND为正例，TAN为反例。</li><li>IN (…) 在这些字符中；</li></ul><p>2、查询结果排序<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, another_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> condition</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> col_name <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> num_limit <span class="keyword">OFFSET</span> num_offset;</span><br></pre></td></tr></table></figure></p><ul><li>ORDER BY col_name 排序 ASC/DESC升序/降序</li><li>LIMIT num_limit OFFSET num_offset 限制从num_offset开始截断num_limit个。</li><li>多段排序可以<code>ORDER BY col_name ASC,ORDER BY col_name ASC</code>逗号分隔。</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo部署博客到阿里云服务器</title>
      <link href="/posts/hexo%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/posts/hexo%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>由于疫情原因，阿里云免费送了半年的服务器，不得拿来玩玩，然后我就先把我的博客从github上迁移到阿里云上来，以后有问题再换。</p><a id="more"></a><hr><blockquote><p>先前条件：<br>1、服务器<br>2、本地电脑已经安装hexo，并且前期已经上传过GitHub（这样的话，你的本地已经有了密钥）</p></blockquote><p><strong>以下部分全是在服务器端的操作！</strong><br><strong>以下部分全是在服务器端的操作！</strong><br><strong>以下部分全是在服务器端的操作！</strong></p><h3 id="1、配置服务器安全组规则"><a href="#1、配置服务器安全组规则" class="headerlink" title="1、配置服务器安全组规则"></a>1、配置服务器安全组规则</h3><p>由于阿里云是默认不授权80端口的访问的，所以我们要手动配置。</p><p>打开阿里云<strong>服务器管理控制台</strong>-&gt;点击左侧<strong>安全组</strong>-&gt;点击右侧的<strong>配置规则</strong>-&gt;点击<strong>添加安全组规则</strong></p><p>如下图<br><img src="https://img-blog.csdnimg.cn/20200306154335794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2、配置代理nginx"><a href="#2、配置代理nginx" class="headerlink" title="2、配置代理nginx"></a>2、配置代理nginx</h3><p>因为我们是拿nginx做Web服务器，所以我们需要安装部署好nginx，如果没有安装。以下为centos命令，其他自己百度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装执行命令如下</span><br><span class="line">yum install -y nginx</span><br><span class="line">启动服务器：</span><br><span class="line">systemctl start nginx</span><br><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure><br>现在可以访问一下我们的公网IP，会进入一个默认的nginx界面，我的转到了centos介绍界面。</p><p>但是我们实际上是想要让这个地址指向我们的博客，而不是nginx的默认网址，这就需要我们去配置nginx的配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p>找到server，更改如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load modular configuration files from the /etc/nginx/conf.d directory.</span></span><br><span class="line">    <span class="comment"># See http://nginx.org/en/docs/ngx_core_module.html#include</span></span><br><span class="line">    <span class="comment"># for more information.</span></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  www.cloudcver.com;<span class="comment">###改成你的域名；没有域名改成服务器公网IP</span></span><br><span class="line">        root         /home/git/projects/blog;<span class="comment">## 改为服务器上存博客的地址，按照我这写就行。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br></pre></td></tr></table></figure></p><h3 id="3、搭建服务器git仓库"><a href="#3、搭建服务器git仓库" class="headerlink" title="3、搭建服务器git仓库"></a>3、搭建服务器git仓库</h3><h4 id="3-1-安装node"><a href="#3-1-安装node" class="headerlink" title="3.1 安装node"></a>3.1 安装node</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://rpm.nodesource.com/setup_10.x | bash -</span><br><span class="line">yum install -y nodejs</span><br></pre></td></tr></table></figure><h4 id="3-2-安装git"><a href="#3-2-安装git" class="headerlink" title="3.2 安装git"></a>3.2 安装git</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><h4 id="3-3-创建git用户"><a href="#3-3-创建git用户" class="headerlink" title="3.3 创建git用户"></a>3.3 创建git用户</h4><p>先添加一个git用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser git</span><br></pre></td></tr></table></figure><br>修改用户权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 740 /etc/sudoers</span><br><span class="line">vi /etc/sudoers</span><br></pre></td></tr></table></figure><br>添加以下内容<br><img src="https://img-blog.csdnimg.cn/20200306174832830.png" alt="在这里插入图片描述"><br>保存退出后 将sudoers文件权限改回原样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 /etc/sudoers</span><br></pre></td></tr></table></figure><br>设置git用户的密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure></p><h4 id="3-4-创建SSH密钥"><a href="#3-4-创建SSH密钥" class="headerlink" title="3.4 创建SSH密钥"></a>3.4 创建SSH密钥</h4><p>我们本地电脑已经生成过密钥，直接复制到服务器上即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su git</span><br><span class="line">mkdir ~/.ssh</span><br><span class="line">vim ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment">#然后将电脑中~/.ssh/id_rsa.pub内容复制过来粘贴。</span></span><br><span class="line">chmod 600 ~/.ssh/authorzied_keys</span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure></p><h4 id="3-5-创建git仓库"><a href="#3-5-创建git仓库" class="headerlink" title="3.5 创建git仓库"></a>3.5 创建git仓库</h4><p>在git用户下操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p projects/blog # 把项目目录建立起来</span><br><span class="line">mkdir repos &amp;&amp; cd repos</span><br><span class="line">git init --bare blog.git # 创建仓库</span><br><span class="line">cd blog.git/hooks</span><br><span class="line">vim post-receive # 创建一个钩子</span><br></pre></td></tr></table></figure><br>钩子内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f</span><br></pre></td></tr></table></figure><br>保存文件，文件加权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x post-receive # 添加可执行权限</span><br><span class="line">exit # 返回到root用户</span><br><span class="line">chown -R git:git /home/git/repos/blog.git # 给git用户添加权限</span><br></pre></td></tr></table></figure><br>测试以下，在本地电脑上测试。sever_ip为你的公网IP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh git@server_ip</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/20200306175622858.png" alt="在这里插入图片描述"></p><h3 id="4本地电脑上传"><a href="#4本地电脑上传" class="headerlink" title="4本地电脑上传"></a>4本地电脑上传</h3><p>在hexo上添加一个部署的端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    fuwuqi: git@server_ip:/home/git/repos/blog.git</span><br><span class="line">    coding: git@e.coding.net:cloudcver/blogme.git</span><br><span class="line">    github: git@github.com:Harryjun/Harryjun.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><h3 id="5线上更新下"><a href="#5线上更新下" class="headerlink" title="5线上更新下"></a>5线上更新下</h3><p>服务器上reload一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><br>打开自己网站会发现快了很多。<br><a href="https://www.cloudcver.com">www.cloudcver.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow加载预训练模型数据</title>
      <link href="/posts/tensorflow%E5%8A%A0%E8%BD%BD%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE/"/>
      <url>/posts/tensorflow%E5%8A%A0%E8%BD%BD%E9%A2%84%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>tensorflow加载预训练模型数据<br><a id="more"></a></p><h3 id="1、自己写图或者修改后的图加载参数"><a href="#1、自己写图或者修改后的图加载参数" class="headerlink" title="1、自己写图或者修改后的图加载参数"></a>1、自己写图或者修改后的图加载参数</h3><p>Tips 1自己重写了一遍图，加载别人训过的参数，要注意图的变量名字要一致！<br>Tips 2自己写一个图，部分图的变量用预训练的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1去除某些参数</span></span><br><span class="line">exclude = [<span class="string">'MobilenetV1/Logits/Conv2d_1c_1x1/biases'</span>,<span class="string">'global_step'</span>]</span><br><span class="line">variables_to_restore = tf.contrib.framework.get_variables_to_restore(exclude=exclude)</span><br><span class="line">saver = tf.train.Saver(variables_to_restore)</span><br><span class="line"><span class="comment"># 2只加载当前搭建的图中部分变量</span></span><br><span class="line">variables_to_restore = [val <span class="keyword">for</span> val <span class="keyword">in</span> tf.global_variables() <span class="keyword">if</span>  <span class="string">'Adam'</span> <span class="keyword">not</span> <span class="keyword">in</span> val.name <span class="keyword">and</span> <span class="string">'power'</span> <span class="keyword">not</span> <span class="keyword">in</span> val.name <span class="keyword">and</span> <span class="string">'global'</span> <span class="keyword">not</span> <span class="keyword">in</span> val.name <span class="keyword">and</span> <span class="string">'Logits/'</span> <span class="keyword">not</span> <span class="keyword">in</span> val.name]</span><br><span class="line">saver = tf.train.Saver(variables_to_restore)</span><br><span class="line"><span class="comment">#加载参数</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    <span class="comment"># 装载参数</span></span><br><span class="line">    saver.restore(sess,  ckpt_path)</span><br><span class="line">    <span class="comment"># 此时改为所有变量以便于之后保存...</span></span><br><span class="line">    variables_to_restore = [val <span class="keyword">for</span> val <span class="keyword">in</span> tf.global_variables()]</span><br><span class="line">saver = tf.train.Saver(variables_to_restore)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow自建数据集dataset使用</title>
      <link href="/posts/tensorflow%E8%87%AA%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86dataset%E4%BD%BF%E7%94%A8/"/>
      <url>/posts/tensorflow%E8%87%AA%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86dataset%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>tensorflow自建数据集dataset使用<br><a id="more"></a></p><h3 id="1-Dataset"><a href="#1-Dataset" class="headerlink" title="1 Dataset"></a>1 Dataset</h3><p><strong>tensorflow中提供了两个dataset的API，一个是做一个数据源，另一个是做一个管道用来不断提取数据。</strong></p><p><strong>tf.data.Dataset</strong>：表示一串元素（elements），其中每个元素包含了一或多个Tensor对象。例如：在一个图片pipeline中，一个元素可以是单个训练样本，它们带有一个表示图片数据的tensors和一个label组成的pair。有两种不同的方式创建一个dataset：<br>创建一个source (例如：<strong>Dataset.from_tensor_slices()</strong>)， 从一或多个tf.Tensor对象中构建一个dataset<br>应用一个transformation（例如：<strong>Dataset.batch()</strong>），从一或多个tf.data.Dataset对象上构建一个dataset<br><strong>tf.data.Iterator</strong>：它提供了主要的方式来从一个dataset中抽取元素。通过<strong>Iterator.get_next()</strong> 返回的该操作会yields出Datasets中的下一个元素，作为输入pipeline和模型间的接口使用。最简单的iterator是一个“one-shot iterator”，它与一个指定的Dataset相关联，通过它来进行迭代。对于更复杂的使用，Iterator.initializer操作可以使用不同的datasets重新初始化（reinitialize）和参数化（parameterize）一个iterator ，例如，在同一个程序中通过training data和validation data迭代多次。</p><h3 id="2、tf-data-Dataset"><a href="#2、tf-data-Dataset" class="headerlink" title="2、tf.data.Dataset"></a>2、tf.data.Dataset</h3><p>一般我们可以从tensor序列直接导入到Dataset中，如下几个例子，直接是tensor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dataset1 = tf.data.Dataset.from_tensor_slices(tf.random_uniform([<span class="number">4</span>, <span class="number">10</span>]))</span><br><span class="line">print(dataset1.output_types)  <span class="comment"># ==&gt; "tf.float32"</span></span><br><span class="line">print(dataset1.output_shapes)  <span class="comment"># ==&gt; "(10,)"</span></span><br><span class="line"></span><br><span class="line">dataset2 = tf.data.Dataset.from_tensor_slices(</span><br><span class="line">   (tf.random_uniform([<span class="number">4</span>]),</span><br><span class="line">    tf.random_uniform([<span class="number">4</span>, <span class="number">100</span>], maxval=<span class="number">100</span>, dtype=tf.int32)))</span><br><span class="line">print(dataset2.output_types)  <span class="comment"># ==&gt; "(tf.float32, tf.int32)"</span></span><br><span class="line">print(dataset2.output_shapes)  <span class="comment"># ==&gt; "((), (100,))"</span></span><br><span class="line"></span><br><span class="line">dataset3 = tf.data.Dataset.zip((dataset1, dataset2))</span><br><span class="line">print(dataset3.output_types)  <span class="comment"># ==&gt; (tf.float32, (tf.float32, tf.int32))</span></span><br><span class="line">print(dataset3.output_shapes)  <span class="comment"># ==&gt; "(10, ((), (100,)))"</span></span><br></pre></td></tr></table></figure><p>在做图像这方面时，我们可以把图像的path和标签导入，再进行批量处理，dataset有个map函数，对所有的数据执行同一函数，这样我们可以再读取图片，解码图片，resize等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_and_preprocess_from_path_label</span><span class="params">(path, label)</span>:</span></span><br><span class="line">    image = tf.read_file(path)  <span class="comment"># 读取图片</span></span><br><span class="line">    image = tf.image.decode_jpeg(image, channels=<span class="number">3</span>)</span><br><span class="line">    image = tf.image.resize_image_with_crop_or_pad(image, args.img_height, args.img_width)  <span class="comment"># 原始图片大小为(266, 320, 3)，重设为(192, 192)</span></span><br><span class="line">    <span class="comment"># image /= 255.0  # 归一化到[0,1]范围</span></span><br><span class="line">    <span class="keyword">return</span> image, label</span><br><span class="line">dataset = dataset.map(load_and_preprocess_from_path_label)</span><br></pre></td></tr></table></figure><h3 id="3、创建iterator"><a href="#3、创建iterator" class="headerlink" title="3、创建iterator"></a>3、创建iterator</h3><p>创建完Dataset API，我们可以利用iterator访问数据，有四种iterator：<br>one-shot<br>initializable<br>reinitializable<br>feedable</p><h4 id="3-1-make-one-shot-iterator"><a href="#3-1-make-one-shot-iterator" class="headerlink" title="3.1 make_one_shot_iterator()"></a>3.1 make_one_shot_iterator()</h4><p>one-shot iterator是最简单的iterator，它只支持在一个dataset上迭代一次的操作，不需要显式初始化。<br>举个例子，我8个数据，就能遍历八次，我搞十次，当第9次就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">data = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]</span><br><span class="line">dataset = tf.data.Dataset.from_tensor_slices(data)</span><br><span class="line">dataset = dataset.shuffle(8).batch(4).repeat()##不断重复，这样就可以遍历完数据继续遍历。</span><br><span class="line">it = dataset.make_one_shot_iterator()</span><br><span class="line">next_val = it.get_next()</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    for i in range(10):</span><br><span class="line">print(sess.run(next_val))</span><br></pre></td></tr></table></figure><br>结果：<br>因为有17个数据，遍历完一次，最后一次不够batch，就打出一个数，我在训练数据时，加了一个shape判断，shape等于batchsize，再feed，不然就再找下一个iterrator即可。<br><img src="https://img-blog.csdnimg.cn/20200225145132433.png" alt="在这里插入图片描述"></p><h4 id="3-2-make-initializable-iterator"><a href="#3-2-make-initializable-iterator" class="headerlink" title="3.2 make_initializable_iterator()"></a>3.2 make_initializable_iterator()</h4><p>initializable需要显式初始化，他可以对数据加上个参数，feed时候可以给参数。</p><h3 id="4、举例"><a href="#4、举例" class="headerlink" title="4、举例"></a>4、举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># read datasets</span></span><br><span class="line">data_path = pathlib.Path(args.traindata_dir)</span><br><span class="line">all_image_paths = list(data_path.glob(<span class="string">'*.jpg'</span>))</span><br><span class="line">all_image_paths = [str(path) <span class="keyword">for</span> path <span class="keyword">in</span> all_image_paths]  <span class="comment"># 所有图片路径的列表</span></span><br><span class="line"><span class="comment">## 读取csv文件</span></span><br><span class="line">all_image_labels = []</span><br><span class="line"><span class="keyword">with</span> open(args.label_path, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    first = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="keyword">if</span> first == <span class="literal">True</span>:</span><br><span class="line">            first = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            all_image_labels.append(row[<span class="number">1</span>])</span><br><span class="line"><span class="comment">## 打乱数据</span></span><br><span class="line">random_index = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(all_image_paths)):</span><br><span class="line">    random_index.append(i)</span><br><span class="line">random.shuffle(random_index)  <span class="comment"># 打散</span></span><br><span class="line">temp = []</span><br><span class="line">temp2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(random_index)):</span><br><span class="line">    temp.append(all_image_paths[random_index[i]])</span><br><span class="line">    temp2.append(all_image_labels[random_index[i]])</span><br><span class="line">all_image_paths = temp</span><br><span class="line">all_image_labels = temp2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建dataset</span></span><br><span class="line">dataset = tf.data.Dataset.from_tensor_slices((all_image_paths, all_image_labels))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_and_preprocess_from_path_label</span><span class="params">(path, label)</span>:</span></span><br><span class="line">    image = tf.read_file(path)  <span class="comment"># 读取图片</span></span><br><span class="line">    image = tf.image.decode_jpeg(image, channels=<span class="number">3</span>)</span><br><span class="line">    image = tf.image.resize_image_with_crop_or_pad(image, args.img_height, args.img_width)  <span class="comment"># 原始图片大小为(266, 320, 3)，重设为(192, 192)</span></span><br><span class="line">    <span class="comment"># image /= 255.0  # 归一化到[0,1]范围</span></span><br><span class="line">    <span class="keyword">return</span> image, label</span><br><span class="line"></span><br><span class="line">dataset = dataset.map(load_and_preprocess_from_path_label)</span><br><span class="line">dataset = dataset.shuffle(<span class="number">2</span> * args.train_batch_size).batch(args.train_batch_size).repeat()</span><br><span class="line">iterator = dataset.make_initializable_iterator()</span><br><span class="line">img_next = iterator.get_next()</span><br></pre></td></tr></table></figure><p>训练时<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sess.run(iterator.initializer)</span><br><span class="line">print(<span class="string">'Start training...'</span>)</span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(args.train_steps):</span><br><span class="line">    train_batch_data, train_batch_labels = sess.run(img_next)</span><br><span class="line">    <span class="keyword">if</span> train_batch_data.shape[<span class="number">0</span>] != args.train_batch_size:</span><br><span class="line">        train_batch_data, train_batch_labels = sess.run(img_next)</span><br><span class="line">    start_time = time.time()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础知识学习（来自阿里云）</title>
      <link href="/posts/Docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%9D%A5%E8%87%AA%E9%98%BF%E9%87%8C%E4%BA%91%EF%BC%89/"/>
      <url>/posts/Docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%9D%A5%E8%87%AA%E9%98%BF%E9%87%8C%E4%BA%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>之前实习一直听上线的老大说docker，但是一直没让我用过，我就自己学了下，docker是用来做镜像隔离的工具。那么什么是容器与镜像？如何构建容器与镜像？</p><a id="more"></a><h3 id="1、容器与镜像"><a href="#1、容器与镜像" class="headerlink" title="1、容器与镜像"></a>1、容器与镜像</h3><h4 id="1-1-什么是容器"><a href="#1-1-什么是容器" class="headerlink" title="1.1 什么是容器"></a>1.1 什么是容器</h4><p>一般系统下运行的进程是资源共享的，这样会存在一些问题：</p><p><strong>1）进程攻击</strong>：因为这些进程能够相互看到并且进行通信，高级权限的进程可以攻击其他进程；<br><strong>2）共享文件</strong>：因为它们使用的是同一个文件系统，因此会带来两个问题：这些进程可以对于已有的数据进行增删改查，具有高级权限的进程可能会将其他进程的数据删除掉，破坏掉其他进程的正常运行；此外，进程与进程之间的依赖可能会存在冲突，如此一来就会给运维带来很大的压力；<br><strong>3）</strong>资源竞争<em>**</em>：因为这些进程使用的是同一个宿主机的资源，应用之间可能会存在资源抢占的问题，当一个应用需要消耗大量 CPU 和内存资源的时候，就可能会破坏其他应用的运行，导致其他应用无法正常地提供服务。</p><p>所以就有了容器这个东西，让一组进程有一个自己的集合，也就是容器。</p><p>容器就是一个<strong>视图隔离、资源可限制、独立文件系统</strong>的进程集合。所谓“视图隔离”就是能够看到部分进程以及具有独立的主机名等；控制资源使用率则是可以对于内存大小以及 CPU 使用个数等进行限制。容器就是一个进程集合，它将系统的其他资源隔离开来，具有自己独立的资源视图。</p><h4 id="1-2-什么是镜像"><a href="#1-2-什么是镜像" class="headerlink" title="1.2 什么是镜像"></a>1.2 什么是镜像</h4><p><strong>容器</strong>具有一个<strong>独立的文件系统</strong>，因为使用的是系统的资源，所以在独立的文件系统内不需要具备内核相关的代码或者工具，我们只需要提供容器所需的二进制文件、配置文件以及依赖即可。只要容器运行时所需的文件集合都能够具备，那么这个容器就能够运行起来。</p><p>我们将这些容器运行时所需要的所有的文件集合称之为<strong>容器镜像</strong>。</p><p>1）环境依赖冲突，比如做深度学习有时候你的代码对于tf的版本可能有特定要求，版本过高过低都会出问题，这样不同的程序可能对于系统都有着不同的要求。<br>2）文件</p><h3 id="2、如何构建镜像"><a href="#2、如何构建镜像" class="headerlink" title="2、如何构建镜像"></a>2、如何构建镜像</h3><h4 id="2-1-编写DockerFile文件"><a href="#2-1-编写DockerFile文件" class="headerlink" title="2.1 编写DockerFile文件"></a>2.1 编写DockerFile文件</h4><p>一般我们新建一个文件夹，在里面存放必要文件和Dockerfile（名字不能改）文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><br>例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Base Images</span><br><span class="line">## 从天池基础镜像构建</span><br><span class="line">FROM registry.cn-shanghai.aliyuncs.com/tcc-public/python:3</span><br><span class="line"></span><br><span class="line">## 把当前文件夹里的文件构建到镜像的根目录下</span><br><span class="line">ADD . /</span><br><span class="line"></span><br><span class="line">## 指定默认工作目录为根目录（需要把run.sh和生成的结果文件都放在该文件夹下，提交后才能运行）</span><br><span class="line">WORKDIR /</span><br><span class="line"></span><br><span class="line">## 镜像启动后统一执行 sh run.sh</span><br><span class="line">CMD [&quot;sh&quot;, &quot;run.sh&quot;]</span><br></pre></td></tr></table></figure><br><strong>1、RUN命令：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 执行指令，可以安装，可以解压文件</span><br><span class="line">RUN yum install wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure></p><p><strong>2、CMD指令</strong><br>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:<br><strong>CMD 在docker run 时运行。<br>RUN 是在 docker build。</strong><br>作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。<br><strong>注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;sh&quot;, &quot;run.sh&quot;]</span><br><span class="line">CMD [&quot;python&quot;, &quot;helloworld.py&quot;]</span><br></pre></td></tr></table></figure><br><strong>3、COPY<br>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</strong></p><p><strong>4、ENTRYPOINT</strong><br>这个类似于CMD，但是这个指令不会被docker run的参数覆盖，一定会被执行。而且，docker run传递的参数将会作为ENTRYPOINT执行命令的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;/bin/bash&quot;,&quot;run.sh&quot;]</span><br></pre></td></tr></table></figure></p><h4 id="2-2-build-and-push"><a href="#2-2-build-and-push" class="headerlink" title="2.2 build and push"></a>2.2 build and push</h4><p>一般我们编写一个镜像文件后，就可以通过 docker build 命令构建出所需要的应用。构建出的结果存储在本地。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t registry.cn-shenzhen.aliyuncs.com/test_for_tianchi/test_for_tianchi_submit:1.0 .</span><br></pre></td></tr></table></figure><br>其中registry.cn-shenzhen.aliyuncs.com/test_for_tianchi/test_for_tianchi_submit是云端地址，我们现在放在阿里云上的公共仓库，（你也可以自己注册一个），随后1.0代表版本号，用来区别你生成的不同版本。最后还有个.代表要操作的目录当前目录。</p><p>在实际生产环境中，我们需要将它传到云端仓库上。后期测试或使用是将它再拉下来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push registry.cn-shenzhen.aliyuncs.com/test_for_tianchi/test_for_tianchi_submit:1.0</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/20200220161449369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-3-pull-and-run"><a href="#2-3-pull-and-run" class="headerlink" title="2.3 pull and run"></a>2.3 pull and run</h4><p>下拉镜像文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull box:1.12</span><br></pre></td></tr></table></figure><br>通过以下命令查看现存镜像文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><br>运行镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run images_name:version (command)</span><br><span class="line">docker run registry.cn-shanghai.aliyuncs.com/cloudcver_test/test1:1.0 sh run.sh</span><br><span class="line">docker run registry.cn-shanghai.aliyuncs.com/cloudcver_test/test1:1.0</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/20200221145026729.png" alt="在这里插入图片描述"></p><h4 id="2-4一些常见指令"><a href="#2-4一些常见指令" class="headerlink" title="2.4一些常见指令"></a>2.4一些常见指令</h4><p><strong>1、启动一个镜像</strong><br>我们可以启动一个通用的镜像环境，比如ubuntu，再比如到了别人的电脑上可以快速布局一个python3环境，启动一个镜像即可，这时候加一个参数-i就是可以交互式操作，执行指令/bin/bash就可以进入命令行下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br>-i: 交互式操作。<br>-t: 终端。<br>/bin/bash执行的指令，也可以单独就执行一个指令sh run.sh。<br>输入exit退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><br>注意：其实也可以后台启动一个镜像，加一个参数d，随后就docker exec id进入镜像即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name ubuntu-test ubuntu /bin/bash</span><br><span class="line">docker exec -it 243c32535da7 /bin/bash</span><br></pre></td></tr></table></figure><br><strong>2、查看所有容器</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><br>如下展示我们运行的容器直接执行结束了，所以状态是退出的状态。<br><img src="https://img-blog.csdnimg.cn/20200221144744967.png" alt="在这里插入图片描述"><br><strong>3、启动一个容器或者重启</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start 0f09f77f021e</span><br><span class="line">docker restart 0f09f77f021e</span><br></pre></td></tr></table></figure><br><strong>4、停止一个容器</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop sss</span><br></pre></td></tr></table></figure><br><strong>5、删除容器</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f 1e560fca3906</span><br></pre></td></tr></table></figure><br>下面的命令可以清理掉所有处于终止状态的容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure></p><p><strong>6、删除镜像</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi xxx</span><br></pre></td></tr></table></figure><br>CPU镜像：docker run your_image sh run.sh<br>GPU镜像：nvidia-docker run your_image sh run.sh</p><h3 id="3-容器的生命周期"><a href="#3-容器的生命周期" class="headerlink" title="3 容器的生命周期"></a>3 容器的生命周期</h3><p>容器是一组具有隔离特性的进程集合，在使用 docker run 的时候会选择一个镜像来提供独立的文件系统并指定相应的运行程序。这里指定的运行程序称之为 initial 进程，这个 initial 进程启动的时候，容器也会随之启动，当 initial 进程退出的时候，容器也会随之退出。</p><p>因此，可以认为容器的生命周期和 initial 进程的生命周期是一致的。当然，因为容器内不只有这样的一个 initial 进程，initial 进程本身也可以产生其他的子进程或者通过 docker exec 产生出来的运维操作，也属于 initial 进程管理的范围内。当 initial 进程退出的时候，所有的子进程也会随之退出，这样也是为了防止资源的泄漏。</p><p>但是这样的做法也会存在一些问题，首先应用里面的程序往往是有状态的，其可能会产生一些重要的数据，当一个容器退出被删除之后，数据也就会丢失了，这对于应用方而言是不能接受的，所以需要将容器所产生出来的重要数据持久化下来。容器能够直接将数据持久化到指定的目录上，这个目录就称之为数据卷。</p><p>数据卷有一些特点，其中非常明显的就是数据卷的生命周期是独立于容器的生命周期的，也就是说容器的创建、运行、停止、删除等操作都和数据卷没有任何关系，因为它是一个特殊的目录，是用于帮助容器进行持久化的。简单而言，我们会将数据卷挂载到容器内，这样一来容器就能够将数据写入到相应的目录里面了，而且容器的退出并不会导致数据的丢失。</p><p>通常情况下，数据卷管理主要有两种方式：</p><p>第一种是通过 bind 的方式，直接将宿主机的目录直接挂载到容器内；这种方式比较简单，但是会带来运维成本，因为其依赖于宿主机的目录，需要对于所有的宿主机进行统一管理。<br>第二种是将目录管理交给运行引擎。</p><h3 id="4-练习"><a href="#4-练习" class="headerlink" title="4 练习"></a>4 练习</h3><p>任务：阿里云天池大赛docker练习场<br><a href="https://tianchi.aliyun.com/competition/entrance/231759/introduction">https://tianchi.aliyun.com/competition/entrance/231759/introduction</a></p><p>答案备用：<br>answer.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># step 1</span><br><span class="line">print(&quot;hello world!&quot;)</span><br><span class="line"># step 2</span><br><span class="line">import csv</span><br><span class="line">csv_file=csv.reader(open(&apos;/tcdata/num_list.csv&apos;,&apos;r&apos;))</span><br><span class="line">content=[] #用来存储整个文件的数据，存成一个列表，列表的每一个元素又是一个列表，表示的是文件的某一行</span><br><span class="line"></span><br><span class="line">for line in csv_file:</span><br><span class="line">    content.append(int(line[0]))</span><br><span class="line">sum_num = sum(content)</span><br><span class="line">content.sort()</span><br><span class="line">content.reverse()</span><br><span class="line"># step 3</span><br><span class="line">import json</span><br><span class="line">print(content[:10])</span><br><span class="line">test_dict = &#123;&quot;Q1&quot;:&quot;Hello world&quot;,&quot;Q2&quot;:sum_num,&quot;Q3&quot;:content[-10:] &#125;</span><br><span class="line">with open(&quot;./result.json&quot;,&quot;w&quot;) as f:</span><br><span class="line">    json.dump(test_dict,f)</span><br></pre></td></tr></table></figure><br>run.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python answer.py</span><br></pre></td></tr></table></figure><br>Dockerfile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Base Images</span><br><span class="line">## 从天池基础镜像构建</span><br><span class="line">FROM registry.cn-shanghai.aliyuncs.com/tcc-public/python:3</span><br><span class="line"></span><br><span class="line">## 把当前文件夹里的文件构建到镜像的根目录下</span><br><span class="line">ADD . /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 指定默认工作目录为根目录（需要把run.sh和生成的结果文件都放在该文件夹下，提交后才能运行）</span><br><span class="line">WORKDIR /</span><br><span class="line"></span><br><span class="line">## 镜像启动后统一执行 sh run.sh</span><br><span class="line">CMD [&quot;sh&quot;, &quot;run.sh&quot;]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoogleClab使用注意事项  !cd指令失效</title>
      <link href="/posts/GoogleClab%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%20%20!cd%E6%8C%87%E4%BB%A4%E5%A4%B1%E6%95%88/"/>
      <url>/posts/GoogleClab%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%20%20!cd%E6%8C%87%E4%BB%A4%E5%A4%B1%E6%95%88/</url>
      
        <content type="html"><![CDATA[<p>GoogleClab  cd指令失效问题<br><a id="more"></a></p><p><strong>注意：cd命令，用!cd 往往达不到自己的目的，需要用%cd 才能切换目录。</strong><br><img src="https://img-blog.csdnimg.cn/20200220211406806.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoogleClab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch安装linux下</title>
      <link href="/posts/pytorch%E5%AE%89%E8%A3%85linux/"/>
      <url>/posts/pytorch%E5%AE%89%E8%A3%85linux/</url>
      
        <content type="html"><![CDATA[<p>总结装机必要包</p><h3 id="pytorch安装linux"><a href="#pytorch安装linux" class="headerlink" title="pytorch安装linux"></a>pytorch安装linux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># CUDA 10.0</span><br><span class="line">pip install torch==1.2.0 torchvision==0.4.0 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"># CUDA 9.2</span><br><span class="line">pip install torch==1.2.0+cu92 torchvision==0.4.0+cu92 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"># CPU only</span><br><span class="line">pip install torch==1.2.0+cpu torchvision==0.4.0+cpu -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xml文件读取与编写</title>
      <link href="/posts/xml%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E7%BC%96%E5%86%99/"/>
      <url>/posts/xml%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>Xml文件读取与编写<br><a id="more"></a></p><h3 id="Xml文件读取与编写"><a href="#Xml文件读取与编写" class="headerlink" title="Xml文件读取与编写"></a>Xml文件读取与编写</h3><p>xml文件一般如下所示，&lt;&gt;为node；有可能还有属性Attribute，一般网页中会有，我们只是存储信息，就没有涉及，例如<folder id = "sd">；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;annotation&gt;</span><br><span class="line">    &lt;folder&gt;VOC2007&lt;/folder&gt;</span><br><span class="line">    &lt;filename&gt;test_1.jpg&lt;/filename&gt;</span><br><span class="line">    &lt;size&gt;</span><br><span class="line">        &lt;width&gt;1920&lt;/width&gt;</span><br><span class="line">        &lt;height&gt;2560&lt;/height&gt;</span><br><span class="line">        &lt;depth&gt;3&lt;/depth&gt;</span><br><span class="line">    &lt;/size&gt;</span><br><span class="line">    &lt;object&gt;</span><br><span class="line">        &lt;name&gt;object&lt;/name&gt;</span><br><span class="line">        &lt;pose&gt;Unspecified&lt;/pose&gt;</span><br><span class="line">        &lt;truncated&gt;0&lt;/truncated&gt;</span><br><span class="line">        &lt;difficult&gt;0&lt;/difficult&gt;</span><br><span class="line">        &lt;bndbox&gt;</span><br><span class="line">            &lt;xmin&gt;457&lt;/xmin&gt;</span><br><span class="line">            &lt;ymin&gt;436&lt;/ymin&gt;</span><br><span class="line">            &lt;xmax&gt;574&lt;/xmax&gt;</span><br><span class="line">            &lt;ymax&gt;526&lt;/ymax&gt;</span><br><span class="line">        &lt;/bndbox&gt;</span><br><span class="line">    &lt;/object&gt;</span><br><span class="line">&lt;/annotation&gt;</span><br></pre></td></tr></table></figure></p><h4 id="xml文件读取"><a href="#xml文件读取" class="headerlink" title="xml文件读取"></a>xml文件读取</h4><p>标配代码如下，加载包，加载文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from xml.dom.minidom import parse  #加载包</span><br><span class="line">domTree = parse(&quot;./customer.xml&quot;)</span><br><span class="line"># 文档根元素</span><br><span class="line">rootNode = domTree.documentElement</span><br></pre></td></tr></table></figure><br>1、按照节点名称查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 通过名称object获取属性值</span><br><span class="line">list1 = rootNode.getElementsByTagName(&quot;object&quot;)</span><br></pre></td></tr></table></figure><br>此时得到是一个node list<br>2、子节点查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child = list1[0].childNodes</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：<br>1、object子节点为name、…、bndbox等。<br>2、这里也可以继续搜按照名字搜list1[0].getElementsByTagName(“xmin”)<br>3、我们要想打印节点内的text需要对节点继续找子节点list1[0].getElementsByTagName(“xmin”).childNodes[0].value</p></blockquote><h4 id="xml文件写入"><a href="#xml文件写入" class="headerlink" title="xml文件写入"></a>xml文件写入</h4><p>1、创建一个节点，设置属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 新建一个customer节点</span><br><span class="line">customer_node = domTree.createElement(&quot;customer&quot;)</span><br><span class="line">customer_node.setAttribute(&quot;ID&quot;, &quot;C003&quot;)</span><br></pre></td></tr></table></figure><br>2、子节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 创建name节点,并设置textValue</span><br><span class="line">name_node = domTree.createElement(&quot;name&quot;)</span><br><span class="line">name_text_value = domTree.createTextNode(&quot;kavin&quot;)</span><br><span class="line">name_node.appendChild(name_text_value)  # 把文本节点挂到name_node节点</span><br><span class="line">customer_node.appendChild(name_node)</span><br></pre></td></tr></table></figure><br>得到如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;customer ID=&quot;C003&quot;&gt;</span><br><span class="line">    &lt;name&gt;kavin&lt;/name&gt;</span><br><span class="line">  &lt;/customer&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>csv文件转换xml格式文件</title>
      <link href="/posts/csv%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2xml%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6/"/>
      <url>/posts/csv%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2xml%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>csv文件转换xml格式文件</p><a id="more"></a><p>CSV文件格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">image_name,x1,y1,x2,y2,class</span><br><span class="line">db1.jpg,6,1550,145,1704,object</span><br><span class="line">db1.jpg,151,1545,288,1704,object</span><br><span class="line">db1.jpg,291,1552,472,1704,object</span><br><span class="line">db1.jpg,733,1600,863,1704,object</span><br><span class="line">db1.jpg,881,1592,1015,1704,object</span><br><span class="line">db10.jpg,865,592,1043,848,object</span><br><span class="line">db10.jpg,1823,1228,1958,1442,object</span><br><span class="line">db10.jpg,1147,1237,1323,1446,object</span><br><span class="line">db10.jpg,1708,583,1840,832,object</span><br></pre></td></tr></table></figure><br>转xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"># .csv--&gt;.xml</span><br><span class="line"># ! /usr/bin/python</span><br><span class="line"># -*- coding:UTF-8 -*-</span><br><span class="line">import os, sys</span><br><span class="line">import glob</span><br><span class="line">from PIL import Image</span><br><span class="line">import csv</span><br><span class="line">import os</span><br><span class="line">import numpy as np</span><br><span class="line">import random</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># VEDAI 图像存储位置</span><br><span class="line">src_img_dir = &quot;/home/train/dataset-expand/park_voc/VOC2007/JPEGImages&quot;</span><br><span class="line"># VEDAI 图像的 ground truth 的 txt 文件存放位置</span><br><span class="line">src_txt_dir = &quot;/home/train/dataset-expand/label_expand&quot;</span><br><span class="line">src_xml_dir = &quot;/home/train/dataset-expand/park_voc/VOC2007/Annotations&quot;</span><br><span class="line"></span><br><span class="line">img_Lists = glob.glob(src_img_dir + &apos;/*.jpg&apos;)</span><br><span class="line"></span><br><span class="line"># read csv 1 without width and height</span><br><span class="line">file_path = &quot;WebMarket_coco_gt_object.csv&quot;</span><br><span class="line">with open(file_path) as csvfile:</span><br><span class="line">    csv_reader = csv.reader(csvfile)  # 使用csv.reader读取csvfile中的文件</span><br><span class="line">    birth_header = next(csv_reader)  # 读取第一行每一列的标题</span><br><span class="line">    count = 0</span><br><span class="line">    img_pre = &apos;&apos;</span><br><span class="line">    flag = 0</span><br><span class="line">    for row in csv_reader:  # 将csv 文件中的数据保存到birth_data中</span><br><span class="line">        #print(row)</span><br><span class="line">        #first</span><br><span class="line">        if flag == 0:</span><br><span class="line">            img_pre = row[0].split(&apos;.&apos;)[0]</span><br><span class="line">            flag = 1</span><br><span class="line">            xml_file = open((&apos;./WebMarket_coco_gt_object/&apos; + img_pre + &apos;.xml&apos;), &apos;w&apos;)</span><br><span class="line">            xml_file.write(&apos;&lt;annotation&gt;\n&apos;)</span><br><span class="line">            xml_file.write(&apos;    &lt;folder&gt;VOC2007&lt;/folder&gt;\n&apos;)</span><br><span class="line">            xml_file.write(&apos;    &lt;filename&gt;&apos; + str(img_pre) + &apos;.jpg&apos; + &apos;&lt;/filename&gt;\n&apos;)</span><br><span class="line">        img = row[0].split(&apos;.&apos;)[0]</span><br><span class="line">        # new file</span><br><span class="line">        if img != img_pre:</span><br><span class="line">            # close file</span><br><span class="line">            xml_file.write(&apos;&lt;/annotation&gt;&apos;)</span><br><span class="line">            xml_file.close()</span><br><span class="line">            # new file</span><br><span class="line">            xml_file = open((&apos;./WebMarket_coco_gt_object/&apos; + img + &apos;.xml&apos;), &apos;w&apos;)</span><br><span class="line">            xml_file.write(&apos;&lt;annotation&gt;\n&apos;)</span><br><span class="line">            xml_file.write(&apos;    &lt;folder&gt;VOC2007&lt;/folder&gt;\n&apos;)</span><br><span class="line">            xml_file.write(&apos;    &lt;filename&gt;&apos; + str(img) + &apos;.jpg&apos; + &apos;&lt;/filename&gt;\n&apos;)</span><br><span class="line">        #print(img)</span><br><span class="line"></span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        xml_file.write(&apos;    &lt;size&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;        &lt;width&gt;&apos; + str(width) + &apos;&lt;/width&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;        &lt;height&gt;&apos; + str(height) + &apos;&lt;/height&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;        &lt;depth&gt;3&lt;/depth&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;    &lt;/size&gt;\n&apos;)</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        xml_file.write(&apos;    &lt;object&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;        &lt;name&gt;&apos; + str(row[5]) + &apos;&lt;/name&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;        &lt;pose&gt;Unspecified&lt;/pose&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;        &lt;truncated&gt;0&lt;/truncated&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;        &lt;difficult&gt;0&lt;/difficult&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;        &lt;bndbox&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;            &lt;xmin&gt;&apos; + str(row[1]) + &apos;&lt;/xmin&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;            &lt;ymin&gt;&apos; + str(row[2]) + &apos;&lt;/ymin&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;            &lt;xmax&gt;&apos; + str(row[3]) + &apos;&lt;/xmax&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;            &lt;ymax&gt;&apos; + str(row[4]) + &apos;&lt;/ymax&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;        &lt;/bndbox&gt;\n&apos;)</span><br><span class="line">        xml_file.write(&apos;    &lt;/object&gt;\n&apos;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml </tag>
            
            <tag> csv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>labelme多目标标注问题</title>
      <link href="/posts/labelme%E5%A4%9A%E7%9B%AE%E6%A0%87%E6%A0%87%E6%B3%A8%E9%97%AE%E9%A2%98/"/>
      <url>/posts/labelme%E5%A4%9A%E7%9B%AE%E6%A0%87%E6%A0%87%E6%B3%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在labelme标注多目标时存在不匹配的问题，任何一张图片都是从1开始，不能自定义标签号，考虑改写json2datasets文件，使他根据标签名称去定义标签号。</p><a id="more"></a><h3 id="labelme多目标标注问题"><a href="#labelme多目标标注问题" class="headerlink" title="labelme多目标标注问题"></a>labelme多目标标注问题</h3><blockquote><p>问题：在labelme标注多目标时存在不匹配的问题，任何一张图片都是从1开始，不能自定义标签号，考虑改写json2datasets文件，使他根据标签名称去定义标签号。</p></blockquote><p>解决：<br>我的目录层级是</p><blockquote><p>/datasets_new/img1/img1_fuse.jpg<br>/datasets_new/img1/img1_fuse.json<br>/datasets_new/img2/img2_fuse.jpg<br>/datasets_new/img2/img2_fuse.json<br>…</p></blockquote><p>执行脚本就把目录下所有json转换完毕，大家可以根据不同的目录方式，可以自行修改代码，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> PIL.Image</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> labelme <span class="keyword">import</span> utils</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    warnings.warn(<span class="string">"This script is aimed to demonstrate how to convert the\n"</span></span><br><span class="line">                  <span class="string">"JSON file to a single image dataset, and not to handle\n"</span></span><br><span class="line">                  <span class="string">"multiple JSON files to generate a real-use dataset."</span>)</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'data_path'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-o'</span>, <span class="string">'--out'</span>, default=<span class="literal">None</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#对不同标签定义一个号，每个号有自己的颜色...从1开始排就可以</span></span><br><span class="line">    label_name_to_value = &#123;<span class="string">'_background_'</span>: <span class="number">0</span>,</span><br><span class="line">                           <span class="string">'change'</span>:<span class="number">1</span>,</span><br><span class="line">                           <span class="string">'disappear'</span>:<span class="number">2</span>,</span><br><span class="line">                           <span class="string">'add'</span>:<span class="number">3</span>&#125;</span><br><span class="line">    count = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(args.data_path):</span><br><span class="line">        path1 = os.path.join(args.data_path,i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> os.listdir(path1):</span><br><span class="line">            path2 = os.path.join(path1, j)</span><br><span class="line">            <span class="keyword">if</span> path2.split(<span class="string">'.'</span>)[<span class="number">-1</span>] != <span class="string">'json'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count.append(path2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(count)):</span><br><span class="line">        path = count[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">            data = json.load(open(path))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> data[<span class="string">'imageData'</span>]:</span><br><span class="line">                imageData = data[<span class="string">'imageData'</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                imagePath = os.path.join(os.path.dirname(path), data[<span class="string">'imagePath'</span>])</span><br><span class="line">                <span class="keyword">with</span> open(imagePath, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    imageData = f.read()</span><br><span class="line">                    imageData = base64.b64encode(imageData).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            img = utils.img_b64_to_arr(imageData)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> shape <span class="keyword">in</span> data[<span class="string">'shapes'</span>]:</span><br><span class="line">                label_name = shape[<span class="string">'label'</span>]</span><br><span class="line">                <span class="keyword">if</span> label_name <span class="keyword">in</span> label_name_to_value:</span><br><span class="line">                    label_value = label_name_to_value[label_name]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    label_value = len(label_name_to_value)</span><br><span class="line">                    label_name_to_value[label_name] = label_value</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># label_values must be dense</span></span><br><span class="line">            label_values, label_names = [], []</span><br><span class="line">            <span class="keyword">for</span> ln, lv <span class="keyword">in</span> sorted(label_name_to_value.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]):</span><br><span class="line">                label_values.append(lv)</span><br><span class="line">                label_names.append(ln)</span><br><span class="line">            <span class="keyword">assert</span> label_values == list(range(len(label_values)))</span><br><span class="line">            </span><br><span class="line">            lbl = utils.shapes_to_label(img.shape, data[<span class="string">'shapes'</span>], label_name_to_value)</span><br><span class="line">            </span><br><span class="line">            captions = [<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(lv, ln)</span><br><span class="line">                <span class="keyword">for</span> ln, lv <span class="keyword">in</span> label_name_to_value.items()]</span><br><span class="line">            lbl_viz = utils.draw_label(lbl, img, captions)</span><br><span class="line">            </span><br><span class="line">            out_dir = osp.basename(count[i]).replace(<span class="string">'.'</span>, <span class="string">'_'</span>)</span><br><span class="line">            out_dir = osp.join(osp.dirname(count[i]), out_dir)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> osp.exists(out_dir):</span><br><span class="line">                os.mkdir(out_dir)</span><br><span class="line">            print(out_dir)</span><br><span class="line">            name=out_dir.split(<span class="string">'/'</span>)</span><br><span class="line">            rename=name[<span class="number">2</span>]+<span class="string">'_'</span>+name[<span class="number">1</span>]</span><br><span class="line">            PIL.Image.fromarray(img).save(osp.join(out_dir, rename+<span class="string">'_'</span>+<span class="string">'img.png'</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment">#PIL.Image.fromarray(lbl).save(osp.join(out_dir, rename+'label.png'))</span></span><br><span class="line">            utils.lblsave(osp.join(out_dir,rename+<span class="string">'_'</span>+<span class="string">'label.png'</span>), lbl)</span><br><span class="line">            PIL.Image.fromarray(lbl_viz).save(osp.join(out_dir,rename+<span class="string">'_'</span>+<span class="string">'label_viz.png'</span>))</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">with</span> open(osp.join(out_dir, <span class="string">'label_names.txt'</span>), <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">for</span> lbl_name <span class="keyword">in</span> label_names:</span><br><span class="line">                    f.write(lbl_name + <span class="string">'\n'</span>)</span><br><span class="line"> </span><br><span class="line">            warnings.warn(<span class="string">'info.yaml is being replaced by label_names.txt'</span>)</span><br><span class="line">            info = dict(label_names=label_names)</span><br><span class="line">            <span class="keyword">with</span> open(osp.join(out_dir, <span class="string">'info.yaml'</span>), <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                yaml.safe_dump(info, f, default_flow_style=<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">            print(<span class="string">'Saved to: %s'</span> % out_dir)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><p>执行完毕后，目录变为</p><blockquote><p>/datasets_new/img1/img1_fuse.jpg<br>/datasets_new/img1/img1_fuse.json<br>/datasets_new/img1/img1_fuse_json/….(生成的东西)<br>/datasets_new/img2/img2_fuse.json</p></blockquote><p>想把它拷贝到上一级目录，可以执行脚本处理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> os.listdir(<span class="string">'./dataset_new'</span>):</span><br><span class="line">    print(index)</span><br><span class="line">    <span class="comment">#path = os.path.join('./dataset_test',index,index+'_mask_jpg')</span></span><br><span class="line">    path = os.path.join(<span class="string">'./dataset_new'</span>, index,index+<span class="string">'_fuse_json'</span>, index+<span class="string">'_dataset_new_label.png'</span>)</span><br><span class="line">    print(path)</span><br><span class="line">    <span class="comment">#if os.path.isdir(path):</span></span><br><span class="line">    <span class="comment">#    os.rmdir(path)</span></span><br><span class="line">    <span class="keyword">if</span> (os.path.exists(path)):</span><br><span class="line">        <span class="comment">#os.remove(os.path.join('./dataset_new', index, index+'_fuse.png'))</span></span><br><span class="line">        shutil.copyfile(path, os.path.join(<span class="string">'./dataset_new'</span>, index, index + <span class="string">'_label.png'</span>))</span><br><span class="line">        <span class="comment">#os.rename(path,os.path.join('./dataset_new', index, index+'_fuse.json'))</span></span><br></pre></td></tr></table></figure><br>最后变为</p><blockquote><p>/datasets_new/img1/img1_fuse.jpg<br>/datasets_new/img1/img1_fuse.json<br>/datasets_new/img1/img1_label.png</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> labelme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巧妙运用GoogleDrive谷歌云盘GPU免费训练</title>
      <link href="/posts/%E5%B7%A7%E5%A6%99%E8%BF%90%E7%94%A8GoogleDrive%E8%B0%B7%E6%AD%8C%E4%BA%91%E7%9B%98GPU%E5%85%8D%E8%B4%B9%E8%AE%AD%E7%BB%83/"/>
      <url>/posts/%E5%B7%A7%E5%A6%99%E8%BF%90%E7%94%A8GoogleDrive%E8%B0%B7%E6%AD%8C%E4%BA%91%E7%9B%98GPU%E5%85%8D%E8%B4%B9%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<p>巧妙运用GoogleDrive谷歌云盘GPU免费训练<br><a id="more"></a><br>&gt;</p><blockquote><blockquote><p>谷歌云盘配置：<br>存储：15GB（超出花钱）<br>GPU：Tesla T4 *1<br>你的要求：<br>网络：外网</p></blockquote></blockquote><h3 id="巧妙运用GoogleDrive谷歌云盘GPU免费训练"><a href="#巧妙运用GoogleDrive谷歌云盘GPU免费训练" class="headerlink" title="巧妙运用GoogleDrive谷歌云盘GPU免费训练"></a>巧妙运用GoogleDrive谷歌云盘GPU免费训练</h3><h4 id="Tips-1-登陆GoogleDrive创建Colaboratory"><a href="#Tips-1-登陆GoogleDrive创建Colaboratory" class="headerlink" title="Tips 1 登陆GoogleDrive创建Colaboratory"></a>Tips 1 登陆GoogleDrive创建Colaboratory</h4><p>转到网站<a href="https://drive.google.com">https://drive.google.com</a>，创建一个文件夹，你随意，在文件夹内创建一个Colaboratory notebook，<strong>右键，新建-更多-Colaboratory</strong><br>注意：如果找不到Colaboratory的话，<strong>点“关联更多应用”</strong>，找到<strong>Colaboratory</strong>再下载后继续上面操作<br><img src="https://img-blog.csdnimg.cn/20200131164859917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="图1"></p><p><img src="https://img-blog.csdnimg.cn/20200131165108227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="Tips-2-配置Colaboratory"><a href="#Tips-2-配置Colaboratory" class="headerlink" title="Tips 2 配置Colaboratory"></a>Tips 2 配置Colaboratory</h4><p>双击打开笔记本，到如下界面，点击<strong>修改-笔记本设置</strong>，修改为<strong>python3与GPU</strong>，保存即可。<br><img src="https://img-blog.csdnimg.cn/2020013116524030.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200131165335831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="Tips-3-授权"><a href="#Tips-3-授权" class="headerlink" title="Tips 3 授权"></a>Tips 3 授权</h4><p>到笔记本正文，复制以下代码运行，进行授权。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">!apt-get install -y -qq software-properties-common python-software-properties module-init-tools</span><br><span class="line">!add-apt-repository -y ppa:alessandro-strada/ppa 2&gt;&amp;1 &gt; /dev/null</span><br><span class="line">!apt-get update -qq 2&gt;&amp;1 &gt; /dev/null</span><br><span class="line">!apt-get -y install -qq google-drive-ocamlfuse fuse</span><br><span class="line">from google.colab import auth</span><br><span class="line">auth.authenticate_user()</span><br><span class="line">from oauth2client.client import GoogleCredentials</span><br><span class="line">creds = GoogleCredentials.get_application_default()</span><br><span class="line">import getpass</span><br><span class="line">!google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; &lt; /dev/null 2&gt;&amp;1 | grep URL</span><br><span class="line">vcode = getpass.getpass()</span><br><span class="line">!echo &#123;vcode&#125; | google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125;</span><br></pre></td></tr></table></figure><br>执行会出现下面界面，点击链接登陆会有一个验证码，填到这里即可。<br><img src="https://img-blog.csdnimg.cn/20200131165640824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="Tips-4-跑代码"><a href="#Tips-4-跑代码" class="headerlink" title="Tips 4 跑代码"></a>Tips 4 跑代码</h4><p>挂载云盘中的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!mkdir -p drive</span><br><span class="line">!google-drive-ocamlfuse drive</span><br></pre></td></tr></table></figure><br>这样你把文件传到云盘就可以啦，剩下的就是常规指令。<br>譬如：<br>安装某包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install -q keras</span><br></pre></td></tr></table></figure><br>运行某文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!python 1.py</span><br></pre></td></tr></table></figure><br>执行python指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br></pre></td></tr></table></figure></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://zhuanlan.zhihu.com/p/33344222">https://zhuanlan.zhihu.com/p/33344222</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
            <tag> Google Drive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习基础问题总结（二）</title>
      <link href="/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>BN；linux常用指令；正则化；<br><a id="more"></a></p><h2 id="一、BN批量标准化（手撕！！）"><a href="#一、BN批量标准化（手撕！！）" class="headerlink" title="一、BN批量标准化（手撕！！）"></a>一、BN批量标准化（手撕！！）</h2><h4 id="1-1-独立同分布"><a href="#1-1-独立同分布" class="headerlink" title="1.1 独立同分布"></a>1.1 独立同分布</h4><p>（1）去除特征之间的相关性 —&gt; 独立；</p><p>（2）使得所有特征具有相同的均值和方差 —&gt; 同分布。</p><p>在训练时我们希望输入的数据能够是独立同分布的话最好，独立同分布的数据之间具有独立性，每个特征不会相互影响，都是最后结果的一个条件，这一点是好的；<br>第二点，对于每一个特征应该具有同分布，这样训练起来使得网络训练更快！收敛更快。</p><h4 id="1-2-ICS影响"><a href="#1-2-ICS影响" class="headerlink" title="1.2 ICS影响"></a>1.2 ICS影响</h4><p>深度神经网络模型的训练为什么会很困难？其中一个重要的原因是，深度神经网络涉及到很多层的叠加，而每一层的参数更新会导致上层的输入数据分布发生变化，通过层层叠加，高层的输入分布变化会非常剧烈，这就使得高层需要不断去重新适应底层的参数更新。为了训好模型，我们需要非常谨慎地去设定学习率、初始化权重、以及尽可能细致的参数更新策略。</p><p>简而言之，每个神经元的输入数据不再是“独立同分布”。</p><p>其一，上层参数需要不断适应新的输入数据分布，降低学习速度。</p><p>其二，下层输入的变化可能趋向于变大或者变小，导致上层落入饱和区，使得学习过早停止。</p><p>其三，每层的更新都会影响到其它层，因此每层的参数更新策略需要尽可能的谨慎。</p><h4 id="1-3-BN来了"><a href="#1-3-BN来了" class="headerlink" title="1.3 BN来了"></a>1.3 BN来了</h4><p>BN的算法如下所示，某一层网络的输出会得到特征x，然后计算这一个batchsize下的均值，m代表batchsize，xi是每个数据的该特征。然后求均值，然后就标准化，到这大家都理解。后面它又来了可尺度变换和缩放，相当于又变道一个服从N(gama,beta)的分布了！这里的gama和beta都是参数，是需要训练的，相当于我们为每一层网络的输出每一个特征训练了一个分布。哈哈<br><img src="https://img-blog.csdnimg.cn/20191212163940370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-4手撕代码"><a href="#1-4手撕代码" class="headerlink" title="1.4手撕代码"></a>1.4手撕代码</h4><p>主要是反向传播推到！</p><p>反向传播求梯度：</p><p>因为：</p><script type="math/tex; mode=display">{y^{(k)} } = {\gamma ^{(k)} }{\widehat x^{(k)} } + {\beta ^{(k)} }</script><p>所以：</p><script type="math/tex; mode=display">{ {\partial l} \over {\partial { {\widehat x}_i} } } = { {\partial l} \over {\partial {y_i} } }\gamma</script><p>因为：</p><script type="math/tex; mode=display">{\widehat x_i} = { { {x_i} - {\mu _B} } \over {\sqrt {\sigma _B^2 + \varepsilon } } }</script><p>所以：</p><script type="math/tex; mode=display">{ {\partial l} \over {\partial \sigma _B^2} } = {\sum\limits_{i = 1}^m { { {\partial l} \over {\partial { {\widehat x}_i} } } ( {x_i} - {u_B}) { { - 1} \over 2}(\sigma _B^2 + \varepsilon )} ^{ - {3 \over 2} } }</script><script type="math/tex; mode=display">{ {\partial l} \over {\partial {u_B} } } = \sum\limits_{ {\rm{i = 1} } }^m { { {\partial l} \over {\partial { {\widehat x}_i} } } } { { - 1} \over {\sqrt {\sigma _B^2 + \varepsilon } } }</script><p>因为：</p><script type="math/tex; mode=display">{\mu _B} = {1 \over m}\sum\limits_{i = 1}^m { {x_i} }</script><p>和</p><script type="math/tex; mode=display">\sigma _B^2 = {1 \over m}\sum\limits_{i = 1}^m {({x_i} }  - {\mu _B}{)^2}</script><p>所以：</p><script type="math/tex; mode=display">{ {\partial l} \over {\partial {x_i} } } = { {\partial l} \over {\partial { {\widehat x}_i} } }{1 \over {\sqrt {\sigma _B^2 + \varepsilon } } } + { {\partial l} \over {\partial \sigma _B^2} } { {2({x_i} - {\mu _B} ) } \over m} + { {\partial l} \over {\partial {u_B} } }{1 \over m}</script><p>所以：</p><script type="math/tex; mode=display">{ {\partial l} \over {\partial \gamma } } = \sum\limits_{i = 1}^m { { {\partial l} \over {\partial {y_i} } } } {\widehat x_i}</script><script type="math/tex; mode=display">{ {\partial l} \over {\partial \beta } } = \sum\limits_{i = 1}^m { { {\partial l} \over {\partial {y_i} } } }</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def batchnorm_backward(dout, cache):</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  Inputs:</span><br><span class="line">  - dout: 上一层的梯度，维度(N, D)，即 dL/dy</span><br><span class="line">  - cache: 所需的中间变量，来自于前向传播</span><br><span class="line"></span><br><span class="line">  Returns a tuple of:</span><br><span class="line">  - dx: (N, D)维的 dL/dx</span><br><span class="line">  - dgamma: (D,)维的dL/dgamma</span><br><span class="line">  - dbeta: (D,)维的dL/dbeta</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">    x, gamma, beta, x_hat, sample_mean, sample_var, eps = cache</span><br><span class="line">  N = x.shape[0]</span><br><span class="line"></span><br><span class="line">  dgamma = np.sum(dout * x_hat, axis = 0)</span><br><span class="line">  dbeta = np.sum(dout, axis = 0)</span><br><span class="line"></span><br><span class="line">  dx_hat = dout * gamma</span><br><span class="line">  dsigma = -0.5 * np.sum(dx_hat * (x - sample_mean), axis=0) * np.power(sample_var + eps, -1.5)</span><br><span class="line">  dmu = -np.sum(dx_hat / np.sqrt(sample_var + eps), axis=0) - 2 * dsigma*np.sum(x-sample_mean, axis=0)/ N</span><br><span class="line">  dx = dx_hat /np.sqrt(sample_var + eps) + 2.0 * dsigma * (x - sample_mean) / N + dmu / N</span><br><span class="line"></span><br><span class="line">  return dx, dgamma, dbeta</span><br></pre></td></tr></table></figure><h2 id="二、Linux环境下常用指令（必备！！）"><a href="#二、Linux环境下常用指令（必备！！）" class="headerlink" title="二、Linux环境下常用指令（必备！！）"></a>二、Linux环境下常用指令（必备！！）</h2><p>1、查看当前进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aus</span><br></pre></td></tr></table></figure><br>2、vim操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim xxx.xx  //编辑文件</span><br></pre></td></tr></table></figure></p><ul><li>进入为命令行界面，按“i”进入insert输入界面，可以编辑操作，写完后，按ESC退出，回到命令行界面；<ul><li>如果不想保存按住“:q!”强制退出；如果想保存按住“:wq”即可；</li><li>命令行界面下搜索指令：“/word”;向下搜索；n继续向下搜索；<br>“?word”向上搜索 n继续向上搜索 N反向搜索；</li><li>nG到第n行</li><li>多窗口操作，打开一个窗口后，:sp yyy.xx打开另一个文件，两个文件一起看，先按住ctr+w+再上下按钮切换窗口；</li></ul></li></ul><p>3、显示信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls ccc/ -a //显示所有信息</span><br><span class="line">ls ccc/ -l // 显示列表信息 等同于 ll ccc/</span><br></pre></td></tr></table></figure><br>4、软连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s ccc/sss ./test //把他软连到test</span><br></pre></td></tr></table></figure><br>5、创建一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch 2.zz</span><br></pre></td></tr></table></figure><br>6、显示绝对路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><br>7、查看内存情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><br>8、查看GPU情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><br>9、查看IP地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><br>10、删除|移动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv aaa bbb              //移动文件</span><br><span class="line">mv -r aaa/ bbb/      //移动文件夹</span><br><span class="line">rm  aaa    //删除文件</span><br></pre></td></tr></table></figure></p><p>11、</p><h2 id="三、关于正则化问题"><a href="#三、关于正则化问题" class="headerlink" title="三、关于正则化问题"></a>三、关于正则化问题</h2><h4 id="1-什么是过拟合"><a href="#1-什么是过拟合" class="headerlink" title="1.什么是过拟合"></a>1.什么是过拟合</h4><p>过拟合是指我们训练的网络过度拟合以满足在训练集有一个完美的效果，但是过度完美他会使得一些噪声也能拟合好，这样对于测试集不利。下图所示。<br>其实就是欠拟合代表拟合效果过于简单，过拟合就是拟合效果过于复杂<br><img src="https://img-blog.csdnimg.cn/20191212195835293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-2-解决过拟合的方法"><a href="#1-2-解决过拟合的方法" class="headerlink" title="1.2 解决过拟合的方法"></a>1.2 解决过拟合的方法</h4><p>1、减少特征数量：其实也等同于网络简单化，网络太复杂，参数多固然拟合效果足够好，所以针对不同的数据会对应不同复杂度的网络，这样才能减少过拟合。<br>2、正则化项：正则化也叫惩罚因子，目标函数追求越小越好，可能他会无法无天的改变模型，我们加一个惩罚控制模型的趋势，让他模型不要太复杂，所以就有了L1、L2正则化<br>3、dropout<br>在2012年，Hinton在其论文《Improving neural networks by preventing co-adaptation of feature detectors》中提出Dropout。当一个复杂的前馈神经网络被训练在小的数据集时，容易造成过拟合。为了防止过拟合，可以通过阻止特征检测器的共同作用来提高神经网络的性能。<br>Dropout说的简单一点就是：我们在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征。那么具体到代码怎么干呢？<br>在没有dropout时，代码如下图所示，就是简单的一个感知机。<br><img src="https://img-blog.csdnimg.cn/20191214160404221.png" alt="在这里插入图片描述"><br>引入dropout后，我们需要首先生成一个概率参数，值为0/1的一个序列，让y去乘这个概率，实际就让某些输入变为0，其实就是上一层的神经元白计算了，没有向后传播。<br>这样搞有一个固定的比例k代表我们要禁止多少比例神经元，如果禁止掉0.4，那么相当远其他神经元的权重作用就会增加，测试时我们还需要对每个神经元乘(1-k)。让他发挥0.6的作用（<strong>好好理解下</strong>）<br><img src="https://img-blog.csdnimg.cn/20191214160349979.png" alt="在这里插入图片描述"></p><blockquote><p>为什么说dropout具有防止过拟合的效果：<br>（1）取平均的作用： 先回到标准的模型即没有dropout，我们用相同的训练数据去训练5个不同的神经网络，一般会得到5个不同的结果，此时我们可以采用 “5个结果取均值”或者“多数取胜的投票策略”去决定最终结果。例如3个网络判断结果为数字9,那么很有可能真正的结果就是数字9，其它两个网络给出了错误结果。这种“综合起来取平均”的策略通常可以有效防止过拟合问题。因为不同的网络可能产生不同的过拟合，取平均则有可能让一些“相反的”拟合互相抵消。dropout掉不同的隐藏神经元就类似在训练不同的网络，随机删掉一半隐藏神经元导致网络结构已经不同，整个dropout过程就相当于对很多个不同的神经网络取平均。而不同的网络产生不同的过拟合，一些互为“反向”的拟合相互抵消就可以达到整体上减少过拟合。<br>（2）减少神经元之间复杂的共适应关系： 因为dropout程序导致两个神经元不一定每次都在一个dropout网络中出现。这样权值的更新不再依赖于有固定关系的隐含节点的共同作用，阻止了某些特征仅仅在其它特定特征下才有效果的情况 。迫使网络去学习更加鲁棒的特征 ，这些特征在其它的神经元的随机子集中也存在。换句话说假如我们的神经网络是在做出某种预测，它不应该对一些特定的线索片段太过敏感，即使丢失特定的线索，它也应该可以从众多其它线索中学习一些共同的特征。从这个角度看dropout就有点像L1，L2正则，减少权重使得网络对丢失特定神经元连接的鲁棒性提高。<br>（3）Dropout类似于性别在生物进化中的角色：物种为了生存往往会倾向于适应这种环境，环境突变则会导致物种难以做出及时反应，性别的出现可以繁衍出适应新环境的变种，有效的阻止过拟合，即避免环境改变时物种可能面临的灭绝。</p></blockquote><p>贴个代码，大家看看<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># dropout函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropout</span><span class="params">(x, level)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> level &lt; <span class="number">0.</span> <span class="keyword">or</span> level &gt;= <span class="number">1</span>:  <span class="comment"># level是概率值，必须在0~1之间</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Dropout level must be in interval [0, 1[.'</span>)</span><br><span class="line">    retain_prob = <span class="number">1.</span> - level</span><br><span class="line">    <span class="comment"># 我们通过binomial函数，生成与x（x表示输入数据，要对其dropout）一样的维数向量。</span></span><br><span class="line">    <span class="comment"># binomial函数就像抛硬币一样，我们可以把每个神经元当做抛硬币一样</span></span><br><span class="line">    <span class="comment"># 硬币正面的概率为p，n表示每个神经元试验的次数</span></span><br><span class="line">    <span class="comment"># 因为我们每个神经元只需要抛一次就可以了所以n=1，size参数是我们有多少个硬币。</span></span><br><span class="line">    <span class="comment"># 即将生成一个0、1分布的向量，0表示这个神经元被屏蔽，不工作了，也就是dropout了</span></span><br><span class="line">    sample = np.random.binomial(n=<span class="number">1</span>, p=retain_prob, size=x.shape)</span><br><span class="line">    print(sample)  <span class="comment"># 【0,1,0,1。。。】有点像独热</span></span><br><span class="line">    <span class="comment"># 0、1与x相乘，我们就可以屏蔽某些神经元，让它们的值变为0。1则不影响</span></span><br><span class="line">    x *= sample</span><br><span class="line">    print(x)</span><br><span class="line">    <span class="comment"># 对余下的非0的进行扩大倍数,因为p&lt;0。0/x=0,所以0不影响</span></span><br><span class="line">    x /= retain_prob</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对dropout的测试，大家可以跑一下上面的函数，了解一个输入x向量，经过dropout的结果</span></span><br><span class="line">x = np.asarray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>], dtype=np.float32)</span><br><span class="line">dropout(x, <span class="number">0.2</span>)</span><br></pre></td></tr></table></figure></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/33173246">详解深度学习中的Normalization，BN/LN/WN</a>:<a href="https://zhuanlan.zhihu.com/p/33173246">https://zhuanlan.zhihu.com/p/33173246</a><br>[2]<a href="https://blog.csdn.net/program_developer/article/details/80737724">深度学习中Dropout原理解析</a><br>[3]<a href="https://blog.csdn.net/dongapple/article/details/76668458">Batch Normalization反方向传播求导</a><br>[4]<a href="https://blog.csdn.net/yuechuen/article/details/71502503">Batch Normalization梯度反向传播推导</a></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习基础问题总结（一）</title>
      <link href="/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/posts/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>激活函数；梯度消失梯度爆炸问题；损失函数；反向传播；<br><a id="more"></a></p><h2 id="一、激活函数"><a href="#一、激活函数" class="headerlink" title="一、激活函数"></a>一、激活函数</h2><h3 id="1-什么是激活函数？激活函数是干什么的？"><a href="#1-什么是激活函数？激活函数是干什么的？" class="headerlink" title="1.什么是激活函数？激活函数是干什么的？"></a>1.什么是激活函数？激活函数是干什么的？</h3><p>激活函数是在神经网络每一层卷积或者全连接后的非线性函数部分。<br>她是干什么的？如果没有激活函数只有前面的全连接的话，相当于整个神经网络只有线性函数，每一层都是权重与输入的乘机，网络的拟合能力有限。正因为上面的原因，我们决定引入非线性函数作为激励函数，这样深层神经网络表达能力就更加强大（不再是输入的线性组合，而是几乎可以逼近任意函数）。</p><h3 id="2-常见的激活函数"><a href="#2-常见的激活函数" class="headerlink" title="2.常见的激活函数"></a>2.常见的激活函数</h3><p>记住下图就可以了<br><img src="https://img-blog.csdnimg.cn/20191210195042512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-为啥relu用的比较多？relu的优点？"><a href="#3-为啥relu用的比较多？relu的优点？" class="headerlink" title="3.为啥relu用的比较多？relu的优点？"></a>3.为啥relu用的比较多？relu的优点？</h3><p>1、sigmoid激活函数以及tanh激活函数容易产生<strong>梯度消失现象</strong>；<strong>relu解决了梯度消失问题。</strong><br>2、sigmoid计算量较大，而<strong>relu计算量较小</strong>。<strong>速度快</strong><br>3、relu会使得负数为0，使得网络具有一定稀疏性，提高网络表达能力，抗过拟合特性。（<strong>但是这也使得一些神经元未被激活….</strong>）</p><h3 id="4-为啥sigmoid会有梯度显示现象？"><a href="#4-为啥sigmoid会有梯度显示现象？" class="headerlink" title="4.为啥sigmoid会有梯度显示现象？"></a>4.为啥sigmoid会有梯度显示现象？</h3><p>看第二部分“梯度消失”</p><h2 id="二、梯度消失、梯度爆炸"><a href="#二、梯度消失、梯度爆炸" class="headerlink" title="二、梯度消失、梯度爆炸"></a>二、梯度消失、梯度爆炸</h2><h3 id="1-梯度消失的例子"><a href="#1-梯度消失的例子" class="headerlink" title="1.梯度消失的例子"></a>1.梯度消失的例子</h3><p>举个例子，对于一个含有20层隐藏层的简单神经网络来说，当梯度消失发生时，接近于输出层的隐藏层由于其梯度相对正常，所以权值更新时也就相对正常，但是当越靠近输入层时，由于梯度消失现象，会导致靠近输入层的隐藏层权值更新缓慢或者更新停滞。这就导致在训练时，只等价于后面几层的浅层网络的学习。<br><strong>注意：浅层是指靠近输出端；深层是靠近输入端的；</strong></p><h3 id="2-梯度消失与梯度爆炸"><a href="#2-梯度消失与梯度爆炸" class="headerlink" title="2.梯度消失与梯度爆炸"></a>2.梯度消失与梯度爆炸</h3><p>梯度计算前层上的梯度的计算来自于后层上梯度的乘积（链式法则）。当层数很多时，就容易出现不稳定。如果激活函数求导后与权重相乘的积大于1，那么层数增多的时候，最终的求出的梯度更新信息将以指数形式增加，即发生梯度爆炸，如果此部分小于1，那么随着层数增多，求出的梯度更新信息将会以指数形式衰减，即发生了梯度消失。</p><h3 id="3-分析sigmoid梯度消失"><a href="#3-分析sigmoid梯度消失" class="headerlink" title="3.分析sigmoid梯度消失"></a>3.分析sigmoid梯度消失</h3><p>sigmoid的函数求其导数得到下图，可以看出当x为0时梯度最大为0.25，而且当x稍微偏大或者偏小会趋近于0。<br>两个角度理解：<br>A）一个梯度最大为0.25，当层数增加后，不断向深层传播会出现0.25*0.25…越来越小，梯度消失。<br>B）某一层梯度可能会因为输入过大导致出现为0的时候向前传播就危险了！梯度会随着输入的变化而变化。<br><img src="https://img-blog.csdnimg.cn/20191210200912869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么为啥人家relu就好呢！！！<br>relu其实长得非常像一个线性函数。（认真看！）</p><blockquote><p>1）sigmoid函数的梯度随着x的增大或减小和消失，而ReLU不会。输入大于0就是1，输入小于0就截止了。<br>（这一点呢，后来出现leakRelu）<br>2）它让负数输入的时候为0.1x，稍微激活一下…缓解relu的负数为0的问题，但是我考虑按照sigmoid的第一条问题的话leakrelu也有，负数为0.1，不断传播就越来越小，但是呢，他没有趋近于0的时候，所以相对于sigmoid好太多！！！！！</p></blockquote><h3 id="4-解决梯度消失的方法"><a href="#4-解决梯度消失的方法" class="headerlink" title="4.解决梯度消失的方法"></a>4.解决梯度消失的方法</h3><p><strong>1、换激活函数</strong><br><strong>2、残差网络（这个后面详细说）</strong><br>就是下面这个图，当初就是有了它，网络的层数瓶颈打开了！！<br>可以看出后一层有一个 +x ，梯度就是+1，这个好，梯度不会变的越来越小了。<br>网络再深也不会消失了。<br><img src="https://img-blog.csdnimg.cn/20191210202759988.png" alt="在这里插入图片描述"><br><strong>3、BN批量规范化（BatchNormalization）</strong><br>老牛逼了，现在几乎所有的网络都加个这个！后面详细说<br><strong>4、LSTM网络</strong><br>这个循环神经网络具有记忆功能，可以缓解梯度消失。<br><strong>5、权重初始化注意一下</strong><br>比如用个高斯分布初始化；因为有一部分原因在于权重初始化值过高导致函数的值发生梯度爆炸</p><h3 id="5-实验过程中怎么发现是否有梯度消失或者梯度爆炸？"><a href="#5-实验过程中怎么发现是否有梯度消失或者梯度爆炸？" class="headerlink" title="5.实验过程中怎么发现是否有梯度消失或者梯度爆炸？"></a>5.实验过程中怎么发现是否有梯度消失或者梯度爆炸？</h3><p><strong>1、我们会看一下某些层的梯度变化，是否出现越来越小，是否出现爆表。<br>2、权重是否会变为Nan？<br>3、梯度快速变大变小。</strong></p><h2 id="三、损失函数"><a href="#三、损失函数" class="headerlink" title="三、损失函数"></a>三、损失函数</h2><h4 id="1-交叉熵"><a href="#1-交叉熵" class="headerlink" title="1.交叉熵"></a>1.交叉熵</h4><p>深度学习中一般用交叉熵这个损失函数。<br>交叉熵损失函数刻画的是两个概率分布之间的距离。如下式，交叉熵刻画的的是通过概率分布q来表达概率分布p的困难程度，其中p为真实分布，q为预测，交叉熵越小，两个概率分布越接近。<br><img src="https://img-blog.csdnimg.cn/20191211105344621.png" alt="在这里插入图片描述"><br>在深度学习中，对于一个多分类问题，一般用softmax将最后的全连接层啥的转为一个概率分布的情况，softmax如下式。其实就是用了个指数，然后分母是每个数据所对应各类得分的总和，分子是他的标签类所对应的分数，这样就转为一个概率了。再用上面那个交叉熵。<br><img src="https://img-blog.csdnimg.cn/20191211105516301.png" alt="在这里插入图片描述"><br>实际</p><h4 id="2-为啥人们选择交叉熵"><a href="#2-为啥人们选择交叉熵" class="headerlink" title="2.为啥人们选择交叉熵"></a>2.为啥人们选择交叉熵</h4><p>交叉熵的曲线如下图所示，他是一个凸函数，有一个最低点，利于loss梯度下降法优化。<br><img src="https://img-blog.csdnimg.cn/2019121110580694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3-回归问题损失函数"><a href="#3-回归问题损失函数" class="headerlink" title="3.回归问题损失函数"></a>3.回归问题损失函数</h4><p><strong>均方差（MES, Mean square error）</strong><br><img src="https://img-blog.csdnimg.cn/20191211110803510.png" alt="在这里插入图片描述"><br><strong>均方根误差RMSE</strong><br><img src="https://img-blog.csdnimg.cn/201912111155531.png" alt="在这里插入图片描述"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]深度学习中常用损失函数<a href="https://blog.csdn.net/Tianlock/article/details/88232467">https://blog.csdn.net/Tianlock/article/details/88232467</a></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法岗位实习&amp;工作需求总结</title>
      <link href="/posts/%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D%E5%AE%9E%E4%B9%A0&amp;%E5%B7%A5%E4%BD%9C%E9%9C%80%E6%B1%82%E6%80%BB%E7%BB%93/"/>
      <url>/posts/%E7%AE%97%E6%B3%95%E5%B2%97%E4%BD%8D%E5%AE%9E%E4%B9%A0&amp;%E5%B7%A5%E4%BD%9C%E9%9C%80%E6%B1%82%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本帖总结一些算法岗位实习&amp;工作的要求；陆续会补一些面经。</p><h3 id="计算机视觉算法实习"><a href="#计算机视觉算法实习" class="headerlink" title="计算机视觉算法实习"></a>计算机视觉算法实习</h3><ul><li>基本条件：<ul><li>熟悉深度学习框架（Tensorflow/Torch/Keras/Caffe）；</li><li>了解基本深度学习网络（CNN，RNN）（<strong>RNN应该是在视频理解或者NLP中应用多</strong>）</li><li>熟悉Python语言；有时也需要C++、JAVA；</li><li>熟悉Linux系统（<strong>公司一般都是服务器下操作</strong>），Shell编程；</li><li>熟悉常见的计算机视觉的应用方向；以下我总结的但不限于图像分类（）、目标检测（Detection）、语义分割（sematic segmentation）、模型压缩、弱监督（weakly supervised learning）、超分辨率重建（super resolution）、生成对抗网络（GAN）</li><li>熟悉经典的深度学习模型（backbone基本结构）</li><li>了解ML算法（Boosting、SVM…）</li></ul></li><li>优先条件：<ul><li>有顶会论文/实际项目落地经验者；（<strong>一般普通实验室没有顶会…那就得有实习经历或者老板有项目…不然就看愿不愿意培养你</strong>）</li><li>重大比赛或者竞赛有荣誉；在Github上有影响大的开源代码；</li></ul></li></ul><h3 id="自然语言算法实习"><a href="#自然语言算法实习" class="headerlink" title="自然语言算法实习"></a>自然语言算法实习</h3><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><ul><li>简历上项目分析；听一下做了啥，以及你的工作与工作量；</li><li>基础知识：深度学习（DropOut、过拟合、各种你知道的网络…）</li><li>编程题（必须刷题，其实大家都是刷题，但是面试官几乎都会考，那就只能干了！）</li></ul><h3 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h3>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/hello-world/"/>
      <url>/posts/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>from tensorflow.python.keras.utils import tf_utils ImportError&#39;:&#39; cannot import name &#39;tf_utils&#39;</title>
      <link href="/posts/from%20tensorflow.python.keras.utils%20import%20tf_utils%20ImportError_%20cannot%20import%20name%20&#39;tf_utils&#39;/"/>
      <url>/posts/from%20tensorflow.python.keras.utils%20import%20tf_utils%20ImportError_%20cannot%20import%20name%20&#39;tf_utils&#39;/</url>
      
        <content type="html"><![CDATA[<p>Debug:在安装keras出现问题<br><a id="more"></a></p><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.python.keras.utils <span class="keyword">import</span> tf_utils</span><br><span class="line">ImportError: cannot <span class="keyword">import</span> name <span class="string">'tf_utils'</span></span><br></pre></td></tr></table></figure><h5 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h5><p>Seems like it was a problem with keras 2.3.0, I installed keras 2.1.5 using pip and it works fine.</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install keras==2.1.5 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h5 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h5><p><a href="https://stackoverflow.com/questions/57985406/cannot-import-name-tf-utils-when-using-importing-keras">https://stackoverflow.com/questions/57985406/cannot-import-name-tf-utils-when-using-importing-keras</a></p>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> keras </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>anaconda + python3.6安装</title>
      <link href="/posts/anconda%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AF%B9%E5%BA%94python%E7%89%88%E6%9C%AC/"/>
      <url>/posts/anconda%E7%89%88%E6%9C%AC%E5%8F%B7%E5%AF%B9%E5%BA%94python%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>anaconda + python3.6安装<br><a id="more"></a><br><img src="https://img-blog.csdnimg.cn/20191109183836983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>清华镜像连接<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多光谱知识总结</title>
      <link href="/posts/%E5%A4%9A%E5%85%89%E8%B0%B1/"/>
      <url>/posts/%E5%A4%9A%E5%85%89%E8%B0%B1/</url>
      
        <content type="html"><![CDATA[<p>多光谱知识总结<br><a id="more"></a><br>多光谱知识总结<br>1、什么是多光谱？<br>多光谱成像技术是基于液晶可调谐滤波（LCTF)技术，可在不同波长处（420一720nm）检测荧光探针或染料在细胞或组织中的分布，可获取各种波长范围内的所有信号，通过光谱学的原理，可将每一种色原或染料分离成单独的图像，完全去除样本的自发荧光，可明显提高组织切片成像的信噪比，还可将每种信号进行单独分离、定量，为多指标检测提供可行性，使之在病理诊断中有着很好的应用价值。<br>简单的说就是看看它在不同波段下是否比RGB显示情况下表现更清晰。<br>2、多光谱成像图像的评价指标<br>2.1 图像亮度信息法<br>对多光谱图像的每个波段来讲，人眼识别灰度图像的最大限度取决于灰度图像的亮度值大小和图像的灰度分布。可以用平均灰度值衡量第i波段灰度图像的亮度，用图像的标准差来度量灰度图像的离散程度<br> <img src="https://tuchuangblog-1257632417.cos.ap-chengdu.myqcloud.com/1.jpg" alt="在这里插入图片描述"><br>2.2 判断分类法<br>可以用深度学习的方法对图像做分类实验，测试其对分类的影响，或者看其提取的特征的欧式距离差别的大小。<br>3、 一些论文应用<br>3.1 马铃薯的最佳光谱范围<br>论文通过对多端波长进行了实验最终给出了马铃薯的最佳光谱范围为475，558，680，715，750，800，850（单位nm）。<br>3.2 四季豆叶片的特征波段<br>对400～720nm波段范围的多光谱图像波段数据进行优化，选取了灰度分布离散、图像亮度信息大且与其他波段相关性小的四季豆叶片特征波段。根据各波段图像的波段指数值和可识别度，从大量波段数据中通过比较两种方法获取了四季豆叶片的特征波段，得出545、630、645、720、650 和570nm波段对四季豆叶片的分类均比较理想。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多光谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pip换镜像安装 清华镜像 豆瓣镜像</title>
      <link href="/posts/pip%E6%8D%A2%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85%20%E6%B8%85%E5%8D%8E%E9%95%9C%E5%83%8F%20%E8%B1%86%E7%93%A3%E9%95%9C%E5%83%8F/"/>
      <url>/posts/pip%E6%8D%A2%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85%20%E6%B8%85%E5%8D%8E%E9%95%9C%E5%83%8F%20%E8%B1%86%E7%93%A3%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>pip换镜像安装 清华镜像 豆瓣镜像<br><a id="more"></a></p><p>豆瓣镜像源<a href="https://pypi.douban.com/simple/">https://pypi.douban.com/simple/</a><br>清华镜像源<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>示例代码安装keras（注意：—user代表安装在个人目录下，不影响root目录）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install keras -i https://pypi.douban.com/simple/ --user</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pip </tag>
            
            <tag> 清华镜像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glib源码编译安装与libffi源码编译安装</title>
      <link href="/posts/glib%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E4%B8%8Elibffi%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
      <url>/posts/glib%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E4%B8%8Elibffi%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>源码安装！啊！glib源码编译安装与libffi源码编译安装<br><a id="more"></a></p><h4 id="安装glib"><a href="#安装glib" class="headerlink" title="安装glib"></a>安装glib</h4><p>安装glib 下载glib <a href="http://ftp.acc.umu.se/pub/GNOME/sources/glib/">http://ftp.acc.umu.se/pub/GNOME/sources/glib/</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf glib-2.48.1.tar.xz</span><br><span class="line">./configure --prefix=/home/meng/software/glib</span><br><span class="line">make -j12</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><br>之后需要配置环境遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH=$HOME/menglingjun/software/glib/lib/pkgconfig</span><br></pre></td></tr></table></figure></p><p>你可能会会遇到这个错误，缺少libffi，直接到安装<a href="#anchor1">libffi</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">No package <span class="string">'libffi'</span> found</span><br><span class="line"></span><br><span class="line">Consider adjusting the PKG_CONFIG_PATH environment variable <span class="keyword">if</span> you</span><br><span class="line">installed software <span class="keyword">in</span> a non-standard prefix.</span><br><span class="line"></span><br><span class="line">Alternatively, you may <span class="built_in">set</span> the environment variables LIBFFI_CFLAGS</span><br><span class="line">and LIBFFI_LIBS to avoid the need to call pkg-config.</span><br><span class="line">See the pkg-config man page <span class="keyword">for</span> more details.</span><br></pre></td></tr></table></figure></p><p>你可能会会遇到这个错误，缺少libffi，直接到安装<a href="#anchor2">libpcre</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configure: error: Package requirements (libpcre &gt;= 8.13) were not met:</span><br><span class="line"></span><br><span class="line">No package <span class="string">'libpcre'</span> found</span><br></pre></td></tr></table></figure></p><div id = anchor1></div><h4 id="安装libffi"><a href="#安装libffi" class="headerlink" title="安装libffi"></a>安装libffi</h4><p>去官网下载libffi  <a href="http://sourceware.org/libffi/">http://sourceware.org/libffi/</a>，然后解压，configure，编译make，安装install。<br>这里需要注意如果不是root就需要装在自己的目录下，config需要加上prefix参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar xf libffi-3.0.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libffi-3.0.0</span><br><span class="line">./configure --prefix=/home/meng/software/libffi</span><br><span class="line">make -j12</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><br>之后需要配置环境遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export LIBFFI_CFLAGS=-I$HOME/menglingjun/software/libffi/lib/libffi-3.2.1/include</span><br><span class="line">export LIBFFI_LIBS=$HOME/menglingjun/software/libffi/lib/libffi.la</span><br><span class="line">export C_INCLUDE_PATH=$HOME/menglingjun/software/libffi/lib/libffi-3.2.1/include/</span><br><span class="line">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$HOME/menglingjun/software/libffi/lib/pkgconfig</span><br></pre></td></tr></table></figure></p><div id = anchor2></div><h4 id="安装libpcre"><a href="#安装libpcre" class="headerlink" title="安装libpcre"></a>安装libpcre</h4><p><a href="https://sourceforge.net/projects/pcre/files/pcre/">https://sourceforge.net/projects/pcre/files/pcre/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -jxvf pcre-8.39.tar.bz2</span><br><span class="line">./configure --prefix=/home/menglingjun/menglingjun/software/pcre/</span><br><span class="line">make -j12</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>配置环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$HOME/menglingjun/software/pcre/lib/pkgconfig</span><br></pre></td></tr></table></figure></p><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><p><a href="https://www.cnblogs.com/pcat/p/5520317.html">https://www.cnblogs.com/pcat/p/5520317.html</a></p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> glib </tag>
            
            <tag> libffi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YouTube-8M feature extraction bug</title>
      <link href="/posts/YouTube-8M%20feature%20extraction%20bug/"/>
      <url>/posts/YouTube-8M%20feature%20extraction%20bug/</url>
      
        <content type="html"><![CDATA[<p>源码编译OPENCV C++版本 linux<br><a id="more"></a></p><p>YouTube-8M feature extraction bug记录</p><h4 id="Error-1-fatal-error-opencv2-core-hpp-No-such-file-or-directory"><a href="#Error-1-fatal-error-opencv2-core-hpp-No-such-file-or-directory" class="headerlink" title="Error 1  fatal error: opencv2/core.hpp: No such file or directory"></a>Error 1  fatal error: opencv2/core.hpp: No such file or directory</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ERROR: /data/menglingjun/mediapipe/mediapipe/framework/formats/BUILD:163:1: C++ compilation of rule <span class="string">'//mediapipe/framework/formats:image_frame_opencv'</span> failed (Exit 1) gcc failed: error executing <span class="built_in">command</span> /usr/<span class="built_in">local</span>/gcc/bin/gcc -U_FORTIFY_SOURCE -fstack-protector -Wall -Wunused-but-set-parameter -Wno-free-nonheap-object -fno-omit-frame-pointer -g0 -O2 <span class="string">'-D_FORTIFY_SOURCE=1'</span> -DNDEBUG -ffunction-sections ... (remaining 70 argument(s) skipped)</span><br><span class="line"></span><br><span class="line">Use --sandbox_debug to see verbose messages from the sandbox</span><br><span class="line">In file included from ./mediapipe/framework/formats/image_frame_opencv.h:20:0,</span><br><span class="line">                 from mediapipe/framework/formats/image_frame_opencv.cc:15:</span><br><span class="line">./mediapipe/framework/port/opencv_core_inc.h:18:36: fatal error: opencv2/core/version.hpp: No such file or directory</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><p>没有找到opencv2/core/version.hpp<br>解决方案：修改./mediapipe/framework/port/opencv_core_inc.h中的路径，我的是opencv4，在路径/opencv/include/opencv4/opencv2下，所以改为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv4/opencv2/core/version.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CV_VERSION_EPOCH  <span class="comment">// for OpenCV 2.x</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv4/opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv4/opencv2/core/core.hpp&gt;</span></span></span><br></pre></td></tr></table></figure></p><h4 id="Error2-fatal-error-libavcodec-avcodec-h-No-such-file-or-directory"><a href="#Error2-fatal-error-libavcodec-avcodec-h-No-such-file-or-directory" class="headerlink" title="Error2 fatal error: libavcodec/avcodec.h: No such file or directory"></a>Error2 fatal error: libavcodec/avcodec.h: No such file or directory</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ERROR: /data/menglingjun/mediapipe/mediapipe/util/BUILD:67:1: C++ compilation of rule <span class="string">'//mediapipe/util:audio_decoder'</span> failed (Exit 1) gcc failed: error executing <span class="built_in">command</span> /usr/<span class="built_in">local</span>/gcc/bin/gcc -U_FORTIFY_SOURCE -fstack-protector -Wall -Wunused-but-set-parameter -Wno-free-nonheap-object -fno-omit-frame-pointer -g0 -O2 <span class="string">'-D_FORTIFY_SOURCE=1'</span> -DNDEBUG -ffunction-sections ... (remaining 81 argument(s) skipped)</span><br><span class="line"></span><br><span class="line">Use --sandbox_debug to see verbose messages from the sandbox</span><br><span class="line">In file included from mediapipe/util/audio_decoder.cc:15:0:</span><br><span class="line">./mediapipe/util/audio_decoder.h:33:32: fatal error: libavcodec/avcodec.h: No such file or directory</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YouTube-8M </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bazel 总结</title>
      <link href="/posts/bazel%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
      <url>/posts/bazel%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>最近在用Utube-8M的mediapipe框架提取视频特征，用到了bazel编译，遇到一些问题做一些总结。</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h2 id="WORKSPACE"><a href="#WORKSPACE" class="headerlink" title="WORKSPACE"></a>WORKSPACE</h2><p>WORKSPACE位于你的项目根目录，标志你的工作区。用于引入外部依赖关系，通常是源代码位于主存储库之外。</p><h2 id="BUILD文件"><a href="#BUILD文件" class="headerlink" title="BUILD文件"></a>BUILD文件</h2><p>BUILD文件给出了编译目标的规则，包括target名称，源文件srcs，头文件hdrs，依赖deps<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cc_binary(</span><br><span class="line">    name = &quot;hello-world&quot;,</span><br><span class="line">    srcs = [&quot;hello-world.cc&quot;],</span><br><span class="line">    hdrs = [&quot;hello-world.hpp&quot;,</span><br><span class="line"> &quot;helo.hpp&quot;,</span><br><span class="line">       ],</span><br><span class="line"> deps = [&quot;//lib:hello-time&quot;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>具体规则可以参考源网站<a href="https://docs.bazel.build/versions/master/be/c-cpp.html#cc_binary">https://docs.bazel.build/versions/master/be/c-cpp.html#cc_binary</a></p><h3 id="deps"><a href="#deps" class="headerlink" title="deps"></a>deps</h3><p>依赖可以包含内部依赖也可以包含外部依赖，<br><strong>内部依赖</strong>这里的路径是以WORKSPACE的路径开始的相对路径，例如deps = [“//lib:hello-time”]代表WORKSPACE路径下有lib文件夹，lib里面有hello-time.cc，并且有BUILD文件，这个就是内部依赖，还没有编译，在你编译主文件时他会自动链接先编译这个文件。</p><p><strong>外部依赖</strong>就是可以调用你安装好的包，比如opencv包，这时你需要先改WORKSPACE加入环境，再写一个BUILD调用。<br>1、WORKSPACE加入环境，它指定了名字，path就是环境遍历，build_file就是build的文件再third_party文件夹下opencv_linux.BUILD中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new_local_repository(</span><br><span class="line">    name = &quot;linux_opencv&quot;,</span><br><span class="line">    build_file = &quot;@//third_party:opencv_linux.BUILD&quot;,</span><br><span class="line">    path = &quot;/home/menglingjun/menglingjun/software/opencv&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>2、改opencv_linux.BUILD<br>加入源文件，头文件，include啥的，都是相对于你前面的path<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cc_library(</span><br><span class="line">    name = &quot;opencv&quot;,</span><br><span class="line">    srcs = glob(</span><br><span class="line">        [</span><br><span class="line">             &quot;lib64/libopencv_core.so&quot;,</span><br><span class="line">             &quot;lib64/libopencv_highgui.so&quot;,</span><br><span class="line">             &quot;lib64/libopencv_imgcodecs.so&quot;,</span><br><span class="line">             &quot;lib64/libopencv_imgproc.so&quot;,</span><br><span class="line">             &quot;lib64/libopencv_video.so&quot;,</span><br><span class="line">             &quot;lib64/libopencv_videoio.so&quot;,</span><br><span class="line">        ],</span><br><span class="line">    ),</span><br><span class="line">    hdrs = glob(</span><br><span class="line">         [</span><br><span class="line">              &quot;include/opencv4/opencv2/**/*.h*&quot;,</span><br><span class="line">              &quot;include/opencv4/opencv2/*.h*&quot;,</span><br><span class="line">         ]),</span><br><span class="line">    includes = [&quot;include/opencv4&quot;,], # [&quot;include&quot;],</span><br><span class="line">    linkstatic = 1,</span><br><span class="line">    visibility = [&quot;//visibility:public&quot;],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>3、你要编译的目标如何依赖<br>把opencv加上就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cc_binary(</span><br><span class="line">    name = &quot;hello-world&quot;,</span><br><span class="line">    srcs = [&quot;hello-world.cc&quot;],</span><br><span class="line">    hdrs = [&quot;hello-world.hpp&quot;,</span><br><span class="line"> &quot;helo.hpp&quot;,</span><br><span class="line">       ],</span><br><span class="line"> deps = [&quot;//third_party:opencv&quot;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="编译文件"><a href="#编译文件" class="headerlink" title="编译文件"></a>编译文件</h2><h3 id="Test-1编译单独一个目标"><a href="#Test-1编译单独一个目标" class="headerlink" title="Test 1编译单独一个目标"></a>Test 1编译单独一个目标</h3><p>在你的WORKSPACE所在目录下运行bazel build，运行main文件夹下的hello-world.cc<br>stage1<br>    ├── main<br>    │   ├── BUILD<br>    │   └── hello-world.cc<br>   └── WORKSPACE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build //main:hello-world</span><br></pre></td></tr></table></figure></p><h3 id="Test-2编译带有依赖的目标"><a href="#Test-2编译带有依赖的目标" class="headerlink" title="Test 2编译带有依赖的目标"></a>Test 2编译带有依赖的目标</h3><p>如果hello-world.cc的文件需要调用hello-greet的包此时就需要加入deps依赖。build文件如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cc_library(</span><br><span class="line">    name = &quot;hello-greet&quot;,</span><br><span class="line">    srcs = [&quot;hello-greet.cc&quot;],</span><br><span class="line">    hdrs = [&quot;hello-greet.h&quot;],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cc_binary(</span><br><span class="line">    name = &quot;hello-world&quot;,</span><br><span class="line">    srcs = [&quot;hello-world.cc&quot;],</span><br><span class="line">    deps = [</span><br><span class="line">        &quot;:hello-greet&quot;,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>这样再编译hello-world，bazel就会首先编译hello-greet再对hello-world.cc进行编译。指令我们还是一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build //main:hello-world</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bazel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mediapipe bazel build 编译提示编译找不到opencv4/opencv2/core/version.hpp</title>
      <link href="/posts/mediapipe%20bazel%20build%20%E7%BC%96%E8%AF%91%E6%8F%90%E7%A4%BA%E7%BC%96%E8%AF%91%E6%89%BE%E4%B8%8D%E5%88%B0opencv4_opencv2_core_version.hpp/"/>
      <url>/posts/mediapipe%20bazel%20build%20%E7%BC%96%E8%AF%91%E6%8F%90%E7%A4%BA%E7%BC%96%E8%AF%91%E6%89%BE%E4%B8%8D%E5%88%B0opencv4_opencv2_core_version.hpp/</url>
      
        <content type="html"><![CDATA[<p>解决mediapipe bazel build 编译提示编译找不到opencv4/opencv2/core/version.hpp</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>问题：mediapipe bazel build 编译提示编译找不到opencv4/opencv2/core/version.hpp<br>分析：主要原因在于没有配置好bazel的第三方库的环境变量<br>解决方案：<br>1、需要修改根目录下WORKSAPCE的linux_opencv仓库的path，改到你安装的opencv环境位置，例如我安装opencv4需要修改如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new_local_repository(</span><br><span class="line">    name = &quot;linux_opencv&quot;,</span><br><span class="line">    build_file = &quot;@//third_party:opencv_linux.BUILD&quot;,</span><br><span class="line">    path = &quot;/home/myname/software/opencv&quot;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>2、需要修改third_party/opencv_linux.BUILD找到opencv<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cc_library(</span><br><span class="line">    name = &quot;opencv&quot;,</span><br><span class="line">    srcs = glob(</span><br><span class="line">        [</span><br><span class="line">            &quot;lib/libopencv_core.so&quot;,</span><br><span class="line">            &quot;lib/libopencv_highgui.so&quot;,</span><br><span class="line">            &quot;lib/libopencv_imgcodecs.so&quot;,</span><br><span class="line">            &quot;lib/libopencv_imgproc.so&quot;,</span><br><span class="line">            &quot;lib/libopencv_video.so&quot;,</span><br><span class="line">            &quot;lib/libopencv_videoio.so&quot;,</span><br><span class="line">        ],</span><br><span class="line">    ),</span><br><span class="line">    hdrs = glob([&quot;include/opencv4/opencv2/*.h*&quot;，</span><br><span class="line">   &quot;include/opencv4/opencv2/**/*.h*&quot; ， ]),</span><br><span class="line">    includes = [&quot;include/opencv4/&quot;],</span><br><span class="line">    linkstatic = 1,</span><br><span class="line">    visibility = [&quot;//visibility:public&quot;],</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bazel </tag>
            
            <tag> mediapipe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码编译OPENCV C++版本 linux</title>
      <link href="/posts/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91OPENCV%20C++%E7%89%88%E6%9C%AC%20linux/"/>
      <url>/posts/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91OPENCV%20C++%E7%89%88%E6%9C%AC%20linux/</url>
      
        <content type="html"><![CDATA[<p>源码编译OPENCV C++版本 linux<br><a id="more"></a></p><h5 id="Tips-1-下载-OPENCV"><a href="#Tips-1-下载-OPENCV" class="headerlink" title="Tips 1 下载 OPENCV"></a>Tips 1 下载 OPENCV</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/opencv/opencv</span><br><span class="line">git clone https://github.com/opencv/opencv</span><br></pre></td></tr></table></figure><h5 id="Tips-2-创建build文件夹"><a href="#Tips-2-创建build文件夹" class="headerlink" title="Tips 2 创建build文件夹"></a>Tips 2 创建build文件夹</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd opencv</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure><h5 id="Tips-3-Cmake编译"><a href="#Tips-3-Cmake编译" class="headerlink" title="Tips 3 Cmake编译"></a>Tips 3 Cmake编译</h5><p><strong>注意：一般编译过程会有两个文件比较难下载，最好提前下载下来，这里参考<em>Error2，Error4</em>先解决再走下面流程。</strong></p><p>其中CMAKE_INSTALL_PREFIX代表你的安装路径<br>-D BUILD_opencv_python3配置是否安装python版的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=../../OpenCV \</span><br><span class="line"> -D OPENCV_EXTRA_MODULES_PATH=../../opencv_contrib/modules \</span><br><span class="line">-D BUILD_opencv_python3=OFF \</span><br><span class="line">-D BUILD_opencv_python2=OFF \</span><br><span class="line">OPENCV_GENERATE_PKGCONFIG=YES ..</span><br></pre></td></tr></table></figure></p><h5 id="Tips-4-make安装"><a href="#Tips-4-make安装" class="headerlink" title="Tips 4 make安装"></a>Tips 4 make安装</h5><p>j4代表用几个CPU加速<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make -j12</span><br><span class="line">#long time ...</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><h5 id="Tips-5-环境变量"><a href="#Tips-5-环境变量" class="headerlink" title="Tips 5 环境变量"></a>Tips 5 环境变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line">PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$HOME/menglingjun/software/opencv/lib64/pkgconfig</span><br><span class="line">export PKG_CONFIG_PATH</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HOME/menglingjun/software/opencv/lib64/</span><br><span class="line"></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>测试版本信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion opencv</span><br></pre></td></tr></table></figure></p><h5 id="Error1-Cmake3找不到"><a href="#Error1-Cmake3找不到" class="headerlink" title="Error1 Cmake3找不到"></a>Error1 Cmake3找不到</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-D WITH_CUBLAS=ON ..</span><br><span class="line">-- The CXX compiler identification is GNU 5.5.0</span><br><span class="line">-- The C compiler identification is GNU 5.5.0</span><br><span class="line">-- Check for working CXX compiler: /usr/local/gcc/bin/g++</span><br><span class="line">-- Check for working CXX compiler: /usr/local/gcc/bin/g++ -- broken</span><br><span class="line">CMake Error at /usr/share/cmake3/Modules/CMakeTestCXXCompiler.cmake:45 (message):</span><br><span class="line">  The C++ compiler</span><br><span class="line"></span><br><span class="line">    &quot;/usr/local/gcc/bin/g++&quot;</span><br><span class="line"></span><br><span class="line">  is not able to compile a simple test program.</span><br><span class="line"></span><br><span class="line">  It fails with the following output:</span><br><span class="line"></span><br><span class="line">    Change Dir: /home/menglingjun/menglingjun/software/opencv-master/build/CMakeFiles/CMakeTmp</span><br><span class="line"></span><br><span class="line">    Run Build Command:&quot;/usr/bin/gmake&quot; &quot;cmTC_39633/fast&quot;</span><br><span class="line">    /usr/bin/gmake -f CMakeFiles/cmTC_39633.dir/build.make CMakeFiles/cmTC_39633.dir/build</span><br><span class="line">    gmake[1]: Entering directory `/data/menglingjun/software/opencv-master/build/CMakeFiles/CMakeTmp&apos;</span><br><span class="line">    /bin/sh: /usr/bin/cmake3: No such file or directory</span><br><span class="line">    gmake[1]: *** [CMakeFiles/cmTC_39633.dir/testCXXCompiler.cxx.o] Error 127</span><br><span class="line">    gmake[1]: Leaving directory `/data/menglingjun/software/opencv-master/build/CMakeFiles/CMakeTmp&apos;</span><br><span class="line">    gmake: *** [cmTC_39633/fast] Error 2</span><br><span class="line">  CMake will not be able to correctly generate this project.</span><br></pre></td></tr></table></figure><p>关注这里/bin/sh: /usr/bin/cmake3: No such file or directory<br>我查看了一下/usr/bin/下有cmake，查一下cmake版本（cmake —version）发现cmake是3版本，我觉得这个cmake就是3，所以创建一个软链（副本）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s cmake cmake3</span><br></pre></td></tr></table></figure><br>我这里就ok了，如果你有别的问题，百度其他地方把。</p><h5 id="Error2-ippicv下载失败问题"><a href="#Error2-ippicv下载失败问题" class="headerlink" title="Error2 ippicv下载失败问题"></a>Error2 ippicv下载失败问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CMake Warning at cmake/OpenCVDownload.cmake:202 (message):</span><br><span class="line">  IPPICV: Download failed: 28;&quot;Timeout was reached&quot;</span><br><span class="line"></span><br><span class="line">  For details please refer to the download log file:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /home/menglingjun/menglingjun/software/opencv-master/build/CMakeDownloadLog.txt</span><br></pre></td></tr></table></figure><p>离线下载<br>链接：<a href="https://pan.baidu.com/s/1f6x2-S-XHKr8K0qv5inKIg&amp;shfl=sharepset">https://pan.baidu.com/s/1f6x2-S-XHKr8K0qv5inKIg&amp;shfl=sharepset</a><br>提取码：s9mz<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p><p>存到一个目录下，随意<br>  /home/menglingjun/menglingjun/software<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 打开终端，输入</span><br><span class="line"> </span><br><span class="line">    vim ~/menglingjun/software/opencv-master/3rdparty/ippicv/ippicv.cmake #就是这个文件的路径</span><br><span class="line"> </span><br><span class="line"># 将47行的</span><br><span class="line"> </span><br><span class="line">     &quot;https://raw.githubusercontent.com/opencv/opencv_3rdparty/$&#123;IPPICV_COMMIT&#125;ippicv/&quot;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 改为步骤1中手动下载的文件的本地路径(也就是将网络下载的模式改为本地文件下载的模式):</span><br><span class="line"> </span><br><span class="line">    &quot;file:  /home/menglingjun/menglingjun/software/opencv-master&quot; #（仅供参考，根据自己的路径填写）</span><br></pre></td></tr></table></figure></p><h5 id="Error3-fatal-error-sys-videoio-h-No-such-file-or-directory"><a href="#Error3-fatal-error-sys-videoio-h-No-such-file-or-directory" class="headerlink" title="Error3 fatal error: sys/videoio.h: No such file or directory"></a>Error3 fatal error: sys/videoio.h: No such file or directory</h5><p>Cmake时把这个加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.2.0/module</span><br></pre></td></tr></table></figure></p><h5 id="Error4-face-landmark-model-dat下载失败问题"><a href="#Error4-face-landmark-model-dat下载失败问题" class="headerlink" title="Error4 face_landmark_model.dat下载失败问题"></a>Error4 face_landmark_model.dat下载失败问题</h5><p>百度云下载地址，失效请评论提醒我更新：<br>链接：<a href="https://pan.baidu.com/s/1uhIDqIbMuIawrE6mXuSrnA&amp;shfl=sharepset">https://pan.baidu.com/s/1uhIDqIbMuIawrE6mXuSrnA&amp;shfl=sharepset</a><br>提取码：re72<br>复制这段内容后打开百度网盘手机App，操作更方便哦<br>找到/opencv_contrib/modules/face下面的CMakeLists.txt文件并打开，如下，修改红色标注的网站，改为本地目录（你需要提前下载好存在这个目录下），如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ocv_download(</span><br><span class="line">    FILENAME face_landmark_model.dat</span><br><span class="line">    HASH $&#123;__file_hash&#125;</span><br><span class="line">    URL</span><br><span class="line">      &quot;$&#123;OPENCV_FACE_ALIGNMENT_URL&#125;&quot;</span><br><span class="line">      &quot;$ENV&#123;OPENCV_FACE_ALIGNMENT_URL&#125;&quot;</span><br><span class="line">      &quot;file:/home/menglingjun/menglingjun/software/opencv_contrib/&quot;</span><br><span class="line">    DESTINATION_DIR &quot;$&#123;CMAKE_BINARY_DIR&#125;/$&#123;OPENCV_TEST_DATA_INSTALL_PATH&#125;/cv/face/&quot;</span><br><span class="line">    ID &quot;data&quot;</span><br><span class="line">    RELATIVE_URL</span><br><span class="line">    STATUS res</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdnimg.cn/20191021163118179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码编译opencv 找不到cmake3</title>
      <link href="/posts/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91opencv%20%E6%89%BE%E4%B8%8D%E5%88%B0cmake3/"/>
      <url>/posts/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91opencv%20%E6%89%BE%E4%B8%8D%E5%88%B0cmake3/</url>
      
        <content type="html"><![CDATA[<p>源码编译opencv 找不到cmake3</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-D WITH_CUBLAS=ON ..</span><br><span class="line">-- The CXX compiler identification is GNU 5.5.0</span><br><span class="line">-- The C compiler identification is GNU 5.5.0</span><br><span class="line">-- Check for working CXX compiler: /usr/local/gcc/bin/g++</span><br><span class="line">-- Check for working CXX compiler: /usr/local/gcc/bin/g++ -- broken</span><br><span class="line">CMake Error at /usr/share/cmake3/Modules/CMakeTestCXXCompiler.cmake:45 (message):</span><br><span class="line">  The C++ compiler</span><br><span class="line"></span><br><span class="line">    &quot;/usr/local/gcc/bin/g++&quot;</span><br><span class="line"></span><br><span class="line">  is not able to compile a simple test program.</span><br><span class="line"></span><br><span class="line">  It fails with the following output:</span><br><span class="line"></span><br><span class="line">    Change Dir: /home/menglingjun/menglingjun/software/opencv-master/build/CMakeFiles/CMakeTmp</span><br><span class="line"></span><br><span class="line">    Run Build Command:&quot;/usr/bin/gmake&quot; &quot;cmTC_39633/fast&quot;</span><br><span class="line">    /usr/bin/gmake -f CMakeFiles/cmTC_39633.dir/build.make CMakeFiles/cmTC_39633.dir/build</span><br><span class="line">    gmake[1]: Entering directory `/data/menglingjun/software/opencv-master/build/CMakeFiles/CMakeTmp&apos;</span><br><span class="line">    /bin/sh: /usr/bin/cmake3: No such file or directory</span><br><span class="line">    gmake[1]: *** [CMakeFiles/cmTC_39633.dir/testCXXCompiler.cxx.o] Error 127</span><br><span class="line">    gmake[1]: Leaving directory `/data/menglingjun/software/opencv-master/build/CMakeFiles/CMakeTmp&apos;</span><br><span class="line">    gmake: *** [cmTC_39633/fast] Error 2</span><br><span class="line">  CMake will not be able to correctly generate this project.</span><br></pre></td></tr></table></figure><p>关注这里/bin/sh: /usr/bin/cmake3: No such file or directory<br>我查看了一下/usr/bin/下有cmake，查一下cmake版本（cmake —version）发现cmake是3版本，我觉得这个cmake就是3，所以创建一个软链（副本）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s cmake cmake3</span><br></pre></td></tr></table></figure><br>我这里就ok了，如果你有别的问题，百度其他地方把。</p>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux软连接</title>
      <link href="/posts/linux%E8%BD%AF%E8%BF%9E%E6%8E%A5/"/>
      <url>/posts/linux%E8%BD%AF%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>linux中有个操作叫做软连接，类似于windows中的快捷方式，对于文件，可以相当于同一个文件用一个内存存储；对于文件夹，内存在A处，软链到B处，我们在B处操作，所有的空间内存都存储到A处；</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>创建软链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln  -s  [源文件或目录]  [目标文件或目录]</span><br></pre></td></tr></table></figure><br>例如，在当前目录创建test1，软链到var路径下的test，这样内存就占用test的内存。（一般用于节省home的内存，将home下的数据软链到其他硬盘）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln –s  /var/www/test  test1</span><br></pre></td></tr></table></figure></p><p>删除软连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm –rf test</span><br></pre></td></tr></table></figure><br>修改软连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln –snf  [新的源文件或目录]  [目标文件或目录]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软连接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVPR2019 GAN论文分享</title>
      <link href="/posts/CVPR2019%20GAN%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/"/>
      <url>/posts/CVPR2019%20GAN%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>更新于2019-9-29<br>2019-9-29增加DCGAN总结<br>2019-9-27增加《Geometry-Consistent Generative Adversarial Networks for》<br>2019-9-26增加《Sphere Generative Adversarial Network Based on Geometric Moment Matching》<br>2019-9-25增加《Mixture Density Generative Adversarial Networks》<br>2019-9-23创建文本<br><a id="more"></a></p><hr><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>2019CVPR共有10篇论文上榜，其中包含6篇改进GAN网络的文章，包括四篇改良GAN的模型崩塌问题，有一篇改良文字转图像模型的，有一篇提出切片W距离；除了改进GAN的论文还有有4篇文章属于领域创新型文章，有应用在模型压缩、美妆生成、交互式图像生成、视频生成等领域。<br><img src="https://img-blog.csdnimg.cn/20191009102123595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191009101557263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="《Mode-Seeking-Generative-Adversarial-Networks-for-Diverse-Image-Synthesis》——-MSGAN"><a href="#《Mode-Seeking-Generative-Adversarial-Networks-for-Diverse-Image-Synthesis》——-MSGAN" class="headerlink" title="《Mode Seeking Generative Adversarial Networks for Diverse Image Synthesis》——-MSGAN"></a>《Mode Seeking Generative Adversarial Networks for Diverse Image Synthesis》——-MSGAN</h3><p>这篇文章主要针对cGAN的模型崩塌问题提出了一种正则化的思想，在原目标函数基础上加入一个输出图像之间的距离与噪声输入之间距离的比值。<br>源码：<a href="https://github.com/HelenMao/MSGAN">https://github.com/HelenMao/MSGAN</a></p><h4 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h4><p>先摆一张论文中的图，这是他idea的来源，讲的什么意思呢，左边为真实数据分布，应该在模型空间里会有五个模型，模型崩塌时会像第二个图一样，他映射好只有中间那两个波峰模型，而利用它的ModeSeeking会达到第三张图状态，怎么达到呢，看右侧虚线框，里面解释在Z到ImageSpaceI的映射中，可以看出如果，这个比值小的话，会使的只在中间晃荡，当比值大时就活到外边映射到更多的模型去。所以作者给出一个正则化思想就是最大化一个输出图像之间的距离与噪声输入之间距离的比值。<br><img src="https://img-blog.csdnimg.cn/20190928095303908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="Work"><a href="#Work" class="headerlink" title="Work"></a>Work</h4><p>加入的正则项如下，他主要想最大化这个比值，以实现输入端一个差值很小的输入却能引起输出端较大的模型差异。（笔者感觉这是一个方向，大家都在想让输出模型尽可能差别大一些，或者增大距离，或者映射到一个区别都更大的空间，这样模型才能输出多样性）<br><img src="https://img-blog.csdnimg.cn/20190928094607252.png" alt="在这里插入图片描述"><br>一般人们引入一个正则项后要加入一个权重系数来平衡，所以最终的目标函数如下：<br><img src="https://img-blog.csdnimg.cn/2019092809462128.png" alt="在这里插入图片描述"></p><h4 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h4><p>作者对于图像约束GAN（pairedimage and unpaired images）、文字约束GAN分别做了大量实验来验证它的正则化项好！<br>这里举一例paired image cGAN<br>作者用pix2pix做的baseline，数据集用的facades（建筑风格）与maps（地图映射）最终结果如下，这大家都说自己好的。<br><img src="https://img-blog.csdnimg.cn/20190928100956259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190928101215267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="《Mixture-Density-Generative-Adversarial-Networks》——-MDGAN"><a href="#《Mixture-Density-Generative-Adversarial-Networks》——-MDGAN" class="headerlink" title="《Mixture Density Generative Adversarial Networks》——-MDGAN"></a>《Mixture Density Generative Adversarial Networks》——-MDGAN</h3><p>这篇文章也是用来解决GAN的模型崩塌问题，传统的GAN中D只做了个打分操作，这里作者想到让D输出K维向量，然后在这个K维度空间去聚类不同的高斯模型。这不同的高斯模型就代表真实图像可能存在的模型（感觉做这方面改进的想法都差不多，我们能改进吗？）<br>源码：<a href="https://github.com/eghbalz/mdgan">https://github.com/eghbalz/mdgan</a>（作者还没写……只写了个readme）</p><h4 id="IDEA-1"><a href="#IDEA-1" class="headerlink" title="IDEA"></a>IDEA</h4><p>这里还是拿论文中一张图简要说一下作者思路，作者想构造更多的模型，他就像最后映射到一个高纬度空间，我们去聚类多个高斯模型这样就能形成更多的模型。<br><img src="https://img-blog.csdnimg.cn/20190928104712554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="Work-1"><a href="#Work-1" class="headerlink" title="Work"></a>Work</h4><p>作者主要的工作就是这个公司，定义了一个lk函数，lk函数如下，他把D输出的结果当成k维embedding来处理，将k维度向量放到C个高斯分布中去计算lk值，这个值越高就说明他服从这个高斯分布，然后这里C个模型相当于他想去映射k个不同的模型来提高图像的多样性（<strong>我不太懂得是他这C个模型参数是提前给定参数还是训练自动调？？？</strong>）<br><img src="https://img-blog.csdnimg.cn/20190928102928583.png" alt="在这里插入图片描述"><br><strong>注意：这里的权值是1/d+1，可不可以改进一下，引入个过拟合项，哈哈。</strong></p><p>然后实际损失函数如下，整体还是和GAN一样。<br><img src="https://img-blog.csdnimg.cn/20190928102406384.png" alt="在这里插入图片描述"></p><h4 id="Experiments-1"><a href="#Experiments-1" class="headerlink" title="Experiments"></a>Experiments</h4><p>作者分别对MNIST、Fashion-MNIST、CIFAR-10、CelebA数据集做了实验，取VanillaGAN以及WGAN、DRAGAN做对比实验，这里展示MNIST数据集实验结果如下：<br><img src="https://img-blog.csdnimg.cn/2019092810442663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="《Sphere-Generative-Adversarial-Network-Based-on-Geometric-Moment-Matching》"><a href="#《Sphere-Generative-Adversarial-Network-Based-on-Geometric-Moment-Matching》" class="headerlink" title="《Sphere Generative Adversarial Network Based on Geometric Moment Matching》"></a>《Sphere Generative Adversarial Network Based on Geometric Moment Matching》</h3><p>本篇文章也是旨在改良GAN网络训练时容易出现模型崩塌和不稳定的问题。原始的GAN网络损失函数计算特征embedding的一阶矩，GAN在训练的过程中会出现不稳定和模型崩塌，WGAN/WGAN-gp虽然引用了Wasserstein距离，一定程度上解决了这个问题，但是这些模型同样存在问题：对于模型的参数要求还是比较高，因此SphereGAN尝试不引入新的参数的情况下将模型整体进行变换，达到稳定模型的效果。<br>源码：<a href="https://github.com/Dotori-HJ/SphereGAN-Pytorch-implementation">https://github.com/Dotori-HJ/SphereGAN-Pytorch-implementation</a></p><h4 id="IDEA-2"><a href="#IDEA-2" class="headerlink" title="IDEA"></a>IDEA</h4><p>目前我还没全看完这篇文章，我理解的意思时，普通的一阶矩可能会突然距离很远，导致一些不稳定的现像，而我们把embedding弄到超球面，计算超球面距离就会被局限到超球面，以实现训练比较稳定的效果，可以看下图理解。<br>另外，作者说利用一个高维的特征以及超球面的特征来保证充分评测数据，以有一个好的结果。两者兼备了！优秀。<br><img src="https://img-blog.csdnimg.cn/20190928175111266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="Work-2"><a href="#Work-2" class="headerlink" title="Work"></a>Work</h4><p>下图展示了整个网络的示意图，前面和GAN网络一致修改了后面损失计算的部分。<br><img src="https://img-blog.csdnimg.cn/20190928175358963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>损失函数如下：<br><img src="https://img-blog.csdnimg.cn/20190928175322355.png" alt="在这里插入图片描述"></p><h4 id="Experiments-2"><a href="#Experiments-2" class="headerlink" title="Experiments"></a>Experiments</h4><p>作者在CIFAR上做了实验，下图为实验结果，效果还算提高了很多。<br><img src="https://img-blog.csdnimg.cn/20190928181804394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="《Geometry-Consistent-Generative-Adversarial-Networks-for-One-Sided-Unsupervised-Domain-Mapping》"><a href="#《Geometry-Consistent-Generative-Adversarial-Networks-for-One-Sided-Unsupervised-Domain-Mapping》" class="headerlink" title="《Geometry-Consistent Generative Adversarial Networks for One-Sided Unsupervised Domain Mapping》"></a>《Geometry-Consistent Generative Adversarial Networks for One-Sided Unsupervised Domain Mapping》</h3><p>本文提出一种几何一致的无监督Image2ImageGAN，相比于CycleGAN、distanceGAN有一个更好的效果，好像文中没有去解释与别人相比是否好，文中说是is compatible with other well-studied unsupervised constraints.但是实验结果他当然证明比别人好！</p><h4 id="IDEA-3"><a href="#IDEA-3" class="headerlink" title="IDEA"></a>IDEA</h4><p>起初image2image的生成对抗网络需要大量的pair图才能有一个好的效果，为此研究者提出好了cycleGAN构造Gxy和Gyx来把y作为中间隐含的变量；distanceGAN则是利用y距离来映射x之间距离，这里作者给出一种几何一致的方法，下图右侧所示，也是在不知道y的情况，用银含量去拟合。<br><img src="https://img-blog.csdnimg.cn/20190929225628893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="Experiments-3"><a href="#Experiments-3" class="headerlink" title="Experiments"></a>Experiments</h4><p>作者采用了SVHM与MNIST数据集作为x、y，对比了DistanceGAN、CycleGAN等实验方法，结果如下：<br><img src="https://img-blog.csdnimg.cn/20190929230344470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="《Towards-Optimal-Structured-CNN-Pruning-via-Generative-Adversarial-Learning》"><a href="#《Towards-Optimal-Structured-CNN-Pruning-via-Generative-Adversarial-Learning》" class="headerlink" title="《Towards Optimal Structured CNN Pruning via Generative Adversarial Learning》"></a>《Towards Optimal Structured CNN Pruning via Generative Adversarial Learning》</h3><p>本文算是比较新颖的一篇文章，作者将GAN网络应用到模型剪枝方面，提出了GAL网络。<br>源码：<a href="https://github.com/anonymouscvpr1983/GAL">https://github.com/anonymouscvpr1983/GAL</a></p><h4 id="IDEA-4"><a href="#IDEA-4" class="headerlink" title="IDEA"></a>IDEA</h4><p>这篇文章引用一个softmask（软掩码）与稀疏限制的思想去试图删掉原网络的一部分层去看它的效果，来训练得到一个和baseline相似效果的网络。</p><h4 id="Work-3"><a href="#Work-3" class="headerlink" title="Work"></a>Work</h4><p>网络框图如下所示，Generator完成对模型的压缩，Discrimantor完成对原始BaseLine模型和剪枝后的模型的评价，Discriminator优化使两个模型差距更大，而Generator使的模型效果和Baseline一致。<br><img src="https://img-blog.csdnimg.cn/20190928154442746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Generator分三方面去改动：</p><p>1）BlockSelection：这个方法适合resnet等带残差的网络，将网络分成许多块，每个块在传播时乘以参数m，m的值决定该block需要的程度，如果最后发现m变为0则该层就可以删掉。<br><img src="https://img-blog.csdnimg.cn/2019092816061059.png" alt="在这里插入图片描述"><br>2）BranchSelection：卷积核选择，对于1*1、3*3等卷积核分别乘以一定比例，决定卷积核对网络的影响多少；这个在googlenet等一些用多种卷积核的网络中有好处。<br><img src="https://img-blog.csdnimg.cn/20190928170840343.png" alt="在这里插入图片描述"></p><p>3）ChanelSelection：通道选择，这种优化方法对于每个卷积网络都适用。他是对于每一层卷积网络，在每它的每一个权重的基础上乘以参数m来限制该权重对整个模型的影响。最后清除m为0的权重。<br><img src="https://img-blog.csdnimg.cn/20190928170010400.png" alt="在这里插入图片描述"></p><h2 id="Experiments-4"><a href="#Experiments-4" class="headerlink" title="Experiments"></a>Experiments</h2><p>作者做了大量实验证明GAL在保证模型准确率的情况下大大压缩了模型的参数量。<br>如下图为MNIST数据集，LeNet与VGG模型的实验结果，作者用SSL和NISP方法对比， GAL 获得了最好的分类错误率与参数压缩量。<br><img src="https://img-blog.csdnimg.cn/20191009102643184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>除此之外，作者也对Resnet、GoogLenet、Densenet做了GAL优化，给出了优化结果。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> GAN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVPR </tag>
            
            <tag> MSGAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm更新代码到服务器端</title>
      <link href="/posts/Pycharm%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"/>
      <url>/posts/Pycharm%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>到设置-Deploment部署里，点加号，添加一个。<br><img src="https://img-blog.csdnimg.cn/20190906164351689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>选择SFTP</p><p><img src="https://img-blog.csdnimg.cn/20190906164425868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后，随便起个名字喽。再设置Connection选项。如下图<br><img src="https://img-blog.csdnimg.cn/20190906164621398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>之后需要设置Mappings，设置本地代码地址以及服务器代码地址，服务器代码地址点击右侧打开后去找就行。</p><p><img src="https://img-blog.csdnimg.cn/20190906164743579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>设置好后点击ok<br><img src="https://img-blog.csdnimg.cn/20190906164243452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>随后再代码部分右击会有deployment，分别有上传，下载，还有sync这样会同步所有不一样的，可以设置。<br><img src="https://img-blog.csdnimg.cn/20190906165005415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>sync下是这样界面，点击那个箭头可以改变更新方向，默认是按照时间更新。<br><img src="https://img-blog.csdnimg.cn/20190906165121395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>screen功能 linux后台运行程序</title>
      <link href="/posts/screen%E5%8A%9F%E8%83%BD%20linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
      <url>/posts/screen%E5%8A%9F%E8%83%BD%20linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>screen功能 linux后台运行程序</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h4 id="1创建screen进程"><a href="#1创建screen进程" class="headerlink" title="1创建screen进程"></a>1创建screen进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen  #进入screen环境</span><br></pre></td></tr></table></figure><h4 id="2进程下运行文件"><a href="#2进程下运行文件" class="headerlink" title="2进程下运行文件"></a>2进程下运行文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python a.py#运行a.py</span><br></pre></td></tr></table></figure><h4 id="3分离窗口"><a href="#3分离窗口" class="headerlink" title="3分离窗口"></a>3分离窗口</h4><p>先ctrl + a 进入命令模式，再按d分离窗口</p><h4 id="4列出当前进程"><a href="#4列出当前进程" class="headerlink" title="4列出当前进程"></a>4列出当前进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">screen -ls #列出当前进程</span><br><span class="line"></span><br><span class="line">There are screens on:</span><br><span class="line"> 22013.pts-37.hpcgpu30   (Detached)</span><br><span class="line"> 9915.pts-33.hpcgpu30    (Detached)</span><br></pre></td></tr></table></figure><h4 id="5再次进入窗口"><a href="#5再次进入窗口" class="headerlink" title="5再次进入窗口"></a>5再次进入窗口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r  22013</span><br></pre></td></tr></table></figure><h4 id="6杀死某个窗口"><a href="#6杀死某个窗口" class="headerlink" title="6杀死某个窗口"></a>6杀死某个窗口</h4><p>杀死22013窗口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 22013</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> screen </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Faiss源码安装</title>
      <link href="/posts/Faiss%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/"/>
      <url>/posts/Faiss%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>本篇文章提供了了Faiss安装的教程（CPU版安好了，GPU版有点问题，后补）</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h4 id="Step-1-下载FAISS"><a href="#Step-1-下载FAISS" class="headerlink" title="Step 1 下载FAISS"></a>Step 1 下载FAISS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/facebookresearch/faiss</span><br></pre></td></tr></table></figure><h4 id="Step-2-生成配置"><a href="#Step-2-生成配置" class="headerlink" title="Step 2 生成配置"></a>Step 2 生成配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd faiss</span><br><span class="line">./configure --with-cuda=/usr/local/cuda-9.0 --prefix=/home/cver/software/faiss/ --with-python=python3</span><br></pre></td></tr></table></figure><p>configure生成makfile文件，这里需要配置cuda目录，安装目录prefix</p><h4 id="Step-3-安装faiss"><a href="#Step-3-安装faiss" class="headerlink" title="Step 3 安装faiss"></a>Step 3 安装faiss</h4><p>我运行时存在一些问题不能安装GPU版本，这里我把GPU部分屏蔽了，以后再解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim makefile.inc</span><br><span class="line">-------------------------------</span><br><span class="line"></span><br><span class="line">NVCC         = /usr/local/cuda-9.0/bin/nvcc</span><br><span class="line">CUDA_ROOT    = /usr/local/cuda-9.0</span><br><span class="line">//CUDA_ARCH    = -gencode=arch=compute_35,code=compute_35 \</span><br><span class="line">//-gencode=arch=compute_52,code=compute_52 \</span><br><span class="line">//-gencode=arch=compute_60,code=compute_60 \</span><br><span class="line">//-gencode=arch=compute_61,code=compute_61 \</span><br><span class="line">//-gencode=arch=compute_70,code=compute_70 \</span><br><span class="line">//-gencode=arch=compute_75,code=compute_75</span><br></pre></td></tr></table></figure><br>修改之后，编译，安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="Step-4-安装swing3"><a href="#Step-4-安装swing3" class="headerlink" title="Step 4 安装swing3"></a>Step 4 安装swing3</h4><p>swing3是C++转python的桥梁…具体可以查一下。<br>首先要下载swing3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://sourceforge.net/projects/swig/files/swig/swig-3.0.12/swig-3.0.12.tar.gz</span><br><span class="line">tar -zxvf swig-3.0.12.tar.gz</span><br></pre></td></tr></table></figure><br>然后配置config<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash ./configure --prefix=/home/cver/software/swing3 --without-pcre</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><br>配置环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"></span><br><span class="line">-----------------------添加以下两句</span><br><span class="line">export SWIG_PATH=/home/cver/software/swing3/bin</span><br><span class="line">export PATH=$SWIG_PATH:$PATH</span><br></pre></td></tr></table></figure></p><h4 id="Step-5-生成python包"><a href="#Step-5-生成python包" class="headerlink" title="Step 5 生成python包"></a>Step 5 生成python包</h4><p>回到faiss目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make py</span><br></pre></td></tr></table></figure><br>仍然需要修改配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd python</span><br><span class="line">vim Makefile</span><br><span class="line"></span><br><span class="line">---------------------我没有sudo权限，所以我安装到自己目录下</span><br><span class="line">$(PYTHON) setup.py install --prefix=/home/cver/.local</span><br></pre></td></tr></table></figure><br>配置好后编译，安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 人脸识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> faiss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Summary Of Face Recognition</title>
      <link href="/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E9%82%A3%E7%82%B9%E4%BA%8B---%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%96%B9%E6%A1%88summary/"/>
      <url>/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E9%82%A3%E7%82%B9%E4%BA%8B---%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%96%B9%E6%A1%88summary/</url>
      
        <content type="html"><![CDATA[<p>通俗易懂教你如何做人脸识别</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h1 id="The-Summary-Of-Face-Recognition"><a href="#The-Summary-Of-Face-Recognition" class="headerlink" title="The Summary Of Face Recognition"></a>The Summary Of Face Recognition</h1><p>[全文共计7162字，预计阅读15分钟，消耗脑容量20MB]</p><blockquote><p>人脸识别包含人脸检测、人脸对齐、人脸识别三个步骤。<br>首先利用人脸检测(FaceDetiction)识别图像中所有人脸，回归人脸的boundbox。<br>然后对于识别出的人脸，可能会有歪头的，如果直接做recognition可能准确率较低，所以&gt;我们需要做一步人脸对齐(FaceAlign)，把所有人脸转为一个标准（正方形内，两眼对齐，嘴巴两侧对齐…）。<br>最后我们需要对所有的人脸做识别，提取特征与员工特征库进行对比。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190821185319477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="Part-1-FaceDetiction"><a href="#Part-1-FaceDetiction" class="headerlink" title="Part 1 FaceDetiction"></a>Part 1 FaceDetiction</h1><p>人脸检测（待总结…）<br><img src="https://img-blog.csdnimg.cn/20190821160732897.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="Part-2-FaceRecognition"><a href="#Part-2-FaceRecognition" class="headerlink" title="Part 2 FaceRecognition"></a>Part 2 FaceRecognition</h1><blockquote><p>其实人脸识别可以从两个角度做，之前人们一直是当成分类任务做，现在更多的是1：1特征对比；<br>先说分类任务，我们先对数据进行人脸检测以及对齐得到一个对齐后的人脸数据集，在训练集中每个类（标签/人）下有许多图片（都是对齐好的），然后对数据做一个分类任务，常规的分类模型有googlenet、resnet、densenet、mobilenet（移动端）等等，目标函数用softmax损失函数。<br>后者1：1比对，把分类网络当成特征提取器提取特征，和人脸库对比，欧氏距离小于一定阈值就认为比对成功。这里注意的是人脸库里面是标准照片直接前向传播得到的embedding 特征层。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190821144643515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Part-2-1-InsightFace框架"><a href="#Part-2-1-InsightFace框架" class="headerlink" title="Part 2.1 InsightFace框架"></a>Part 2.1 InsightFace框架</h2><p>我们先看一下insightface的框架是怎么做的。这我自己画的一个简单的图，其实很简单，人脸识别分类代码分为两部分，一部分在特征提取网络，用成熟的分类网络提取特征，得到embedding向量，可以看为FaceImage2Vector。这个维度可以自己设计，大家都选的512（抱歉，一个特别的日子，我们一起默哀一会。）然后常规做法，我们会用全连接层转到class_num维度，这时搞一个softmax去做损失即可。后来，大佬们就觉得损失不够好开始改，这个我在2.2中去介绍一下这一系列损失函数的变化。<br><img src="https://img-blog.csdnimg.cn/20190821162957233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后接下来，我们看一下人脸识别代码怎么评测？</p><h2 id="Part-2-2-模型评测"><a href="#Part-2-2-模型评测" class="headerlink" title="Part 2.2 模型评测"></a>Part 2.2 模型评测</h2><p>对于普通分类问题，可能我们考察一个模型好坏，主要看测试集准确率就可以；对于人脸识别问题，我们有开集和闭集之说，闭集是指训练集与测试集人物一样，不会出现不认识的人，一般只在我们的某个领域，比如某个公司不会来外人。但实际不可能，人脸是个很大的开集，我们的训练集不可能囊括所有人，你训练一个模型，比如公司内部，万一有个别的人来了，这破机器认为他就是内部的人，因为可能模型不能很好的区分开。所以这就有了开集测试的重要性。</p><p>实际我们做人脸识别考察是在我们的库里训练一个更好的特征提取器，这个提取器拥有很好的区分能力。如果只在闭集测试，那就看准确率就行；如果在开集测试，我们就要看他在其他数据集上的区分度，怎么测？我们取样N对图像，看每一对两个图像是否属于一个类，我们搞一个阈值，两个图像的特征（由特征提取器提取）欧氏距离小于阈值就认为属于一个类，否则不属于一个类。我们看他能实现多高的准确率。</p><p>做1：1认证，我们需要准备一个pair测试文件，格式如下：</p><blockquote><p>图A地址  图B地址  0/1（代表着是否为同类）</p></blockquote><p>这里注意两张图片是不同图片，大概可能会有3000正例（同类），3000负例。做比对之后我们会有一个结果</p><blockquote><p>TP代表正确识别为正例的样本（原来是正例）   TN正确识别为负例的样本（原来是负例）<br>FP代表错误识别为正例的样本（原来是负例）   FN错误识别为负例的样本（原来是正例）<br>TN+FP代表测试负例，也就是类间测试次数<br>TP+FN代表测试正例，也就是类内测试次数<br>（这里类内测试是指同属于一个类的样本测试，看他们是否足够接近，类间测试是对于不同类的测试，看他们距离是否足够大）<br>FN为错误识别为负例的样本，也是错误接受的次数<br>FP同理代表错误拒绝的次数</p></blockquote><p>然后我们会用以下指标考查：<br>（1）准确率：实验中直接采用(TP+TN)/SUM；考察越高越好。</p><p>TPR召回率：TP/(TP+FN)；考察越高越好</p><p>FPR假正例率：FP/(TN+FP)；考察越低越好</p><p>（2）FAR误识率：FAR = 错误接受次数/类间测试次数=FN/(TN+FP)；考察越低越好。</p><p>（3）FRR拒识率：FRR = 错误拒绝次数/类内测试次数=FP/(TP+FN)；考察越低越好。</p><h2 id="Part-2-3-损失函数回顾"><a href="#Part-2-3-损失函数回顾" class="headerlink" title="Part 2.3 损失函数回顾"></a>Part 2.3 损失函数回顾</h2><blockquote><p>人脸识别和一般的分类任务不太一样，他更大的特点在于类目多，我们训练13亿人，要让他对地球人进行适应，并且类间差距可能也小，样本有时不均衡，数据不多。所以对于人脸识别要求有更好的泛化能力、容错能力。我们从基本的softmax一点一点看一看</p></blockquote><h3 id="Part-2-3-1-softmax损失"><a href="#Part-2-3-1-softmax损失" class="headerlink" title="Part 2.3.1 softmax损失"></a>Part 2.3.1 softmax损失</h3><p>softmax损失函数是最经典的损失函数，用于多分类问题；softmax损失作用于标签所对应类Y_i的得分，优化提高它的概率得分，所以对于闭集的分类能有一个好的结果；<br><img src="https://img-blog.csdnimg.cn/20190821165213487.png" alt="在这里插入图片描述"><br>然而我们了解人脸识别一般是开集的，测试集是所有可能进入你的检测系统的人，有两个问题？一则来了一个外人，你是否能把他排出去？二则稍微脸上变了点，你是否能很好地分开？softmax做损失在训练集能很好的分开，但是不能很好的增加类外间距，减小类内间距。</p><blockquote><p>这里补充一下什么是类内间距，类外间距？<br>划分多个类，无非是把它映射到某一个featuremap，然后做一个超平面，把它们分开，类内间距，就是一个类自己的划分区域最大伸展距离，其实就是它的空间。类外间距就是每个类区域之间的间距。我们想要的结果是他们之间的间隔大一点，这样会有一定的容错能力，泛化能力；类内的间隔小一些，这样聚类效果更好一些。</p></blockquote><p>随后大家就开始增大类外间距，减小类内间距的探索。</p><h3 id="Part-2-3-2-Triplet-Loss"><a href="#Part-2-3-2-Triplet-Loss" class="headerlink" title="Part 2.3.2 Triplet Loss"></a>Part 2.3.2 Triplet Loss</h3><p>Triplet loss属于Metric Learning, 相比起softmax, 它可以方便地训练大规模数据集，不受显存的限制。缺点是过于关注局部，导致难以训练且收敛时间长</p><blockquote><p>这里提一下Metric Learning的概念，它是根据不同的任务来自主学习出针对某个特定任务的度量距离函数。通过计算两张图片之间的相似度，使得输入图片被归入到相似度大的图片类别中去。通常的目标是使同类样本之间的距离尽可能缩小，不同类样本之间的距离尽可能放大。</p></blockquote><p>Triplet loss是这么干的，搞三种图片进去，图A，与图A同类的图，与图A不是同类的图，然后损失函数如下，目的就是让同类的图更近，不同类的图更远。</p><pre><code>         $$L=max(d(a,p)−d(a,n)+margin,0)$$</code></pre><p><img src="https://img-blog.csdnimg.cn/20190823104456649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="Part-2-3-3-L-Softmax"><a href="#Part-2-3-3-L-Softmax" class="headerlink" title="Part 2.3.3 L-Softmax"></a>Part 2.3.3 L-Softmax</h3><p>到L-Softmax，人们就开始直接搞一个间距给损失函数，下图中第一个是softmax做十分类的二维特征图，可以看出来是分开了，但是很拥挤。如果放一张训练集之外的图可能就分错了。</p><blockquote><p>这里我对这个图做一个解释，首先数据实验是将损失函数前的embedding层定为二维（X1,X2）也就对应着图里的横纵坐标；然后在正式损失之前有个全连接层，对于这个W维度应该是（2，class）这里实验是对手写数字体做实验，所以class=10，这里我们认为W=(W_1,W_2,W_3,…,W_10)代表10个子权重，其实我们去看$W\cdot X= ||W||<em>|X| </em>cos\theta = ( ||W_1||<em>|X| </em>cos\theta_1,||W_2||<em>|X| </em>cos\theta_2,…)$最后每一项代表该类的得分，也就是哪一项值大就更属于哪一类。此时权重是一个可调量，我们认为他是平面内十个向量，然后同样一个X看他和谁的点乘更大就更好。再者由于cos在0-180度内是单调函数，所以角度越小越好，||W||越大越好。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190821171557148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>L-Softmax就对$\theta$做了个间距，如下公式，对于不是本类的还是原来操作（注意这里写为$W\cdot X=||W||<em>||X||</em>cos\theta$），对于本类，我们把角度$\theta$变成$m\theta$，此处m代表提升的倍数，这样让他本来可能模型认为分类不错，但是我们强行把角度增大，使得效果不是很好，这会模型只能说好吧，按照这个继续去优化，去适应这个间隙。</p><p><img src="https://img-blog.csdnimg.cn/20190821172959595.png" alt="在这里插入图片描述"><br>另外为了损失函数单调，我们搞了个条件限制mt<img src="https://img-blog.csdnimg.cn/2019082117294528.png" alt="在这里插入图片描述"><br>然后我们再看上面那张彩图，对于不同m，投射出来的间隙确实不一样，之间的间隙越来越大。m越大分割的类间距越大，类内间距越小，聚类的效果越好，当然这个值也不能太大，可能会不收敛。</p><p><img src="https://img-blog.csdnimg.cn/20190821171557148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="Part-2-3-4-SphereFace-A-softmax"><a href="#Part-2-3-4-SphereFace-A-softmax" class="headerlink" title="Part 2.3.4 SphereFace( A-softmax)"></a>Part 2.3.4 SphereFace( A-softmax)</h3><p>SphereFace是在L-Softmax的基础上将权重进行归一化，L-Softmax会同时从角度和权重长度上区分不同类别，而SphereFace只从角度上去区分不同类别（因为||W|| = 1了）<br><img src="https://img-blog.csdnimg.cn/20190821170424118.png" alt="在这里插入图片描述"><br>这里可以用他论文里这张图，这里（a）和（b）是softmax loss的结果；（c）和（d）是限制W1和W2向量的模等于1，而且b1和b2偏置等于0，称为modified softmax loss；（e）和（f）是angular softmax loss；我们能看出softmax点比较散，类间距几乎没有，我们把W1标准化，b=0发现，产生了一定间距，进而他做了margin发现间距更大了。之前的L-softmax没有对权重归一化，使得类的结果还要考虑W，这样测间距就比较复杂，A-softmax只需要衡量角度即可。<br><img src="https://img-blog.csdnimg.cn/20190823114805527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="Part-2-3-5-CosFace-LMSL-Large-Margin-Cosine-Loss"><a href="#Part-2-3-5-CosFace-LMSL-Large-Margin-Cosine-Loss" class="headerlink" title="Part 2.3.5 CosFace( LMSL: Large Margin Cosine Loss)"></a>Part 2.3.5 CosFace( LMSL: Large Margin Cosine Loss)</h3><p>CosFace的思想和SphereFace( A-softmax)的思想接近，其中主要做了以下三点的改进：</p><ul><li>loss的形式做了稍微的改变，将超参数m由乘法运算变成了减法运算</li><li>不仅对权重进行了正则化，还对特征进行了正则化。</li><li>对归一化后的值乘上一个scale参数，超球面过小时，分类映射到超球面上不好分类，这个scale参数可以扩大超球面体积，这是后面的损失一直在用的观点。</li></ul><p><img src="https://img-blog.csdnimg.cn/2019082117365039.png" alt="在这里插入图片描述"></p><h3 id="Part-2-3-6-ArcFace"><a href="#Part-2-3-6-ArcFace" class="headerlink" title="Part 2.3.6 ArcFace"></a>Part 2.3.6 ArcFace</h3><p>ArcFace是在CosFace基础上又改了下，前面有过对于角度乘以一个margin，这里它直接在角度上加一个margin，得到了一个很好的结果，如下所示。<br><img src="https://img-blog.csdnimg.cn/20190821174050423.png" alt="在这里插入图片描述"><br>论文中对多个损失函数做了一个对比，如下图所示，普通softmax就是分开即可，类间距几乎没有，SpherFace在角度上乘以margin可以增加内间距，但是存在角度为0的地方会有交集，这是一个问题；ArcFace也是在角度上做的margin，他是直接加一个margin，就解决了0度角的交集；CosFace则是在角度的cos值基础上加了一个margin也能在cosi基础上做好间距。<br><img src="https://img-blog.csdnimg.cn/20190821174210759.png" alt="在这里插入图片描述"></p><h1 id="Part-3-InsightFace"><a href="#Part-3-InsightFace" class="headerlink" title="Part 3 InsightFace"></a>Part 3 InsightFace</h1><h2 id="Part-3-1-代码结构"><a href="#Part-3-1-代码结构" class="headerlink" title="Part 3.1 代码结构"></a>Part 3.1 代码结构</h2><p>我做了这么一张图，大概展示代码的整个结构，Insightface源码在这：<a href="https://github.com/deepinsight/insightface#pretrained-models">https://github.com/deepinsight/insightface#pretrained-models</a><br>我们如果只关注人脸识别部分，更多的要去看src以及recognition部分代码<br><img src="https://img-blog.csdnimg.cn/20190823105859490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Part-3-2-人脸识别实验"><a href="#Part-3-2-人脸识别实验" class="headerlink" title="Part 3.2 人脸识别实验"></a>Part 3.2 人脸识别实验</h2><p>这里我们以搭建一个人脸识别方案的例子展开，首先需要准备数据，数据准备完后我们需要对数据进行人脸识别+对齐，这部分可以采用MTCNN方法，在src/align中，附上我的实际操作总结：<a href="https://blog.csdn.net/CLOUD_J/article/details/98769515">insightface数据制作全过程记录</a>然后对于对齐好的数据，我们可以进行用insightface提供的模型做初步验证，可以参考：<a href="https://blog.csdn.net/CLOUD_J/article/details/98882718">insightface测试recognition验证集效果全过程</a>测试结束，我们可以进行训练，可以参考：<a href="https://blog.csdn.net/CLOUD_J/article/details/98941498">insightface中recognition训练过程</a></p><h1 id="Part-4-人脸识别部署"><a href="#Part-4-人脸识别部署" class="headerlink" title="Part 4 人脸识别部署"></a>Part 4 人脸识别部署</h1><p>（待补充）</p><hr><p>幸福是靠自己正确的！用黄晓明的一句话，我不管你怎么想，我只说我要怎样！加油！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 人脸识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> insightface </tag>
            
            <tag> 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python + web操作 爬虫 自动填写表单</title>
      <link href="/posts/python%20+%20web%E6%93%8D%E4%BD%9C%20%E7%88%AC%E8%99%AB%20%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%86%99%E8%A1%A8%E5%8D%95/"/>
      <url>/posts/python%20+%20web%E6%93%8D%E4%BD%9C%20%E7%88%AC%E8%99%AB%20%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%86%99%E8%A1%A8%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>最近想做一个自动填表单提交的程序，用到了webdriver这个东西，做了简答的总结。</p><a id="more"></a><h3 id="Pre-install-package"><a href="#Pre-install-package" class="headerlink" title="Pre install package"></a>Pre install package</h3><p><strong>安装webdriver库(chorme版本)</strong>：找到你的版本，下载好放到Google/Chrome/Application文件夹下<br><a href="http://npm.taobao.org/mirrors/chromedriver/">http://npm.taobao.org/mirrors/chromedriver/</a><br><img src="https://blogpic-1257632417.cos.ap-chengdu.myqcloud.com/BlogGit/2019/20190821154924317.png" alt="在这里插入图片描述"><br><img src="https://blogpic-1257632417.cos.ap-chengdu.myqcloud.com/BlogGit/2019/2019082115522843.png" alt="在这里插入图片描述"><br>配置环境变量C:\Users\menglingjun\AppData\Local\Google\Chrome\Application把这个加到环境变量，可能你那不一样，就是把chromedriver在的文件夹路径。</p><p><strong>安装python selenium库</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install selenium</span><br></pre></td></tr></table></figure></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>导入web库</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br></pre></td></tr></table></figure><br><strong>创建driver对象并读取某网页</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver= webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">'http://www.baidu.com'</span>)</span><br></pre></td></tr></table></figure><br><strong>获取网页上某元素并改内容</strong><br>网页上有个审查元素，可以右键看审查元素，这个大家都会。google浏览器中叫做“检查”</p><p>点击下图中那个按钮，就可以进入选取状态，此时我们选取左侧某个内容，右侧就会对应到他那一行代码，我们可以看到它的id，name等信息。<br><img src="https://blogpic-1257632417.cos.ap-chengdu.myqcloud.com/BlogGit/2019/20190821155813517.png" alt="在这里插入图片描述"><br>根据这些id、name找到它的位置。<br><img src="https://blogpic-1257632417.cos.ap-chengdu.myqcloud.com/BlogGit/2019/20190821155933472.png" alt="在这里插入图片描述"><br>这里可以by_id也可以by_name等等，然后send_key更改信息，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = driver.find_element_by_id(<span class="string">"id_username"</span>)</span><br><span class="line">name.send_keys(<span class="string">"data_operation"</span>)</span><br></pre></td></tr></table></figure></p><p><strong>按钮类操作</strong><br>获取按钮，然后点击。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">login_button = driver.find_element_by_class_name(<span class="string">"submit-row"</span>)</span><br><span class="line">login_button.click()</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过这些操作，我们可以实现网页表单自动填写。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 网络爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> webdriver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VIM最近使用常见指令总结</title>
      <link href="/posts/VIM%E6%9C%80%E8%BF%91%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/posts/VIM%E6%9C%80%E8%BF%91%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本文总结了VIM编辑器的一些常见指令</p><a id="more"></a><h2 id="1-基本功"><a href="#1-基本功" class="headerlink" title="1 基本功"></a>1 基本功</h2><blockquote><p>基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 </p></blockquote><h3 id="1-1-命令模式："><a href="#1-1-命令模式：" class="headerlink" title="1.1 命令模式："></a>1.1 命令模式：</h3><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><ul><li>i 切换到输入模式，以输入字符。 </li><li>x 删除当前光标所在处的字符。 </li><li>: 切换到底线命令模式，以在最底一行输入命令。</li></ul><h3 id="1-2-输入模式"><a href="#1-2-输入模式" class="headerlink" title="1.2 输入模式"></a>1.2 输入模式</h3><p>在命令模式下按下i就进入了输入模式。输入状态就直接打字就可以，记住以下几个指令</p><ul><li>HOME/END，移动光标到行首/行尾 </li><li>Page Up/Page Down，上/下翻页</li><li>Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 </li><li><strong>ESC，退出输入模式，切换到命令模式</strong></li></ul><p><strong>记住写完了按下ESC就回到命令模式1.1中</strong></p><h3 id="1-3-底线命令模式"><a href="#1-3-底线命令模式" class="headerlink" title="1.3 底线命令模式"></a>1.3 底线命令模式</h3><p>在<strong>命令模式</strong>下按下:（英文冒号）就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序 </li><li>w 保存文件</li><li>q!    若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</li></ul><p><strong>一般我们写完了，按ESC回退到命令模式，再按:qw回车保存并退出。</strong></p><h2 id="2-命令模式其他功能"><a href="#2-命令模式其他功能" class="headerlink" title="2 命令模式其他功能"></a>2 命令模式其他功能</h2><p>命令模式下页面变换</p><ul><li><strong>nG    n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行</strong></li><li>gg    移动到这个档案的第一行，相当于 1G 啊！ (常用) n<Enter>    n 为数字。光标向下移动 n 行(常用) </li><li><strong>[Ctrl] +[f]    屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</strong> </li><li><strong>[Ctrl] + [b]    屏幕『向上』移动一页，相当于[Page Up] 按键 (常用)</strong> </li><li>[Ctrl] + [d]    屏幕『向下』移动半页 </li><li>[Ctrl] + [u]    屏幕『向上』移动半页</li></ul><p>搜索替换功能</p><ul><li><strong>/word    向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用)</strong> </li><li>?word    向光标之上寻找一个字符串名称为 word 的字符串。</li><li><strong>n    这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</strong></li><li>N    这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</li><li>:1,$s/word1/word2/g 或 :%s/word1/word2/g    从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</li><li>:1,$s/word1/word2/gc 或 :%s/word1/word2/gc    从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]菜鸟教程 <a href="https://www.runoob.com/linux/linux-vim.html">https://www.runoob.com/linux/linux-vim.html</a></p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 参数模块argparse使用</title>
      <link href="/posts/python%20%E5%8F%82%E6%95%B0%E6%A8%A1%E5%9D%97argparse%E4%BD%BF%E7%94%A8/"/>
      <url>/posts/python%20%E5%8F%82%E6%95%B0%E6%A8%A1%E5%9D%97argparse%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>python 参数模块argparse使用<br>最近在用，做下总结！</p><a id="more"></a><blockquote><p>argparse是python的一个命令行解析包，用于编写可读性非常好的程序</p></blockquote><h4 id="1创建参数"><a href="#1创建参数" class="headerlink" title="1创建参数"></a>1创建参数</h4><p>导入包；创建参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(<span class="string">"name"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="2添加参数"><a href="#2添加参数" class="headerlink" title="2添加参数"></a>2添加参数</h4><p>添加参数，包括参数名data_dir表示为—data-dir<br>default默认值<br>help<br>注意：所有参数均为字符串型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--data-dir'</span>, default=<span class="string">''</span>, help=<span class="string">''</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--image-size'</span>, type=str, default=<span class="string">'112,112'</span>, help=<span class="string">''</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--output'</span>, default=<span class="string">''</span>, help=<span class="string">'path to save.'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--num-samepairs'</span>,default=<span class="number">100</span>)</span><br></pre></td></tr></table></figure></p><h4 id="3程序中用参数"><a href="#3程序中用参数" class="headerlink" title="3程序中用参数"></a>3程序中用参数</h4><p>创建对象，然后获取它的值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">args = parser.parse_args()</span><br><span class="line">lfw_dir = args.data_dir</span><br></pre></td></tr></table></figure></p><h4 id="4命令行如何用"><a href="#4命令行如何用" class="headerlink" title="4命令行如何用"></a>4命令行如何用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 verification.py --data-dir ../lfw  --nfolds <span class="number">10</span> --target lfw</span><br></pre></td></tr></table></figure><h4 id="5参数分组设置"><a href="#5参数分组设置" class="headerlink" title="5参数分组设置"></a>5参数分组设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add_argument_group()</span><br><span class="line">参数分组设置。当有分组命令的需求时可用，输入参数将归于所属分组下.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(</span><br><span class="line">        formatter_class=argparse.ArgumentDefaultsHelpFormatter,</span><br><span class="line">        description=<span class="string">'Create an image list or \</span></span><br><span class="line"><span class="string">        make a record database by reading from an image list'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'prefix'</span>, help=<span class="string">'prefix of input/output lst and rec files.'</span>)</span><br><span class="line"></span><br><span class="line">    cgroup = parser.add_argument_group(<span class="string">'Options for creating image lists'</span>)</span><br><span class="line">    cgroup.add_argument(<span class="string">'--list'</span>, action=<span class="string">'store_true'</span>, help=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><h4 id="6参数action"><a href="#6参数action" class="headerlink" title="6参数action"></a>6参数action</h4><p>有的参数带有action表示在命令行时直接加上这个参数，不赋值就直接按照action行动。<br>例如：下面的行动是store_true，设置list为真，这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgroup.add_argument(<span class="string">'--list'</span>, action=<span class="string">'store_true'</span>,help=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><br>这样程序中可以<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.list:</span><br><span class="line">    make_list(args)</span><br></pre></td></tr></table></figure><br>运行时直接加—list代表设置为真<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 im2rec.py --list --recursive ../../datasets/lfw/lfw ../../datasets/lfw2</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> argparse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 文件操作OS总结</title>
      <link href="/posts/python%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9COS%E6%80%BB%E7%BB%93/"/>
      <url>/posts/python%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9COS%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本文总结了关于python文件系统的操作。</p><a id="more"></a><p>python 文件操作OS总结<br>最近在用，坐下总结！</p><p>os的一些操作</p><h4 id="os-listdir-path"><a href="#os-listdir-path" class="headerlink" title="os.listdir(path)"></a>os.listdir(path)</h4><p>列出该文件夹下面的目录，一般这么用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">folders_1 = os.listdir(prefix)</span><br><span class="line"><span class="keyword">for</span> folder <span class="keyword">in</span> folders_1:</span><br><span class="line">...<span class="comment">#遍历这个目录</span></span><br></pre></td></tr></table></figure></p><h4 id="os-makedirs-path"><a href="#os-makedirs-path" class="headerlink" title="os.makedirs(path)"></a>os.makedirs(path)</h4><p>创建该路径<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.makedirs(path, mode=<span class="number">0o777</span>)</span><br></pre></td></tr></table></figure></p><h4 id="os-path-模块"><a href="#os-path-模块" class="headerlink" title="os.path() 模块"></a>os.path() 模块</h4><p>文件路径模块<br>1、路径拆分<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.split(path) 把路径分割成 dirname 和 basename，返回一个元组</span><br></pre></td></tr></table></figure><br>2、路径合并<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.join(path1, path2,...)把目录和文件名合成一个路径</span><br></pre></td></tr></table></figure><br>3、查看路径是否存在<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.path.exists(path)路径存在则返回<span class="literal">True</span>,路径损坏返回<span class="literal">False</span></span><br></pre></td></tr></table></figure><br>一般这么用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(out_dir):</span><br><span class="line">    os.makedirs(out_dir)</span><br></pre></td></tr></table></figure></p><h4 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h4><p>打开文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(name[, mode[, buffering]])</span><br></pre></td></tr></table></figure><br>模式如下<br><img src="https://blogpic-1257632417.cos.ap-chengdu.myqcloud.com/BlogGit/2019/2019081311550612.png" alt="在这里插入图片描述"><br>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(img_root_path, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines()[<span class="number">0</span>:]:</span><br><span class="line">        pair = line.strip().split(<span class="string">','</span>)</span><br><span class="line">        pairs_end += pairs_F[int(pair[<span class="number">0</span>])],pairs_N[int(pair[<span class="number">1</span>])]</span><br><span class="line">        <span class="keyword">if</span> pair == <span class="string">'same'</span>:</span><br><span class="line">            issame_list.append(<span class="string">'True'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            issame_list.append(<span class="string">'False'</span>)</span><br><span class="line"><span class="keyword">return</span> pairs_end,issame_list</span><br></pre></td></tr></table></figure><p>创建文件对象，又会衍生出他的方法</p><h4 id="file-对象方法"><a href="#file-对象方法" class="headerlink" title="file 对象方法"></a>file 对象方法</h4><p><strong>file.read([size])</strong>：size 未指定则返回整个文件，如果文件大小 &gt;2 倍内存则有问题，f.read()读到文件尾时返回””(空字串)。<br><strong>file.readline()</strong>：返回一行。这个在上面那个例子提到，我们一行一行读取。<br><strong>file.readlines([size])</strong> ：返回包含size行的列表, size 未指定则返回全部行。<br><strong>for line in f: print line</strong> ：通过迭代器访问。<br><strong>f.write(“hello\n”)</strong>：如果要写入字符串以外的数据,先将他转换为字符串。<br><strong>f.tell()</strong>：返回一个整数,表示当前文件指针的位置(就是到文件头的比特数)。<br><strong>f.seek(偏移量,[起始位置])</strong>：用来移动文件指针。<br>偏移量: 单位为比特，可正可负<br>起始位置: 0 - 文件头, 默认值; 1 - 当前位置; 2 - 文件尾<br><strong>f.close()</strong> 关闭文件</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>insightface中recognition训练过程</title>
      <link href="/posts/insightface%E4%B8%ADrecognition%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B/"/>
      <url>/posts/insightface%E4%B8%ADrecognition%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>insightface中recognition训练过程<br><a id="more"></a></p><h3 id="1-config文件"><a href="#1-config文件" class="headerlink" title="1 config文件"></a>1 config文件</h3><p>到目录/recognition/下有sample_config.py文件，这是给了个样例配置文件，我们复制一下起名config.py然后编辑 config.py  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp sample_config.py config.py</span><br><span class="line">vim config.py</span><br></pre></td></tr></table></figure><p>config下做了一些配置</p><blockquote><p>default默认配置<br>config配置<br>network网络模型参数<br>loss损失函数选择<br>dataset数据集配置<br>generate_config生成配置文件，把network、loss、dataset配置都加载config上。</p></blockquote><p>然后看train.py文件</p><h3 id="2-main"><a href="#2-main" class="headerlink" title="2 main"></a>2 main</h3><p>主函数比较简单，参数填进去就可以了。这里需要特别注意下参数这一块。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> args</span><br><span class="line">    args = parse_args()</span><br><span class="line">    train_net(args)</span><br></pre></td></tr></table></figure></p><p>到最开始那里有参数，如下，我们注意先来三个参数dataset、network、loss然后有一个generate_config生成配置，吧三个参数组合到config里，这里这三个参数要和config.py里面每个参数起的名字一样哦<br>例如dataset  : emore   retina 当然你也可以自己改配置文件自己加<br>network :r100 r50 r100fc<br>…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_args</span><span class="params">()</span>:</span></span><br><span class="line">  parser = argparse.ArgumentParser(description=<span class="string">'Train face network'</span>)</span><br><span class="line">  <span class="comment"># general</span></span><br><span class="line">  parser.add_argument(<span class="string">'--dataset'</span>, default=default.dataset, help=<span class="string">'dataset config'</span>)</span><br><span class="line">  parser.add_argument(<span class="string">'--network'</span>, default=default.network, help=<span class="string">'network config'</span>)</span><br><span class="line">  parser.add_argument(<span class="string">'--loss'</span>, default=default.loss, help=<span class="string">'loss config'</span>)</span><br><span class="line">  args, rest = parser.parse_known_args()</span><br><span class="line">  generate_config(args.network, args.dataset, args.loss)</span><br><span class="line">  parser.add_argument(<span class="string">'--models-root'</span>, default=default.models_root, help=<span class="string">'root directory to save model.'</span>)</span><br><span class="line">  parser.add_argument(<span class="string">'--pretrained'</span>, default=default.pretrained, help=<span class="string">'pretrained model to load'</span>)</span><br><span class="line">  parser.add_argument(<span class="string">'--pretrained-epoch'</span>, type=int, default=default.pretrained_epoch, help=<span class="string">'pretrained epoch to load'</span>)</span><br><span class="line">  parser.add_argument(<span class="string">'--ckpt'</span>, type=int, default=default.ckpt, help=<span class="string">'checkpoint saving option. 0: discard saving. 1: save when necessary. 2: always save'</span>)</span><br><span class="line">  parser.add_argument(<span class="string">'--verbose'</span>, type=int, default=default.verbose, help=<span class="string">'do verification testing and model saving every verbose batches'</span>)</span><br><span class="line">  parser.add_argument(<span class="string">'--lr'</span>, type=float, default=default.lr, help=<span class="string">'start learning rate'</span>)</span><br><span class="line">  parser.add_argument(<span class="string">'--lr-steps'</span>, type=str, default=default.lr_steps, help=<span class="string">'steps of lr changing'</span>)</span><br><span class="line">  parser.add_argument(<span class="string">'--wd'</span>, type=float, default=default.wd, help=<span class="string">'weight decay'</span>)</span><br><span class="line">  parser.add_argument(<span class="string">'--mom'</span>, type=float, default=default.mom, help=<span class="string">'momentum'</span>)</span><br><span class="line">  parser.add_argument(<span class="string">'--frequent'</span>, type=int, default=default.frequent, help=<span class="string">''</span>)</span><br><span class="line">  parser.add_argument(<span class="string">'--per-batch-size'</span>, type=int, default=default.per_batch_size, help=<span class="string">'batch size in each context'</span>)</span><br><span class="line">  parser.add_argument(<span class="string">'--kvstore'</span>, type=str, default=default.kvstore, help=<span class="string">'kvstore setting'</span>)</span><br><span class="line">  args = parser.parse_args()</span><br><span class="line">  <span class="keyword">return</span> args</span><br></pre></td></tr></table></figure><p>然后主要看train.py文件</p><h3 id="3-train"><a href="#3-train" class="headerlink" title="3 train"></a>3 train</h3><p>前面会选择GPU，然后make 存模型的文件夹，然后读数据集bin文件</p><p>加载预训练模型，如果有预训练模型，就直接加载checkpoint模型参数到arg_params，aux_params，然后sym = get_symbol(args)走一个前向传播，如果没有模型则声明个none。参数在后面fit时有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> len(args.pretrained)==<span class="number">0</span>:</span><br><span class="line">  arg_params = <span class="literal">None</span></span><br><span class="line">  aux_params = <span class="literal">None</span></span><br><span class="line">  sym = get_symbol(args)</span><br><span class="line">  <span class="keyword">if</span> config.net_name==<span class="string">'spherenet'</span>:</span><br><span class="line">    data_shape_dict = &#123;<span class="string">'data'</span> : (args.per_batch_size,)+data_shape&#125;</span><br><span class="line">    spherenet.init_weights(sym, data_shape_dict, args.num_layers)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">'loading'</span>, args.pretrained, args.pretrained_epoch)</span><br><span class="line">  _, arg_params, aux_params = mx.model.load_checkpoint(args.pretrained, args.pretrained_epoch)</span><br><span class="line">  sym = get_symbol(args)</span><br></pre></td></tr></table></figure><p>这里有个get_symbol前面有定义，我们到前面能看到，写了一大堆，我们看一点<br>这里先获取你的网络的模型net_name这一套在/recognition/symbol有resnet等等的get_symbol，这个特征提完后，加全连接层，分别有softmax等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def get_symbol(args):</span><br><span class="line">  embedding = eval(config.net_name).get_symbol()</span><br><span class="line">  all_label = mx.symbol.Variable(&apos;softmax_label&apos;)</span><br><span class="line">  gt_label = all_label</span><br><span class="line">  is_softmax = True</span><br><span class="line">  if config.loss_name==&apos;softmax&apos;: #softmax</span><br><span class="line">    _weight = mx.symbol.Variable(&quot;fc7_weight&quot;, shape=(config.num_classes, config.emb_size), </span><br><span class="line">        lr_mult=config.fc7_lr_mult, wd_mult=config.fc7_wd_mult, init=mx.init.Normal(0.01))</span><br><span class="line">    if config.fc7_no_bias:</span><br><span class="line">      fc7 = mx.sym.FullyConnected(data=embedding, weight = _weight, no_bias = True, num_hidden=config.num_classes, name=&apos;fc7&apos;)</span><br><span class="line">    else:</span><br><span class="line">      _bias = mx.symbol.Variable(&apos;fc7_bias&apos;, lr_mult=2.0, wd_mult=0.0)</span><br><span class="line">      fc7 = mx.sym.FullyConnected(data=embedding, weight = _weight, bias = _bias, num_hidden=config.num_classes, name=&apos;fc7&apos;)</span><br></pre></td></tr></table></figure></p><p>回到train上来<br>然后计算算力，这部分时flops_counter.py在/common下，有兴趣可以看一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算消耗算力</span></span><br><span class="line"><span class="keyword">if</span> config.count_flops:</span><br><span class="line">  all_layers = sym.get_internals()</span><br><span class="line">  _sym = all_layers[<span class="string">'fc1_output'</span>]</span><br><span class="line">  FLOPs = flops_counter.count_flops(_sym, data=(<span class="number">1</span>,<span class="number">3</span>,image_size[<span class="number">0</span>],image_size[<span class="number">1</span>]))</span><br><span class="line">  _str = flops_counter.flops_str(FLOPs)</span><br><span class="line">  print(<span class="string">'Network FLOPs: %s'</span>%_str)</span><br></pre></td></tr></table></figure><p>后面创建模型<br>contex默认选择CPU，给ctxGPU序号<br>symbol给出计算的输出即可。<br>symbol: the network definition<br>context: the device (or a list of devices) to use for execution<br>data_names : the list of input data variable names<br>label_names : the list of input label variable names</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model = mx.mod.Module(</span><br><span class="line">    context       = ctx,</span><br><span class="line">    symbol        = sym,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>主要看model.fit</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">model.fit(train_dataiter,</span><br><span class="line">    begin_epoch        = begin_epoch,</span><br><span class="line">    num_epoch          = <span class="number">999999</span>,</span><br><span class="line">    eval_data          = val_dataiter,</span><br><span class="line">    eval_metric        = eval_metrics,</span><br><span class="line">    kvstore            = args.kvstore,</span><br><span class="line">    optimizer          = opt,</span><br><span class="line">    <span class="comment">#optimizer_params   = optimizer_params,</span></span><br><span class="line">    initializer        = initializer,</span><br><span class="line">    arg_params         = arg_params,</span><br><span class="line">    aux_params         = aux_params,</span><br><span class="line">    allow_missing      = <span class="literal">True</span>,</span><br><span class="line">    batch_end_callback = _batch_callback,</span><br><span class="line">    epoch_end_callback = epoch_cb )</span><br></pre></td></tr></table></figure><p>参数解释如下<br>train_data (DataIter) – Train DataIter.<br>eval_data (DataIter) – 验证集数据，每个epoch会验证一下，可以选择none<br>epoch_end_callback (function or list of functions) – 每一次epoch调用一次<br>batch_end_callback (function or list of function) – 每个batch调用一次，可以存放一些打印函数或者我们更新学习率<br>kvstore (str or KVStore) – Defaults to ‘local’.<br>optimizer (str or Optimizer) – Defaults to ‘sgd’.优化器<br>initializer (Initializer) – The initializer is called to initialize the module parameters when they are not already initialized.<br>arg_params (dict) – 初始化参数，默认没有<br>aux_params (dict) – aux参数同上<br>allow_missing (bool) – 在有预训练参数时是否允许丢失，也就是如果允许，则上面的参数万一有丢的，我们就随机初始化。<br>begin_epoch (int) – 开始的次数，从几开始计数<br>num_epoch (int) – 训练epoch</p><p>然后看到model每个epoch调用了回调函数，做了点啥呢<br>主要时当数据量达到一定就打印数据，当测试效果好的时候就保存模型。</p><h3 id="4运行"><a href="#4运行" class="headerlink" title="4运行"></a>4运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=&apos;0,1,2,3&apos; python -u train.py --network r50 --loss arcface --dataset emore</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 人脸识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> insightface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux服务器下一些操作</title>
      <link href="/posts/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
      <url>/posts/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>本文总结了最近使用linux服务器用到的一些基本操作</p><a id="more"></a><h3 id="1-链接服务器"><a href="#1-链接服务器" class="headerlink" title="1 链接服务器"></a>1 链接服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh menglingjun@hpcgpu9.ai.lycc.qihoo.net</span><br></pre></td></tr></table></figure><p>输入密码…</p><h3 id="2-创建软连接"><a href="#2-创建软连接" class="headerlink" title="2 创建软连接"></a>2 创建软连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">readlink -f ./insightface/</span><br><span class="line">产生软连接</span><br><span class="line">/data/menglingjun/insightface</span><br><span class="line">复制一下，然后到Home下</span><br><span class="line">ln -s /data/menglingjun/insightface .</span><br></pre></td></tr></table></figure><h3 id="3-查内存情况"><a href="#3-查内存情况" class="headerlink" title="3 查内存情况"></a>3 查内存情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><h3 id="4-查看文件详情"><a href="#4-查看文件详情" class="headerlink" title="4 查看文件详情"></a>4 查看文件详情</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll /</span><br><span class="line">~ home目录</span><br><span class="line">pwd显示当前工作目录绝对路径</span><br></pre></td></tr></table></figure><h3 id="5-查看GPU情况"><a href="#5-查看GPU情况" class="headerlink" title="5 查看GPU情况"></a>5 查看GPU情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><h3 id="6-安装PIP包到个人用户下"><a href="#6-安装PIP包到个人用户下" class="headerlink" title="6 安装PIP包到个人用户下"></a>6 安装PIP包到个人用户下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install packget --user</span><br></pre></td></tr></table></figure><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip --default-timeout=100 install -U packget</span><br></pre></td></tr></table></figure><h3 id="8-查看本机IP"><a href="#8-查看本机IP" class="headerlink" title="8 查看本机IP"></a>8 查看本机IP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">ls -lht查看当前文件夹下文件信息</span><br></pre></td></tr></table></figure><h3 id="9-windows把文件传到linux下"><a href="#9-windows把文件传到linux下" class="headerlink" title="9 windows把文件传到linux下"></a>9 windows把文件传到linux下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scp -rp menglingjun@10.173.226.203:/home/menglingjun/insightface/insightface-master/datasets/lfw2/Micky_Arison/Micky_Arison_0001.jpg d:/a</span><br><span class="line">scp /d:/1.txt menglingjun@10.160.167.27:/home/menglingjun/a</span><br><span class="line">scp -r /d:/a menglingjun@10.160.167.27:/home/menglingjun/a#拷贝整个目录</span><br><span class="line">scp /d:/im2rec.py menglingjun@10.173.226.203:/home/menglingjun/insightface/insightface-master/src/data/</span><br><span class="line">scp menglingjun@10.173.226.203 :/home/menglingjun/a/d:/1.txt  /d:/a</span><br><span class="line"></span><br><span class="line">scp /d:/generate_image_pairs.py menglingjun@10.173.226.203:/home/menglingjun/insightface/insightface-master/src/data/</span><br></pre></td></tr></table></figure><h3 id="10-删除文件夹"><a href="#10-删除文件夹" class="headerlink" title="10 删除文件夹"></a>10 删除文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf //</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>insightface测试recognition验证集效果全过程</title>
      <link href="/posts/insightface%E6%B5%8B%E8%AF%95recognition%E9%AA%8C%E8%AF%81%E9%9B%86%E6%95%88%E6%9E%9C%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/posts/insightface%E6%B5%8B%E8%AF%95recognition%E9%AA%8C%E8%AF%81%E9%9B%86%E6%95%88%E6%9E%9C%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>insightface测试recognition验证集效果全过程<br><a id="more"></a></p><blockquote><p>本过程在insightface代码下作实验，源代码参考<br><a href="https://github.com/deepinsight/insightface#pretrained-models">https://github.com/deepinsight/insightface#pretrained-models</a><br>实验测试recognition下的eval验证</p></blockquote><h2 id="1数据准备"><a href="#1数据准备" class="headerlink" title="1数据准备"></a>1数据准备</h2><p>数据准备参考博文：insightface数据制作全过程记录<br><a href="https://blog.csdn.net/CLOUD_J/article/details/98769515">https://blog.csdn.net/CLOUD_J/article/details/98769515</a></p><h2 id="2eval验证"><a href="#2eval验证" class="headerlink" title="2eval验证"></a>2eval验证</h2><p>在/recognition/eval下verification.py文件<br><img src="https://blogpic-1257632417.cos.ap-chengdu.myqcloud.com/BlogGit/2019/20190808181303477.png" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 verification.py --data-dir ../../datasets/lfw --model ../../models/model-r50-am-lfw/model,0 --nfolds 10</span><br></pre></td></tr></table></figure><p>运行时出现了点问题，主要在于我们之前准备数据集时没有打乱数据导致正样本挤在一起，会使这一部分数据负样本为0，我们计算正确率会用负样本识别正确比上总负样样本数，分母出现0，所以做了更改calculate_val_far函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_val_far</span><span class="params">(threshold, dist, actual_issame)</span>:</span></span><br><span class="line">    predict_issame = np.less(dist, threshold)</span><br><span class="line">    true_accept = np.sum(np.logical_and(predict_issame, actual_issame))</span><br><span class="line">    false_accept = np.sum(np.logical_and(predict_issame, np.logical_not(actual_issame)))</span><br><span class="line">    n_same = np.sum(actual_issame)</span><br><span class="line">    n_diff = np.sum(np.logical_not(actual_issame))</span><br><span class="line">    <span class="comment">#print(true_accept, false_accept)</span></span><br><span class="line">    <span class="comment">#print(n_same, n_diff)</span></span><br><span class="line">    <span class="keyword">if</span> n_same == <span class="number">0</span>:</span><br><span class="line">        val = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        val = float(true_accept) / float(n_same)</span><br><span class="line">    <span class="keyword">if</span> n_diff == <span class="number">0</span>:</span><br><span class="line">        far = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        far = float(false_accept) / float(n_diff)</span><br><span class="line">    <span class="keyword">return</span> val, far</span><br></pre></td></tr></table></figure><h2 id="3代码解析"><a href="#3代码解析" class="headerlink" title="3代码解析"></a>3代码解析</h2><h3 id="3-1主函数"><a href="#3-1主函数" class="headerlink" title="3.1主函数"></a>3.1主函数</h3><p>主函数首先做了模型载入，数据载入bin文件，然后对载入的模型分别做测试，检测各个模型数据效果。<br>核心在这里，遍历ver_list不同数据集，遍历nets不同模型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.mode==<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ver_list)):</span><br><span class="line">      results = []</span><br><span class="line">      <span class="keyword">for</span> model <span class="keyword">in</span> nets:</span><br><span class="line">        acc1, std1, acc2, std2, xnorm, embeddings_list = test(ver_list[i], model, args.batch_size, args.nfolds)</span><br><span class="line">        print(<span class="string">'[%s]XNorm: %f'</span> % (ver_name_list[i], xnorm))</span><br><span class="line">        print(<span class="string">'[%s]Accuracy: %1.5f+-%1.5f'</span> % (ver_name_list[i], acc1, std1))</span><br><span class="line">        print(<span class="string">'[%s]Accuracy-Flip: %1.5f+-%1.5f'</span> % (ver_name_list[i], acc2, std2))</span><br><span class="line">        results.append(acc2)</span><br><span class="line">      print(<span class="string">'Max of [%s] is %1.5f'</span> % (ver_name_list[i], np.max(results)))</span><br><span class="line">  <span class="keyword">elif</span> args.mode==<span class="number">1</span>:</span><br><span class="line">    model = nets[<span class="number">0</span>]</span><br><span class="line">    test_badcase(ver_list[<span class="number">0</span>], model, args.batch_size, args.target)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    model = nets[<span class="number">0</span>]</span><br><span class="line">    dumpR(ver_list[<span class="number">0</span>], model, args.batch_size, args.target)</span><br></pre></td></tr></table></figure><br>然后再提示几点，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--model<span class="string">', default='</span>../../models/model-r50-am-lfw/model,<span class="number">50</span></span><br></pre></td></tr></table></figure><br>该参数代表模型路径的名字加上训练的epoch，../../models/model-r50-am-lfw是路径，然后model是名字；<br>后面的50是epoch就是你可能在训练时会把多个epoch的结果输出，你可能验证不同epoch当时模型参数的效果。<br><img src="https://blogpic-1257632417.cos.ap-chengdu.myqcloud.com/BlogGit/2019/20190808182339708.png" alt="在这里插入图片描述"></p><h3 id="3-2-test函数"><a href="#3-2-test函数" class="headerlink" title="3.2 test函数"></a>3.2 test函数</h3><p>测试函数<br>首先前向传播得到输出特征，然后计算它的范数，之后计算他的准确率</p><p>前向传播主要在这！这里对你的多个数据集遍历，当然你要是只有一个数据集就一次楼。data数据集，ba和bb随便起的名字，然后就这样不断取batchsize进行前向传播model.forward(db, is_train=False)然后将输出存到embeddings这个东西里，最后将多个数据集都存到embeddings_list<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range( len(data_list) ):</span><br><span class="line">  data = data_list[i]</span><br><span class="line">  embeddings = <span class="literal">None</span></span><br><span class="line">  ba = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> ba&lt;data.shape[<span class="number">0</span>]:</span><br><span class="line">    bb = min(ba+batch_size, data.shape[<span class="number">0</span>])</span><br><span class="line">    count = bb-ba</span><br><span class="line">    _data = nd.slice_axis(data, axis=<span class="number">0</span>, begin=bb-batch_size, end=bb)</span><br><span class="line">    <span class="comment">#print(_data.shape, _label.shape)</span></span><br><span class="line">    time0 = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">if</span> data_extra <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      db = mx.io.DataBatch(data=(_data,), label=(_label,))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      db = mx.io.DataBatch(data=(_data,_data_extra), label=(_label,))</span><br><span class="line">    model.forward(db, is_train=<span class="literal">False</span>)</span><br><span class="line">    net_out = model.get_outputs()<span class="comment">#获取输出</span></span><br><span class="line">    _embeddings = net_out[<span class="number">0</span>].asnumpy()</span><br><span class="line">    time_now = datetime.datetime.now()</span><br><span class="line">    diff = time_now - time0</span><br><span class="line">    time_consumed+=diff.total_seconds()</span><br><span class="line">    <span class="comment">#print(_embeddings.shape)</span></span><br><span class="line">    <span class="keyword">if</span> embeddings <span class="keyword">is</span> <span class="literal">None</span>:<span class="comment">#第一次的话先创建一个列表</span></span><br><span class="line">      embeddings = np.zeros( (data.shape[<span class="number">0</span>], _embeddings.shape[<span class="number">1</span>]) )</span><br><span class="line">    embeddings[ba:bb,:] = _embeddings[(batch_size-count):,:]<span class="comment">#补进去</span></span><br><span class="line">    ba = bb</span><br><span class="line">  embeddings_list.append(embeddings)</span><br></pre></td></tr></table></figure></p><p>第二步，做了个范数计算<br>计算一下特征的总平均范数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_xnorm = <span class="number">0.0</span></span><br><span class="line">_xnorm_cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> embed <span class="keyword">in</span> embeddings_list:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(embed.shape[<span class="number">0</span>]):</span><br><span class="line">    _em = embed[i]</span><br><span class="line">    _norm=np.linalg.norm(_em)</span><br><span class="line">    <span class="comment">#print(_em.shape, _norm)</span></span><br><span class="line">    _xnorm+=_norm</span><br><span class="line">    _xnorm_cnt+=<span class="number">1</span></span><br><span class="line">_xnorm /= _xnorm_cnt</span><br></pre></td></tr></table></figure><br>第三步 计算准确率<br>这里传入特征列表和标签列表还有nrof_folds，啥意思，这个是做K折检测的，分K份检测。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_, _, accuracy, val, val_std, far = evaluate(embeddings, issame_list, nrof_folds=nfolds)</span><br><span class="line">acc2, std2 = np.mean(accuracy), np.std(accuracy)</span><br></pre></td></tr></table></figure><br>这里有一点注意，文中有个  embeddings = embeddings_list[0] + embeddings_list[1]我理解把两个数据集组合验证。</p><h3 id="3-3evaluate评估函数"><a href="#3-3evaluate评估函数" class="headerlink" title="3.3evaluate评估函数"></a>3.3evaluate评估函数</h3><p>首先先将数据集分了两块，就是原来是这样<br>A1 A2 A3  A4   B1  B2<br>这样A1和A2对比同类1<br>改成这样<br>A1 A3 B1奇数放一起<br>A2 A4 B2偶数放一起</p><blockquote><p>python中a::b代表从a开始以b单位增长</p></blockquote><p>这里还搞了个thresholds作为阈值，会在评估函数里遍历寻找最好的阈值。<br>完事做了两个评估<br>calculate_roc<br>calculate_val</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(embeddings, actual_issame, nrof_folds=<span class="number">10</span>, pca = <span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="comment"># Calculate evaluation metrics</span></span><br><span class="line">    thresholds = np.arange(<span class="number">0</span>, <span class="number">4</span>, <span class="number">0.01</span>)</span><br><span class="line">    embeddings1 = embeddings[<span class="number">0</span>::<span class="number">2</span>]</span><br><span class="line">    embeddings2 = embeddings[<span class="number">1</span>::<span class="number">2</span>]</span><br><span class="line">    tpr, fpr, accuracy = calculate_roc(thresholds, embeddings1, embeddings2,</span><br><span class="line">        np.asarray(actual_issame), nrof_folds=nrof_folds, pca = pca)</span><br><span class="line">    thresholds = np.arange(<span class="number">0</span>, <span class="number">4</span>, <span class="number">0.001</span>)</span><br><span class="line">    val, val_std, far = calculate_val(thresholds, embeddings1, embeddings2,</span><br><span class="line">        np.asarray(actual_issame), <span class="number">1e-3</span>, nrof_folds=nrof_folds)</span><br><span class="line">    <span class="keyword">return</span> tpr, fpr, accuracy, val, val_std, far</span><br></pre></td></tr></table></figure><h2 id="3-4-calculate-roc"><a href="#3-4-calculate-roc" class="headerlink" title="3.4 calculate_roc"></a>3.4 calculate_roc</h2><p>第一步 先生命一个K折数据类<br>1、这里assert是断言的意思，就是说后面那句话不对就直接报错；<br>2、LFold在前面有声明类，就是调用kfold这个包<br>3、<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(embeddings1.shape[<span class="number">0</span>] == embeddings2.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">assert</span>(embeddings1.shape[<span class="number">1</span>] == embeddings2.shape[<span class="number">1</span>])</span><br><span class="line">    nrof_pairs = min(len(actual_issame), embeddings1.shape[<span class="number">0</span>])</span><br><span class="line">    nrof_thresholds = len(thresholds)</span><br><span class="line">    k_fold = LFold(n_splits=nrof_folds, shuffle=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    tprs = np.zeros((nrof_folds,nrof_thresholds))</span><br><span class="line">    fprs = np.zeros((nrof_folds,nrof_thresholds))</span><br><span class="line">    accuracy = np.zeros((nrof_folds))</span><br><span class="line">    indices = np.arange(nrof_pairs)</span><br></pre></td></tr></table></figure></p><p>第二步，求了下范数距离欧式距离</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pca==<span class="number">0</span>:</span><br><span class="line">  diff = np.subtract(embeddings1, embeddings2)<span class="comment">#做减法</span></span><br><span class="line">  dist = np.sum(np.square(diff),<span class="number">1</span>)<span class="comment">#求平方和</span></span><br></pre></td></tr></table></figure><p>第三步 遍历thresholds寻找最好的阈值。<br>k_fold.split(indices)是分数据函数，用训练集取找好的阈值，用测试机打分。tprs暂时没用，关注accuracy准确率<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> fold_idx, (train_set, test_set) <span class="keyword">in</span> enumerate(k_fold.split(indices)):</span><br><span class="line">        <span class="comment">#print('train_set', train_set)</span></span><br><span class="line">        <span class="comment">#print('test_set', test_set)</span></span><br><span class="line">        <span class="keyword">if</span> pca&gt;<span class="number">0</span>:</span><br><span class="line">          print(<span class="string">'doing pca on'</span>, fold_idx)</span><br><span class="line">          embed1_train = embeddings1[train_set]</span><br><span class="line">          embed2_train = embeddings2[train_set]</span><br><span class="line">          _embed_train = np.concatenate( (embed1_train, embed2_train), axis=<span class="number">0</span> )</span><br><span class="line">          <span class="comment">#print(_embed_train.shape)</span></span><br><span class="line">          pca_model = PCA(n_components=pca)</span><br><span class="line">          pca_model.fit(_embed_train)</span><br><span class="line">          embed1 = pca_model.transform(embeddings1)</span><br><span class="line">          embed2 = pca_model.transform(embeddings2)</span><br><span class="line">          embed1 = sklearn.preprocessing.normalize(embed1)</span><br><span class="line">          embed2 = sklearn.preprocessing.normalize(embed2)</span><br><span class="line">          <span class="comment">#print(embed1.shape, embed2.shape)</span></span><br><span class="line">          diff = np.subtract(embed1, embed2)</span><br><span class="line">          dist = np.sum(np.square(diff),<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Find the best threshold for the fold</span></span><br><span class="line">        acc_train = np.zeros((nrof_thresholds))</span><br><span class="line">        <span class="keyword">for</span> threshold_idx, threshold <span class="keyword">in</span> enumerate(thresholds):<span class="comment">#遍历找最好阈值</span></span><br><span class="line">            _, _, acc_train[threshold_idx] = calculate_accuracy(threshold, dist[train_set], actual_issame[train_set])</span><br><span class="line">        best_threshold_index = np.argmax(acc_train)</span><br><span class="line">        <span class="comment">#print('threshold', thresholds[best_threshold_index])</span></span><br><span class="line">        <span class="keyword">for</span> threshold_idx, threshold <span class="keyword">in</span> enumerate(thresholds):</span><br><span class="line">            tprs[fold_idx,threshold_idx], fprs[fold_idx,threshold_idx], _ = calculate_accuracy(threshold, dist[test_set], actual_issame[test_set])</span><br><span class="line">        _, _, accuracy[fold_idx] = calculate_accuracy(thresholds[best_threshold_index], dist[test_set], actual_issame[test_set])</span><br></pre></td></tr></table></figure></p><h3 id="3-5-准确率计算"><a href="#3-5-准确率计算" class="headerlink" title="3.5 准确率计算"></a>3.5 准确率计算</h3><p>核心函数在这，我们的改动也在这里。</p><p>说几个注意</p><blockquote><p>np.less求最小值，求每个值与阈值相比，如果比阈值小则真。<br>np.logical_and代表逻辑与的意思，就是两个numpy进行与，把预测和真实进行与一下得到tp，就是预测正确的正样本truepositive。<br>np.logical_not(actual_issame)代表取反，给真是样本取反，<br>fp = np.sum(np.logical_and(predict_issame, np.logical_not(actual_issame)))这样代表预测和真实样本取反的与就是错误预测的正样本。<br>tn，fn一样。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_accuracy</span><span class="params">(threshold, dist, actual_issame)</span>:</span></span><br><span class="line">    predict_issame = np.less(dist, threshold)</span><br><span class="line">    tp = np.sum(np.logical_and(predict_issame, actual_issame))</span><br><span class="line">    fp = np.sum(np.logical_and(predict_issame, np.logical_not(actual_issame)))</span><br><span class="line">    tn = np.sum(np.logical_and(np.logical_not(predict_issame), np.logical_not(actual_issame)))</span><br><span class="line">    fn = np.sum(np.logical_and(np.logical_not(predict_issame), actual_issame))</span><br><span class="line">  </span><br><span class="line">    tpr = <span class="number">0</span> <span class="keyword">if</span> (tp+fn==<span class="number">0</span>) <span class="keyword">else</span> float(tp) / float(tp+fn)</span><br><span class="line">    fpr = <span class="number">0</span> <span class="keyword">if</span> (fp+tn==<span class="number">0</span>) <span class="keyword">else</span> float(fp) / float(fp+tn)</span><br><span class="line">    acc = float(tp+tn)/dist.size</span><br><span class="line">    <span class="keyword">return</span> tpr, fpr, acc</span><br></pre></td></tr></table></figure><p>最后结果如下<br>Accuracy没有，我们只有一个数据集，这里我理解的是Acuuracy是单个数据集准确率，Accuracy-Flip和其他数据集混在一起，这里就看0.99675即可。<br><img src="https://blogpic-1257632417.cos.ap-chengdu.myqcloud.com/BlogGit/2019/2019080914404384.png" alt="在这里插入图片描述"></p><p>前面阈值打印出来是1.39</p><p> <img src="https://blogpic-1257632417.cos.ap-chengdu.myqcloud.com/BlogGit/2019/20190809144230616.png" alt="在这里插入图片描述"></p><h2 id="4结果"><a href="#4结果" class="headerlink" title="4结果"></a>4结果</h2><div class="table-container"><table><thead><tr><th></th><th>LFW</th><th>CFP-FP</th></tr></thead><tbody><tr><td>renet-r50</td><td>99.63%(99.80%)</td><td>92.66%(92.74%)</td></tr><tr><td>renet-r100</td><td>99.81%(99.77%)</td><td>95.94%(98.27%)</td></tr></tbody></table></div><p><strong>注意：括号内为github作者的结果，括号前为我的结果。结果取batchsize=16</strong></p><p>目前对于差别有些疑问，还等待发现，如有大神能指点，还请指导。</p><h2 id="5问题"><a href="#5问题" class="headerlink" title="5问题"></a>5问题</h2><p><strong>1、内存问题</strong><br><img src="https://blogpic-1257632417.cos.ap-chengdu.myqcloud.com/BlogGit/2019/20190813153114557.png" alt="在这里插入图片描述"><br>考虑减小batchsize<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 verification.py --data-dir ../../datasets/lfw2/ --model ../../models/model-r100-ii/model,<span class="number">0</span> --nfolds <span class="number">10</span> --batch-size <span class="number">16</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 人脸识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> insightface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>insightface数据制作全过程记录</title>
      <link href="/posts/insightface%E6%95%B0%E6%8D%AE%E5%88%B6%E4%BD%9C%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
      <url>/posts/insightface%E6%95%B0%E6%8D%AE%E5%88%B6%E4%BD%9C%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>insightface数据制作全过程记录</strong><br><a id="more"></a><br>测试insightface时发现需要调整数据，<br>insigtface/datasets属于存放数据的目录，insightface/src/data中存放了数据处理的一些代码，包括rec文件生成。</p><h2 id="1数据对齐"><a href="#1数据对齐" class="headerlink" title="1数据对齐"></a>1数据对齐</h2><p>我们用lfw数据做实验，你也可以自己找数据。</p><blockquote><p>lfw数据<br><a href="http://vis-www.cs.umass.edu/lfw/">http://vis-www.cs.umass.edu/lfw/</a><br>我下载的是这个原图像<a href="https://drive.google.com/file/d/1p1wjaqpTh_5RHfJu4vUh8JJCdKwYMHCp/view?usp=sharing">https://drive.google.com/file/d/1p1wjaqpTh_5RHfJu4vUh8JJCdKwYMHCp/view?usp=sharing</a></p></blockquote><p>datasets/lfwdata下存放数据<br>lfwdata下分目录存放每一类的数据，每个人一个文件夹，里面存图。<br>在src/align里提供了人脸对齐的代码，检测加对齐<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 align_lfw.py --input-dir ../../datasets/lfwdata --output-dir ../../datasets/lfw2</span><br></pre></td></tr></table></figure><br><strong>注意：这里cfp-fp数据集的对齐和lfw不一样，原因在于目录层级不一样，cfp-fp数据目录下每个person还分正脸侧脸，所以在遍历时不太一致，我们又写了align_cfp.py文件。</strong><br>这里我们复制一份align_lfw.py到align_cfp.py。然后改main函数里<br>1、数据路径遍历方式变为ytf，这个你去看face_image有定义<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataset = face_image.get_dataset(<span class="string">'ytf'</span>, args.input_dir)</span><br><span class="line">print(<span class="string">'dataset size'</span>, <span class="string">'lfw'</span>, len(dataset))</span><br></pre></td></tr></table></figure><br>2、113行改一下生成新的路径存储图片这里<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = img[:,:,<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">_paths = fimage.image_path.split(<span class="string">'/'</span>)</span><br><span class="line">a,b,c = _paths[<span class="number">-3</span>], _paths[<span class="number">-2</span>],_paths[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><h3 id="2生成list文件"><a href="#2生成list文件" class="headerlink" title="2生成list文件"></a>2生成list文件</h3><p>这里insightface提供的face2rec2不能生成list，所以我们找了个程序<strong>稍后上传</strong>，用im2rec.py，这个程序也是生成rec的，我们加上参数—list 就生成lst文件 —recursive代表遍历文件下所有目录。<br>../../datasets/lfw/lfw输出目录最后lfw代表list的名字，不用加后缀。<br>../../datasets/lfw2图片目录<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 im2rec.py --list --recursive ../../datasets/lfw/train ../../datasets/lfw2</span><br></pre></td></tr></table></figure></p><h3 id="3生成rec-amp-idx-文件（依托于list）"><a href="#3生成rec-amp-idx-文件（依托于list）" class="headerlink" title="3生成rec  &amp;idx 文件（依托于list）"></a>3生成rec  &amp;idx 文件（依托于list）</h3><p>生成rec文件，把—list去掉<br>../../datasets/lfw/train.lst代表lst的目录<br>../../datasets/lfw2原图存在的目录<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 im2rec.py ../../datasets/lfw/train.lst ../../datasets/lfw2</span><br></pre></td></tr></table></figure></p><h3 id="4创建property配置文件"><a href="#4创建property配置文件" class="headerlink" title="4创建property配置文件"></a>4创建property配置文件</h3><p>直接创建一个名为property的文件，没有后缀<br>写1000,112,112代表ID数量,尺寸,尺寸</p><p><strong>目前datasets/lfw/目录下存在lfw.lst   lfw.rec  lfw.idx</strong></p><h3 id="5-创建pair文件"><a href="#5-创建pair文件" class="headerlink" title="5 创建pair文件"></a>5 创建pair文件</h3><p>为了做测试我们需要生成验证集用的bin文件，bin文件生成前需要做pair文件，就是一对一对的数据，每一行分别是<br>图A的目录 空格 图B的目录 空格 标志0/1（代表两张图类别一致否）<br><img src="https://blogpic-1257632417.cos.ap-chengdu.myqcloud.com/BlogGit/2019/20190807182610776.png" alt="在这里插入图片描述"><br>利用generate_image_pairs.py（源文件有问题，已修改）<br>稍后上传，附录有<br>../../datasets/lfw2对齐图像目录<br>../../datasets/lfw/train.txt存放txt<br>100要多少个数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 generate_image_pairs.py --data-dir ../../datasets/lfw2 --outputtxt ../../datasets/lfw/train.txt --num-samepairs <span class="number">100</span></span><br></pre></td></tr></table></figure><p><strong>注意：这里生成pairs的方法不太好，数据集给了一些标准的pairs文件，我们可以写一个脚本取解读，具体如下：</strong></p><blockquote><p>lfw在insightface里面有pair.txt<br>cfp没有，只有一组FP对，需要我们自己写个脚本，这里我写好了上传来。我们依然放到src/data下cfp_make_bin.py<br>cfp给了这个目录有一组对<br><img src="https://blogpic-1257632417.cos.ap-chengdu.myqcloud.com/BlogGit/2019/20190813113439176.png" alt="在这里插入图片描述"></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import mxnet as mx</span><br><span class="line">from mxnet import ndarray as nd</span><br><span class="line">import argparse</span><br><span class="line">import pickle</span><br><span class="line">import sys</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=&apos;Package LFW images&apos;)</span><br><span class="line"># general</span><br><span class="line">parser.add_argument(&apos;--data-dir&apos;, default=&apos;&apos;, help=&apos;&apos;)</span><br><span class="line">parser.add_argument(&apos;--image-size&apos;, type=str, default=&apos;112,112&apos;, help=&apos;&apos;)</span><br><span class="line">parser.add_argument(&apos;--output&apos;, default=&apos;&apos;, help=&apos;path to save.&apos;)</span><br><span class="line">parser.add_argument(&apos;--num-samepairs&apos;,default=100)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">data_dir = args.data_dir</span><br><span class="line">image_size = [int(x) for x in args.image_size.split(&apos;,&apos;)]</span><br><span class="line">pairs_end = []</span><br><span class="line">def get_paths():</span><br><span class="line">    pairs = []</span><br><span class="line">    prefix = os.path.join(data_dir,&apos;Protocol/&apos;)</span><br><span class="line"></span><br><span class="line">    #prefix = &quot;/Split/&quot;</span><br><span class="line">    prefix_F = os.path.join(prefix, &quot;Pair_list_F.txt&quot;)</span><br><span class="line">    pairs_F = []</span><br><span class="line">    prefix_P = os.path.join(prefix,&quot;Pair_list_P.txt&quot;)</span><br><span class="line">    pairs_P = []</span><br><span class="line">    pairs_end = []</span><br><span class="line">    issame_list = []</span><br><span class="line">    #读pairlist文件</span><br><span class="line">    with open(prefix_F, &apos;r&apos;) as f:</span><br><span class="line">        for line in f.readlines()[0:]:</span><br><span class="line">            pair = line.strip().split()</span><br><span class="line">            pairs_F.append(pair[1])</span><br><span class="line">    print(len(pairs_F))</span><br><span class="line">    with open(prefix_P, &apos;r&apos;) as f:</span><br><span class="line">        for line in f.readlines()[0:]:</span><br><span class="line">            pair = line.strip().split()</span><br><span class="line">            pairs_P.append(pair[1])</span><br><span class="line">    print(len(pairs_P))</span><br><span class="line"></span><br><span class="line">    #读pair文件</span><br><span class="line">    prefix = os.path.join(data_dir,&quot;Protocol/Split/FP&quot;)</span><br><span class="line">    folders_1 = os.listdir(prefix)</span><br><span class="line">    for folder in folders_1:</span><br><span class="line">        sublist = []</span><br><span class="line">        same_list = []</span><br><span class="line">        pairtxt = os.listdir(os.path.join(prefix, folder))</span><br><span class="line">        for pair in pairtxt:</span><br><span class="line">            img_root_path = os.path.join(prefix, folder, pair)</span><br><span class="line">            with open(img_root_path, &apos;r&apos;) as f:</span><br><span class="line">                for line in f.readlines()[0:]:</span><br><span class="line">                    #print(line)</span><br><span class="line">                    pair1 = line.strip().split(&apos;,&apos;)</span><br><span class="line">                    #print(pair)</span><br><span class="line">                    pairs_end += (os.path.join(data_dir,&apos;Protocol/&apos;,pairs_F[int(pair1[0])-1]),os.path.join(data_dir,&apos;Protocol/&apos;,pairs_P[int(pair1[1])-1]))</span><br><span class="line">                    #print(pair)</span><br><span class="line">                    if pair == &apos;same.txt&apos;:</span><br><span class="line">                        #print(&apos;ok!&apos;)</span><br><span class="line">                        issame_list.append(True)</span><br><span class="line">                    else:</span><br><span class="line">                        issame_list.append(False)</span><br><span class="line">    return pairs_end,issame_list</span><br></pre></td></tr></table></figure><h3 id="6-生成验证集bin文件"><a href="#6-生成验证集bin文件" class="headerlink" title="6 生成验证集bin文件"></a>6 生成验证集bin文件</h3><p>完事后利用/src/data/下的 lfw2pack.py生成bin文件<br>但是有点问题，需要修改下，参考这篇博客<a href="https://blog.csdn.net/hanjiangxue_wei/article/details/86566348">https://blog.csdn.net/hanjiangxue_wei/article/details/86566348</a><br>修改lfw2pack.py中19行，打#的为更改的，改为两个参数，一个是txt读出来的列表，另一个是总数量。<br><strong>注意：cfp跳过就可以了</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import mxnet as mx</span><br><span class="line">from mxnet import ndarray as nd</span><br><span class="line">import argparse</span><br><span class="line">import pickle</span><br><span class="line">import sys</span><br><span class="line">import os</span><br><span class="line">sys.path.append(os.path.join(os.path.dirname(__file__), &apos;..&apos;, &apos;eval&apos;))</span><br><span class="line">import lfw</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=&apos;Package LFW images&apos;)</span><br><span class="line"># general</span><br><span class="line">parser.add_argument(&apos;--data-dir&apos;, default=&apos;&apos;, help=&apos;&apos;)</span><br><span class="line">parser.add_argument(&apos;--image-size&apos;, type=str, default=&apos;112,112&apos;, help=&apos;&apos;)</span><br><span class="line">parser.add_argument(&apos;--output&apos;, default=&apos;&apos;, help=&apos;path to save.&apos;)</span><br><span class="line">parser.add_argument(&apos;--num-samepairs&apos;,default=100)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">lfw_dir = args.data_dir</span><br><span class="line">image_size = [int(x) for x in args.image_size.split(&apos;,&apos;)]</span><br><span class="line">lfw_pairs = lfw.read_pairs(os.path.join(lfw_dir, &apos;train.txt&apos;))</span><br><span class="line">print(lfw_pairs)</span><br><span class="line">lfw_paths, issame_list = lfw.get_paths(lfw_pairs,int(args.num_samepairs)+1)#, &apos;jpg&apos;)</span><br><span class="line">lfw_bins = []</span><br><span class="line">#lfw_data = nd.empty((len(lfw_paths), 3, image_size[0], image_size[1]))</span><br><span class="line">print(len(issame_list))</span><br><span class="line">i = 0</span><br><span class="line">for path in lfw_paths:</span><br><span class="line">  with open(path, &apos;rb&apos;) as fin:</span><br><span class="line">    _bin = fin.read()</span><br><span class="line">    lfw_bins.append(_bin)</span><br><span class="line">    #img = mx.image.imdecode(_bin)</span><br><span class="line">    #img = nd.transpose(img, axes=(2, 0, 1))</span><br><span class="line">    #lfw_data[i][:] = img</span><br><span class="line">    i+=1</span><br><span class="line">    if i%1000==0:</span><br><span class="line">      print(&apos;loading lfw&apos;, i)</span><br><span class="line"></span><br><span class="line">with open(args.output, &apos;wb&apos;) as f:</span><br><span class="line">  pickle.dump((lfw_bins, issame_list), f, protocol=pickle.HIGHEST_PROTOCOL)</span><br></pre></td></tr></table></figure><br>对应的get_paths这个文件存在src\eval\lfw.py下，把他也改了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def get_paths(pairs, same_pairs):</span><br><span class="line">    nrof_skipped_pairs = 0</span><br><span class="line">    path_list = []</span><br><span class="line">    issame_list = []</span><br><span class="line">    cnt = 1</span><br><span class="line">    for pair in pairs:</span><br><span class="line">      path0 = pair[0]</span><br><span class="line">      path1 = pair[1]</span><br><span class="line"></span><br><span class="line">      if cnt &lt; same_pairs:</span><br><span class="line">        issame = True</span><br><span class="line">      else:</span><br><span class="line">        issame = False </span><br><span class="line">      if os.path.exists(path0) and os.path.exists(path1):    # Only add the pair if both paths exist</span><br><span class="line">        path_list += (path0,path1)</span><br><span class="line">        issame_list.append(issame)</span><br><span class="line">      else:</span><br><span class="line">        print(&apos;not exists&apos;, path0, path1)</span><br><span class="line">        nrof_skipped_pairs += 1</span><br><span class="line">      cnt += 1</span><br><span class="line">    if nrof_skipped_pairs&gt;0:</span><br><span class="line">        print(&apos;Skipped %d image pairs&apos; % nrof_skipped_pairs)</span><br><span class="line">    return path_list, issame_list</span><br></pre></td></tr></table></figure><br>之后再运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 lfw2pack.py --data-dir ../../datasets/lfw --output ../../datasets/lfw/lfw.bin --num-samepairs 300</span><br></pre></td></tr></table></figure></p><p>附录<br>generate_image_pairs.py、</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment">#src = '../../datasets/lfw2'</span></span><br><span class="line"><span class="comment">#dst = open('../../datasets/lfw/train.txt', 'a')</span></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'generate image pairs'</span>)</span><br><span class="line"><span class="comment"># general</span></span><br><span class="line">parser.add_argument(<span class="string">'--data-dir'</span>, default=<span class="string">''</span>, help=<span class="string">''</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--outputtxt'</span>, default=<span class="string">''</span>, help=<span class="string">'path to save.'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--num-samepairs'</span>,default=<span class="number">100</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">same_list = []</span><br><span class="line">diff_list = []</span><br><span class="line">list1 = []</span><br><span class="line">list2 = []</span><br><span class="line">folders_1 = os.listdir(args.data_dir)</span><br><span class="line">dst = open(args.outputtxt, <span class="string">'a'</span>)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">dst.writelines(<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment"># 产生相同的图像对</span></span><br><span class="line"><span class="keyword">for</span> folder <span class="keyword">in</span> folders_1:</span><br><span class="line">    sublist = []</span><br><span class="line">    same_list = []</span><br><span class="line">    imgs = os.listdir(os.path.join(args.data_dir, folder))</span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> imgs:</span><br><span class="line">        img_root_path = os.path.join(args.data_dir, folder, img)</span><br><span class="line">        sublist.append(img_root_path)</span><br><span class="line">        list1.append(img_root_path)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> itertools.combinations(sublist, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> item:</span><br><span class="line">            same_list.append(name)</span><br><span class="line">    <span class="keyword">if</span> len(same_list) &gt; <span class="number">10</span> <span class="keyword">and</span> len(same_list) &lt; <span class="number">13</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(same_list), <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> count &lt; int(args.num_samepairs):<span class="comment">#数量可以修改</span></span><br><span class="line">                    dst.writelines(same_list[j] + <span class="string">' '</span> + same_list[j+<span class="number">1</span>]+ <span class="string">' '</span> + <span class="string">'1'</span> + <span class="string">'\n'</span>)</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count &gt;= int(args.num_samepairs):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">list2 = list1.copy()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生不同的图像对</span></span><br><span class="line">diff = <span class="number">0</span></span><br><span class="line">print(count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不同的图像对远远小于相同的图像对，则继续重复产生，直到两者相差很小</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    random.seed(time.time() * <span class="number">100000</span> % <span class="number">10000</span>)</span><br><span class="line">    random.shuffle(list2)</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> range(<span class="number">0</span>, len(list2) - <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> list2[p] != list2[p + <span class="number">1</span>]:</span><br><span class="line">            dst.writelines(list2[p] + <span class="string">' '</span> + list2[p + <span class="number">1</span>] + <span class="string">' '</span> + <span class="string">'0'</span>+ <span class="string">'\n'</span>)</span><br><span class="line">            diff += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> diff &gt;= count:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment">#print(diff)</span></span><br><span class="line">    <span class="keyword">if</span> diff &lt; count:</span><br><span class="line">        <span class="comment">#print('--')</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>有问题请留言，最近一两周在做这个可以更新帖子及问题</p><hr><p>Next：<br>insightface测试验证集效果全过程<br><a href="https://blog.csdn.net/CLOUD_J/article/details/98882718">https://blog.csdn.net/CLOUD_J/article/details/98882718</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 人脸识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> insightface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WGAN代码解读及实验总结</title>
      <link href="/posts/WGAN%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%8F%8A%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
      <url>/posts/WGAN%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%8F%8A%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>GAN作为图像的另一个新领域，本成为21世纪最好的idea。嘿嘿，最近小试牛刀，下载了个WGAN的代码，这里简单分析下，给大家一个参考。</p><p><strong>【提示】<br>本文预计阅读时间5分钟，带灰色底纹的和加粗的为重要部分哦！</strong><br><a id="more"></a></p><h2 id="（一）WGAN初识"><a href="#（一）WGAN初识" class="headerlink" title="（一）WGAN初识"></a>（一）WGAN初识</h2><p><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g4kf9xy7ubj20we0az40o.jpg" alt="在这里插入图片描述"></p><p><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g4kfa25crsj20o50ayacf.jpg" alt="在这里插入图片描述"></p><p><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g4kfa59t5kj20n20dj42e.jpg" alt="在这里插入图片描述"></p><h2 id="（二）代码分析"><a href="#（二）代码分析" class="headerlink" title="（二）代码分析"></a>（二）代码分析</h2><h3 id="2-1-main-struct"><a href="#2-1-main-struct" class="headerlink" title="2.1 main struct"></a>2.1 main struct</h3><p>打开代码后，它的主要结构如下图所示。<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g4kfappsw0j20eq09wadm.jpg" alt="在这里插入图片描述"><br>我们先看一下wgan_conv主函数，打开之后首先直接到最底main的位置，如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">'CUDA_VISIBLE_DEVICES'</span>] = <span class="string">'0'</span></span><br><span class="line"><span class="comment"># the dir of pic generated</span></span><br><span class="line">sample_folder = <span class="string">'Samples/mnist_wgan_conv'</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(sample_folder):</span><br><span class="line">os.makedirs(sample_folder)</span><br><span class="line"></span><br><span class="line"><span class="comment"># net param</span></span><br><span class="line">generator = G_conv_mnist()</span><br><span class="line">discriminator = D_conv_mnist()</span><br><span class="line"><span class="comment"># data param</span></span><br><span class="line">data = mnist()</span><br><span class="line"></span><br><span class="line"><span class="comment"># run</span></span><br><span class="line">wgan = WGAN(generator, discriminator, data)</span><br><span class="line">wgan.train(sample_folder)</span><br></pre></td></tr></table></figure><br>这里做几点阐述</p><blockquote><p>1、首先创建了一个目录用来存储你的生成图像，程序会每隔一段时间输出一个图像。<br>2、搞了三个类，一个generater生成器网络，一个是discriminator判别器类，然后是数据类。<br>3、又声明一个对象WGAN网络，然后调用它的train函数</p></blockquote><p>OK至此，主函数结构阐述清楚。那此时你会想generater咋定义？discriminator咋定义？<br>好一个一个看。</p><h3 id="2-2-generator"><a href="#2-2-generator" class="headerlink" title="2.2 generator"></a>2.2 generator</h3><p>generator是生成器网络，其实就是搭了一个上采样的网络，先将噪声输入一维向量，通过全连接到更多的数据，然后把它展开成二维的图像，这里我们先用的灰度，你也可以改成彩色。然后再上采样，随意搞得，反正最后你要上采样到和你的正样本图像维度一致。如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G_conv_mnist</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.name = <span class="string">'G_conv_mnist'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, z)</span>:</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(self.name) <span class="keyword">as</span> scope:</span><br><span class="line"><span class="comment">#step 1 全连接层，把z白噪声变为8*15*128图</span></span><br><span class="line">g = tcl.fully_connected(z, <span class="number">8</span>*<span class="number">15</span>*<span class="number">128</span>, activation_fn = tf.nn.relu, normalizer_fn=tcl.batch_norm,</span><br><span class="line">weights_initializer=tf.random_normal_initializer(<span class="number">0</span>, <span class="number">0.02</span>))</span><br><span class="line">g = tf.reshape(g, (<span class="number">-1</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">128</span>)) </span><br><span class="line"><span class="comment">#step 2 反卷积/上采样 到16*30*64图    4代表卷积核大小</span></span><br><span class="line">g = tcl.conv2d_transpose(g, <span class="number">64</span>, <span class="number">4</span>,stride=<span class="number">2</span>, </span><br><span class="line">activation_fn=tf.nn.relu, normalizer_fn=tcl.batch_norm, padding=<span class="string">'SAME'</span>, weights_initializer=tf.random_normal_initializer(<span class="number">0</span>, <span class="number">0.02</span>))</span><br><span class="line"><span class="comment">#step 3 反卷积/上采样 到32*60*1的图，此时和真实手写体的数据是一样的图</span></span><br><span class="line">g = tcl.conv2d_transpose(g, <span class="number">1</span>, <span class="number">4</span>, stride=<span class="number">2</span>, </span><br><span class="line">activation_fn=tf.nn.sigmoid, padding=<span class="string">'SAME'</span>, weights_initializer=tf.random_normal_initializer(<span class="number">0</span>, <span class="number">0.02</span>))</span><br><span class="line">print(g.shape)</span><br><span class="line"><span class="keyword">return</span> g</span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vars</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope=self.name)</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：<br>这里你会看到一个call函数，它是咋用呢？<br>一个类下面有个call函数，你就可以生成一个对象后，直接把它当成方法用。例如<br>class G():<br>       <strong>call</strong>(x):<br>           print(x)<br>这样的话你就A = G()，然后再A(1)就打印了1。<br>其实就是说这个类弄好了，之后可以直接当函数用。</p></blockquote><p>好，然后我们看一下discriminator</p><h3 id="2-3-discriminator"><a href="#2-3-discriminator" class="headerlink" title="2.3 discriminator"></a>2.3 discriminator</h3><p>和generator干了差不多的事情，他要把X和GX输进去，然后搭建一个卷积网络判别真假。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D_conv_mnist</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.name = <span class="string">'D_conv_mnist'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, x, reuse=False)</span>:</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(self.name) <span class="keyword">as</span> scope:</span><br><span class="line"><span class="keyword">if</span> reuse:</span><br><span class="line">scope.reuse_variables()</span><br><span class="line">size = <span class="number">64</span></span><br><span class="line"><span class="comment">#step 1 卷积4*4卷积核 bzx30x60x1 -&gt; bzx15x30x64</span></span><br><span class="line">shared = tcl.conv2d(x, num_outputs=size, kernel_size=<span class="number">4</span>, </span><br><span class="line">stride=<span class="number">2</span>, activation_fn=lrelu)</span><br><span class="line"><span class="comment">#step 2 卷积4*4卷积核 bzx15x30x64 -&gt; bzx7x15x128</span></span><br><span class="line">shared = tcl.conv2d(shared, num_outputs=size * <span class="number">2</span>, kernel_size=<span class="number">4</span>,</span><br><span class="line">stride=<span class="number">2</span>, activation_fn=lrelu, normalizer_fn=tcl.batch_norm)</span><br><span class="line"><span class="comment">#step 3 展开向量 bzx7x15x128 -&gt; bzx6372</span></span><br><span class="line">shared = tcl.flatten(shared)</span><br><span class="line"><span class="comment">#step 4 全连接层</span></span><br><span class="line">d = tcl.fully_connected(shared, <span class="number">1</span>, activation_fn=<span class="literal">None</span>, weights_initializer=tf.random_normal_initializer(<span class="number">0</span>, <span class="number">0.02</span>))</span><br><span class="line">q = tcl.fully_connected(shared, <span class="number">128</span>, activation_fn=lrelu, normalizer_fn=tcl.batch_norm)</span><br><span class="line">q = tcl.fully_connected(q, <span class="number">10</span>, activation_fn=<span class="literal">None</span>) <span class="comment"># 10 classes</span></span><br><span class="line"><span class="keyword">return</span> d, q</span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vars</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope=self.name)</span><br></pre></td></tr></table></figure><h3 id="2-4-数据的导入改写"><a href="#2-4-数据的导入改写" class="headerlink" title="2.4 数据的导入改写"></a>2.4 数据的导入改写</h3><p>我下载的代码是直接导入的minist数据集，我们可能要导入图片数据集哈，这里我做了一些改变。<br>这里加了个next_batch函数，先生成随机序列，然后读取batch图像，存到数据集中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mnist</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, flag=<span class="string">'conv'</span>, is_tanh = False)</span>:</span></span><br><span class="line">self.datapath = prefix + <span class="string">'bus_data/'</span></span><br><span class="line">self.X_dim = <span class="number">784</span> <span class="comment"># for mlp</span></span><br><span class="line">self.z_dim = <span class="number">100</span></span><br><span class="line">self.y_dim = <span class="number">10</span></span><br><span class="line">self.sizex = <span class="number">32</span> <span class="comment"># for conv</span></span><br><span class="line">self.sizey = <span class="number">60</span> <span class="comment"># for conv</span></span><br><span class="line">self.channel = <span class="number">1</span> <span class="comment"># for conv</span></span><br><span class="line"><span class="comment">#self.data = input_data.read_data_sets(datapath, one_hot=True)</span></span><br><span class="line">self.flag = flag</span><br><span class="line">self.is_tanh = is_tanh</span><br><span class="line">self.Train_nums = <span class="number">17</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,batch_size)</span>:</span></span><br><span class="line">batch_imgs = self.next_batch(self.datapath,batch_size)</span><br><span class="line"><span class="comment">#batch_imgs,y = self.next_batch(prefix,batch_size)</span></span><br><span class="line"><span class="keyword">if</span> self.flag == <span class="string">'conv'</span>:</span><br><span class="line">batch_imgs = np.reshape(batch_imgs, (batch_size, self.sizex, self.sizey, self.channel)) </span><br><span class="line"><span class="keyword">if</span> self.is_tanh:</span><br><span class="line">batch_imgs = batch_imgs*<span class="number">2</span> - <span class="number">1</span></span><br><span class="line"><span class="comment">#return batch_imgs, y</span></span><br><span class="line"><span class="keyword">return</span> batch_imgs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_batch</span><span class="params">(self,data_path, batch_size)</span>:</span></span><br><span class="line"><span class="comment">#def next_batch(self,data_path, lable_path, batch_size):</span></span><br><span class="line">train_temp = np.random.randint(low=<span class="number">0</span>, high=self.Train_nums, size=batch_size) <span class="comment"># 生成元素的值在[low,high)区间，随机选取</span></span><br><span class="line">train_data_batch = np.zeros([batch_size,self.sizex,  self.sizey]) <span class="comment"># 其中[img_row,  img_col, 3]是原数据的shape，相应变化</span></span><br><span class="line"><span class="comment">#train_label_batch = np.zeros([batch_size, self.size, self.size]) #</span></span><br><span class="line">count = <span class="number">0</span> <span class="comment"># 后面就是读入图像，并打包成四维的batch</span></span><br><span class="line"><span class="comment">#print(data_path)</span></span><br><span class="line">img_list = os.listdir(data_path)</span><br><span class="line"><span class="comment">#print(img_list)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> train_temp:</span><br><span class="line">img_path = os.path.join(data_path, img_list[i])  <span class="comment"># 图片文件</span></span><br><span class="line">img = cv.imread(img_path)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_RGB2GRAY)</span><br><span class="line">train_data_batch[count, :, :]  = cv.resize(gray,(self.sizey,  self.sizex))</span><br><span class="line">count+=<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> train_data_batch<span class="comment">#, train_label_batch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data2fig</span><span class="params">(self, samples)</span>:</span></span><br><span class="line"><span class="keyword">if</span> self.is_tanh:</span><br><span class="line">samples = (samples + <span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">gs = gridspec.GridSpec(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">gs.update(wspace=<span class="number">0.05</span>, hspace=<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, sample <span class="keyword">in</span> enumerate(samples):</span><br><span class="line">ax = plt.subplot(gs[i])</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">ax.set_xticklabels([])</span><br><span class="line">ax.set_yticklabels([])</span><br><span class="line">ax.set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">plt.imshow(sample.reshape(self.sizex,self.sizey), cmap=<span class="string">'Greys_r'</span>)</span><br><span class="line"><span class="keyword">return</span> fig</span><br></pre></td></tr></table></figure><h3 id="2-5-WGAN网络"><a href="#2-5-WGAN网络" class="headerlink" title="2.5 WGAN网络"></a>2.5 WGAN网络</h3><p>首先是搭网络NET，discriminator分别把真实的正样本X投进去，把噪声产生的G_sample投进去，得到正负结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nets</span></span><br><span class="line">self.G_sample = self.generator(self.z)</span><br><span class="line"></span><br><span class="line">self.D_real, _ = self.discriminator(self.X)</span><br><span class="line">self.D_fake, _ = self.discriminator(self.G_sample, reuse = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>然后就是计算损失。我们利用上面结果分别计算D和G的损失，然后有两个优化器，分别对于D和G<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># loss</span></span><br><span class="line">self.D_loss = - tf.reduce_mean(self.D_real) + tf.reduce_mean(self.D_fake)</span><br><span class="line">self.G_loss = - tf.reduce_mean(self.D_fake)</span><br><span class="line"></span><br><span class="line">self.D_solver = tf.train.RMSPropOptimizer(learning_rate=<span class="number">1e-4</span>).minimize(self.D_loss, var_list=self.discriminator.vars)</span><br><span class="line">self.G_solver = tf.train.RMSPropOptimizer(learning_rate=<span class="number">1e-4</span>).minimize(self.G_loss, var_list=self.generator.vars)</span><br></pre></td></tr></table></figure><br>这里网络就搭建好了，我们要看一下train函数。其主要是先优化D再优化G这个步骤，这里我么此优化G和D的次数相同，你也可以去调整这个n_d。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(training_epoches):</span><br><span class="line"><span class="comment"># update D</span></span><br><span class="line">n_d = <span class="number">20</span> <span class="keyword">if</span> epoch &lt; <span class="number">250</span> <span class="keyword">or</span> (epoch+<span class="number">1</span>) % <span class="number">500</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n_d):</span><br><span class="line"><span class="comment">#X_b, _ = self.data(batch_size)</span></span><br><span class="line">X_b= self.data(batch_size)</span><br><span class="line">self.sess.run(self.clip_D)</span><br><span class="line">self.sess.run(</span><br><span class="line">self.D_solver,</span><br><span class="line">            feed_dict=&#123;self.X: X_b, self.z: sample_z(batch_size, self.z_dim)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment"># update G</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n_d):</span><br><span class="line"><span class="comment">#X_b, _ = self.data(batch_size)</span></span><br><span class="line">X_b= self.data(batch_size)</span><br><span class="line">self.sess.run(self.clip_D)</span><br><span class="line">self.sess.run(</span><br><span class="line">self.G_solver,</span><br><span class="line">feed_dict=&#123;self.z: sample_z(batch_size, self.z_dim)&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>对于WGAN的全部代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WGAN</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, generator, discriminator, data)</span>:</span></span><br><span class="line">self.generator = generator</span><br><span class="line">self.discriminator = discriminator</span><br><span class="line">self.data = data</span><br><span class="line"></span><br><span class="line">self.z_dim = self.data.z_dim</span><br><span class="line">self.sizex = self.data.sizex</span><br><span class="line">self.sizey = self.data.sizey</span><br><span class="line">self.channel = self.data.channel</span><br><span class="line"></span><br><span class="line">self.X = tf.placeholder(tf.float32, shape=[<span class="literal">None</span>, self.sizex, self.sizey, self.channel])</span><br><span class="line">self.z = tf.placeholder(tf.float32, shape=[<span class="literal">None</span>, self.z_dim])</span><br><span class="line"><span class="comment"># nets</span></span><br><span class="line">self.G_sample = self.generator(self.z)</span><br><span class="line"></span><br><span class="line">self.D_real, _ = self.discriminator(self.X)</span><br><span class="line">self.D_fake, _ = self.discriminator(self.G_sample, reuse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss</span></span><br><span class="line">self.D_loss = - tf.reduce_mean(self.D_real) + tf.reduce_mean(self.D_fake)</span><br><span class="line">self.G_loss = - tf.reduce_mean(self.D_fake)</span><br><span class="line"></span><br><span class="line">self.D_solver = tf.train.RMSPropOptimizer(learning_rate=<span class="number">1e-4</span>).minimize(self.D_loss, var_list=self.discriminator.vars)</span><br><span class="line">self.G_solver = tf.train.RMSPropOptimizer(learning_rate=<span class="number">1e-4</span>).minimize(self.G_loss, var_list=self.generator.vars)</span><br><span class="line"></span><br><span class="line"><span class="comment"># clip</span></span><br><span class="line">self.clip_D = [var.assign(tf.clip_by_value(var, <span class="number">-0.01</span>, <span class="number">0.01</span>)) <span class="keyword">for</span> var <span class="keyword">in</span> self.discriminator.vars]</span><br><span class="line"></span><br><span class="line">gpu_options = tf.GPUOptions(allow_growth=<span class="literal">True</span>)</span><br><span class="line">self.sess = tf.Session(config=tf.ConfigProto(gpu_options=gpu_options))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, sample_folder, training_epoches = <span class="number">100000</span>, batch_size = <span class="number">5</span>)</span>:</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">self.sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(training_epoches):</span><br><span class="line"><span class="comment"># update D</span></span><br><span class="line">n_d = <span class="number">20</span> <span class="keyword">if</span> epoch &lt; <span class="number">250</span> <span class="keyword">or</span> (epoch+<span class="number">1</span>) % <span class="number">500</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n_d):</span><br><span class="line"><span class="comment">#X_b, _ = self.data(batch_size)</span></span><br><span class="line">X_b= self.data(batch_size)</span><br><span class="line">self.sess.run(self.clip_D)</span><br><span class="line">self.sess.run(</span><br><span class="line">self.D_solver,</span><br><span class="line">            feed_dict=&#123;self.X: X_b, self.z: sample_z(batch_size, self.z_dim)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment"># update G</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n_d):</span><br><span class="line"><span class="comment">#X_b, _ = self.data(batch_size)</span></span><br><span class="line">X_b= self.data(batch_size)</span><br><span class="line">self.sess.run(self.clip_D)</span><br><span class="line">self.sess.run(</span><br><span class="line">self.G_solver,</span><br><span class="line">feed_dict=&#123;self.z: sample_z(batch_size, self.z_dim)&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print loss. save images.</span></span><br><span class="line"><span class="keyword">if</span> epoch % <span class="number">100</span> == <span class="number">0</span> <span class="keyword">or</span> epoch &lt; <span class="number">100</span>:</span><br><span class="line">D_loss_curr = self.sess.run(</span><br><span class="line">self.D_loss,</span><br><span class="line">            feed_dict=&#123;self.X: X_b, self.z: sample_z(batch_size, self.z_dim)&#125;)</span><br><span class="line">G_loss_curr = self.sess.run(</span><br><span class="line">self.G_loss,</span><br><span class="line">feed_dict=&#123;self.z: sample_z(batch_size, self.z_dim)&#125;)</span><br><span class="line">print(<span class="string">'Iter: &#123;&#125;; D loss: &#123;:.4&#125;; G_loss: &#123;:.4&#125;'</span>.format(epoch, D_loss_curr, G_loss_curr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> epoch % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">samples = self.sess.run(self.G_sample, feed_dict=&#123;self.z: sample_z(<span class="number">16</span>, self.z_dim)&#125;)</span><br><span class="line">print(samples.shape)</span><br><span class="line">fig = self.data.data2fig(samples)</span><br><span class="line">plt.savefig(<span class="string">'&#123;&#125;/&#123;&#125;.png'</span>.format(sample_folder, str(i).zfill(<span class="number">3</span>)), bbox_inches=<span class="string">'tight'</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">plt.close(fig)</span><br></pre></td></tr></table></figure><h2 id="（三）实验结果"><a href="#（三）实验结果" class="headerlink" title="（三）实验结果"></a>（三）实验结果</h2><p>我找了17张车的图片~~原谅我比较懒，如下图所示。基本都是差不多样子的。<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g4kfasarlqj20hq069q76.jpg" alt="在这里插入图片描述"><br>然后代码跑起来~我们把它resize到（30，60），主要是为了让我的机器跑快些，本来就怂。<br>一开始是一堆噪声图如下图所示。<img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g4kfb1ggwnj209d08kadl.jpg" alt="在这里插入图片描述"><br>其实在训练一段时间后如下所示，可以看出具有一定车的样子，中间黑车身，貌似也能看到个车轱辘。哈哈。初见效果~<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g4kfb2c7ajj209d086tad.jpg" alt="在这里插入图片描述"><br>损失的结果如下所示：<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g4kfb2u5lmj20i2057mxj.jpg" alt="在这里插入图片描述"></p><h2 id="（四）总结"><a href="#（四）总结" class="headerlink" title="（四）总结"></a>（四）总结</h2><p>通过这个实验对于GAN有了初步的了解，如果有什么写的不对的地方，还请指出。这里附上代码：<br><a href="https://github.com/Harryjun/wgan_demo">https://github.com/Harryjun/wgan_demo</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 图像生成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wgan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分割FCN全卷积神经网络</title>
      <link href="/posts/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2FCN%E5%85%A8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/posts/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2FCN%E5%85%A8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>FCN全卷积神经网络是图像分割的基础网络<br><a id="more"></a><br>FCN实现了端到端的网络，输入mxm图像，输出为mxmxc的图像，其中c代表种类。</p><h2 id="1思想概述"><a href="#1思想概述" class="headerlink" title="1思想概述"></a>1思想概述</h2><p>FCN叫做全卷积神经网络，顾名思义所有曾都是卷积层！也就是抛掉了全连接层，这是第一个改变；再者卷积神经网络卷到最后特征图尺寸越来越少，分辨率比较小，不适合我们做图像分割，好，这里引入一个上采样的做法，卷积完之后再上采样到大尺寸图；网络又考虑层数不断叠加后原图的信息丢失的比较多，那么我们这里引入一个跳层结构，把前面的第四层、第三层特征引过来叠加一下。有种resnet思想。</p><h2 id="2FCN网络图"><a href="#2FCN网络图" class="headerlink" title="2FCN网络图"></a>2FCN网络图</h2><p>我们再看一下下面这个图网络的主题，从左到右卷积、池化一顿操作猛如虎（蓝色卷积，绿色池化），到了最右边16*16*4096，全连接层丢了，先给他弄到21通道再上采样到34*34*21然后合并featuremap4后再上采样，最后经过一系列得到最后500*500*21的特征图。之后怎么做？很多人没有说好，我们平时做分类是得到全连接的1*21这样对他进行softmax，21类，每类有个分数存在1*21的向量中，好我们这500*500*21是像素级别的分类，总共有500*500个像素，每个像素属于21个类别的分别得分是啥，这样用softmax计算损失。所以我们看那些标注图是每个像素有个颜色代表它所属于的类别。端到端！伟大！</p><blockquote><p>端到端学习是一种解决问题的思路，与之对应的是多步骤解决问题，也就是将一个问题拆分为多个步骤分步解决，而端到端是由输入端的数据直接得到输出端的结果。<br><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g3je0ihg1cj20z20dcaeo.jpg" alt="在这里插入图片描述"></p></blockquote><p>那么接下来就要解决细节问题，上采样怎么实现？怎么合并数据？</p><h2 id="3上采样"><a href="#3上采样" class="headerlink" title="3上采样"></a>3上采样</h2><p>对于低分辨率的特征图，我们常常采用上采样的方式将它还原高分辨率，这里陈述三种方法。</p><h3 id="3-1双线性插值上采样"><a href="#3-1双线性插值上采样" class="headerlink" title="3.1双线性插值上采样"></a>3.1双线性插值上采样</h3><p>首先线形插值是什么？线形插值就是知道两个点的值，连一条直线，来确定中间的点的值，具体怎么做，我们找(x1,y1)、(x2,y2)连成一条直线，[x1,x2]中的点就可以用线上的点表示。<br>双线性插值是一个三维的坐标系，我们找到四个点来确定中心点坐标，如下图为网上找的一个例子。<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g3jdvkj58tj20ta0hk421.jpg" alt="在这里插入图片描述"></p><blockquote><p>这种方法计算简单，无需训练。</p><h3 id="3-2反卷积上采样"><a href="#3-2反卷积上采样" class="headerlink" title="3.2反卷积上采样"></a>3.2反卷积上采样</h3><p><strong>3.2.1 怎样上采样</strong><br>普通的卷积操作，会使得分辨率降低，如下图3*3的卷积核去卷积4*4得到2*2的输出。上采样的过程也是卷积，那么怎么会得到分辨率提高呢？之前我们看卷积时有个保持输出与输入同分辨率的方法就是周围补0，嗯嗯。那么你是否灵机一动，那要是让分辨率提高呢？是不是再多补一些0，对的看看图2。</p></blockquote><p><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g3jdvm4k6jj206s077gm0.jpg" alt="在这里插入图片描述"><br>图1 常规卷积操作<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g3jdvnl0qqj209k0aqdhd.jpg" alt="在这里插入图片描述"><br>图2 上采样操作（四周补0）</p><p>其实呢作者在这又换了个方法，你想一下，只在四周补0会导致最边上的信息不太好，那我们把这个信息平均下，在每个像素与像素之间补0呢，看图3就是这么操作的。</p><p><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g3jdvp4fnaj20az0chmzc.jpg" alt="在这里插入图片描述"><br>图3 反卷积插零</p><p><strong>3.2.2 反卷积补多少零？</strong><br>然后我们看一下参数的计算，先看一下四周补0的情况。下图给出了发卷积的参数，我们要保持转置卷积的输出核卷积的输入相同也就是i=o’，转置卷积就是反卷积。这里主要算出p为多少就是补多少个0，看我图5给出了计算。<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g3jdvqwtllj20op0c9tdi.jpg" alt="在这里插入图片描述"><br>图4 四周补零反卷积<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g3jdvsu3tnj20w40u0tx6.jpg" alt="在这里插入图片描述"><br>图5 四周补0计算</p><p>再看一下反卷积间隙补0的计算如图6所示。其中插零输入是先往里面插入i‘-1个0。再计算p’</p><p><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g3jdvu0dfsj20ou0c4jwj.jpg" alt="在这里插入图片描述"><br>图6 间隙补0反卷积<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g3jdvvx2wtj212w0u01kx.jpg" alt="在这里插入图片描述"><br>图7 间隙补零反卷积计算</p><h3 id="3-3反池化上采样"><a href="#3-3反池化上采样" class="headerlink" title="3.3反池化上采样"></a>3.3反池化上采样</h3><p>反池化可以用下图来理解，再池化时需要记录下池化的位置，反池化时把池化的位置直接还原，其他位置填0。<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g3jdvx7r1xj20jb07lwff.jpg" alt="在这里插入图片描述"></p><h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><p>三种方法各有优缺，双线性插值方法实现简单，无需训练；反卷积上采样需要训练，但能更好的还原特征图；</p><h2 id="4跳层结构Skip-Layer"><a href="#4跳层结构Skip-Layer" class="headerlink" title="4跳层结构Skip-Layer"></a>4跳层结构Skip-Layer</h2><p>跳层结构是啥呢，就是把第四层的featuremap考虑进来和最后一层得到的featuremap上采样合并信息再进行上采样。这个结构叫做跳层。那么实际你可以再结合第三层featuremap这样上次样倍数就需要提高，考虑的源信息就越多。</p><h2 id="5再看FCN网络"><a href="#5再看FCN网络" class="headerlink" title="5再看FCN网络"></a>5再看FCN网络</h2><p>之后我们再看FCN这个网络，如果你只考虑最后一层信息，进行上采样，得到下图，这是在ALEXnet上做了修改，把最后的全连接层去掉改为卷积操作，最后卷出来16*16*21的featuremap进行了一个步长为32的双线性插值上采样得到500*500*21的图，可想而知这家伙肯定差太多了，中间这么多点都是插值插出来的！<br><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g3jdvyy375j20il06daaz.jpg" alt="在这里插入图片描述"><br>继续，改一下，这里把那个上采样改为2倍的反卷积采样，上采样到34*34*21，然后考虑第四层featuremap对他进行1*1*21卷积得到34*34*21的图，之后再合并两个信息，直接对应元素相加，得到34*34*21然后进行步长16的上采样。在这之后考虑还不行就在考虑第三个特征层加进去！</p><p><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g3jdw0lr4qj20rf09gjth.jpg" alt="在这里插入图片描述"></p><h2 id="6实验结果"><a href="#6实验结果" class="headerlink" title="6实验结果"></a>6实验结果</h2><p>实验分别对FCN32、16、8的结构做了实验，可以看出考虑浅层的信息越多，实验效果越好！<br><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g3jdw1rqtjj20bn04y40d.jpg" alt="在这里插入图片描述"></p><h2 id="7小结"><a href="#7小结" class="headerlink" title="7小结"></a>7小结</h2><p>FCN给我们提供了一个上采样的思路来解决图像分辨率低的问题，以及跳层结构来考虑浅层网络的特征来考虑多图像信息。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]FCN中反卷积、上采样、双线性插值之间的关系<br><a href="https://blog.csdn.net/u011771047/article/details/72872742/">https://blog.csdn.net/u011771047/article/details/72872742/</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 语义分割 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FCN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测CNN经典网络（四）R-FCN</title>
      <link href="/posts/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89R-FCN/"/>
      <url>/posts/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89R-FCN/</url>
      
        <content type="html"><![CDATA[<p>前面所说的RCNN作为最早的目标检测网络，具有一些问题，其对每一个ROI都做一遍卷积（费时）；对于感兴趣区域的筛选也费时；随后FastR-CNN、Faster-CNN给出了解决方案。之后学者又去思考后面的全连接层能不能去掉，或者不让每一个感兴趣区域都走一遍全连接，这也很费时间啊！（我们了解在图像分类中，人们都很讨厌全连接层，参数量太大），为此R-FCN出现了！<br><a id="more"></a></p><h2 id="1回顾"><a href="#1回顾" class="headerlink" title="1回顾"></a>1回顾</h2><p>回顾R-CNN系列的方案都是在解决一个计算量计算时间的问题，R-CNN存在一些问题，SPP-net提出金字塔池化层，将卷积放在前面，实现了一张图卷积一次就行，降低了大量时间！Fast R-CNN提出了ROI池化，引入并行的多任务损失函数，也提高了效率！到了Faster R-CNN认为区域建议网络也可以环程卷积网络，提出了RPN网络~~。本篇文章介绍下一个迭代版本R-FCN将后面的全连接层分类层也换成卷积网络！<br><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g2u905081sj20ks085abp.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2位置敏感性的理解"><a href="#2位置敏感性的理解" class="headerlink" title="2位置敏感性的理解"></a>2位置敏感性的理解</h2><p>写着一部分看了好多文章都没看懂，查了好多资料总结到如下，之后有新的理解会加上，如果朋友们有好的文章解释可以推荐给我。<br>首先，对于图片分类问题，我们用比较深的卷积网络比较好，当网络比较深的时候，分类问题对于位置的敏感性就较差，因为一张图片通过一个深的网络到了后面再到全连接层，位置的变动对于后面特征的影响比较小了，所以它的识别还是会准确，这就是位置不敏感，平移不变性。<br>然而对于定位问题，我们需要得到它的定位，网络过于深的化就会造成我们定位不准确，平移不变！所以构造一个浅的网络可能对于分类来说比较好。</p><p>再来看个Faster R-CNN + ResNet-101结构的例子。这个是参考文献3给出的，如果在Faster R-CNN中没有ROI层，直接对整个feature map进行分类和位置的回归，由于ResNet的结构较深，平移可变性较差，检测出来的坐标会极度不准确。具体网络可以自己查一下！</p><p>如果在ResNet中间（conv4与conv5间）加个ROI层结果就不一样了，此时到了第四卷积层才给框选区域，坐标还是有的，此时分类器离得比较近了，分类器对于位置的敏感程度比较低了！也就是平移可变性！ROI层提取出的proposal中，有的对应前景label，有的对应背景label，proposal位置的偏移就有可能造成分类器（前景和背景分类）的不同。偏移后原来的前景很有可能变成了背景，原来的背景很有可能变成了前景，换句话说分类loss对proposal的位置是敏感的，这种情况ROI层给深层网络带来了平移可变性。</p><p>如果把ROI加到ResNet的最后一层（图1 conv5后）结果又是怎样呢？conv5的第一个卷积stride是2，造成conv5输出的feature map更小，这时proposal的一个小偏移在conv5输出上很有可能都感知不到，即proposal对应的label没有改变，此时识别出来的位置准确度会很差。</p><p>作者在考虑前人的实验后，想着把ROI向后靠一下是不是就能把全连接层也共享了！实则会导致位置的准确度降低的！所以考虑这些因素，他提出了位置敏感卷积网络。</p><h2 id="3位置敏感卷积层网络"><a href="#3位置敏感卷积层网络" class="headerlink" title="3位置敏感卷积层网络"></a>3位置敏感卷积层网络</h2><p>下图为R-FCN网络（<strong>这里说明一下，下面应该是还有一个回归！</strong>），其中红色部分是修改后的分类器，我们可以看出前面卷积之后得到featuremap之后有一部分向上去做RPN网络了，这个和FasterR-CNN一样。另一路去做分类了~~这里你会看到它写的是conv卷积，对没错，我们用一个卷积得到一个具有深度为K*K*(C+1)的特征。C+1代表类别，C个类别加一个背景。K是啥意思？这个K<em>K我们表示它属于某个类别上左、上中、上右……的可能性。下图中每个颜色块代表一个方位，一共3\</em>3=9个方位，每个方位其实是包含C+1个的。再通俗点黄色层其实不是一层有C+1个层，分别代表它属于每个类别左上角的概率！<br>然后它不是有很多ROI，它用ROI套住一个区域，对于第一类，他需要从这9个大层中对应这个类的小层得到一个平均结果，然后把这9个数组合投票~看他是不是这个类。<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2u9056tkoj20j00abgp7.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看下面这个图，每个大层有C+1个，然后对ROI抽取后得到饼图，有C+1个类所以是C+1层，再求一个得分得到C+1的向量。<br>那么这时需要解决两个问题：<br><strong>First 对于一个ROI如何抽成一个点<br>Second 投票怎么投？</strong><br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2u905ujynj20fs05htaw.jpg" alt="在这里插入图片描述"><br>好，接下来说这个问题。<br><strong>First 对于一个ROI如何抽成一个点</strong><br>这里它直接采取平均值的方法，所有像素值的平均值来代表一个值。<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2u908n3k7j20l20bijvt.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>Second 投票怎么投？</strong><br>对于投票，他也是计算的这K*K个值的平均值。哈哈！</p><h2 id="4位置敏感回归"><a href="#4位置敏感回归" class="headerlink" title="4位置敏感回归"></a>4位置敏感回归</h2><p>前面分类有了，那么回归位置呢？思路是一样的！前面分类是卷积为K*K*(C+1),回归的话就是四个参数啊，左上角右上角坐标！，那就是K*K*4,其他的就和上面一样了。<br>即在ResNet的共享卷积层的最后一层上面连接一个与position-sensitive score map并行的score maps，该score maps用来进行regression操作，我们将其命名为regression score map，而该regression score map的维度应当是 4<em>K</em>K ，然后经过Position-sensitive RoI pooling操作后，每一个RoI就能得到4个值作为该RoI的x,y,w,h的偏移量了，其思路和分类完全相同。</p><h2 id="5损失的定义"><a href="#5损失的定义" class="headerlink" title="5损失的定义"></a>5损失的定义</h2><p>然后就是怎么去定义这个损失，只有定义好损失，网络才能按照作者的设想去跑啊！，看下面这个图（图都是从小象课堂的PPT上截取的，感谢！）。<br>先主要说一下分类损失，得到上面的投票，C+1的向量对这个值softmax归一化，其实就是都去指数幂次，然后把正确的做分子，这样看正确类别分类的得分是否够大，不大的话，呵呵损失就大，那么网络训练就回去矫正，那么为了让损失小，就得让这个类别的得分高，那么就得让前面的位置敏感卷积层的得分高~这样从理论上应该是能实现的。<br><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g2u90b1vyzj20ko0cajx0.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="6可视化结果"><a href="#6可视化结果" class="headerlink" title="6可视化结果"></a>6可视化结果</h2><p>论文中给出了其可视化的结果，如下图所示，可以看出，当这个ROI选对了，那么对于人这个类别，它得出的9个方位图在中间，我们可以看出左上角其实不太属于人，看中间那个图高亮的区域少；中间部位其实肯定属于人了，我们看出第五个格子几乎全部高亮，以此类推可以分析其他格子，最后计算每个格子的平均得到右图，可以看出其值比较高，属于人类。<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2u90cpwktj20lx09rn4w.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图2哪个区域选歪了之后就不一样了得分低一点，也很好分析！</p><p><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2u90ecvhej20lt0a4n4v.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="7实验效果"><a href="#7实验效果" class="headerlink" title="7实验效果"></a>7实验效果</h2><p>作者首先做了一个实验去测试一下不同的位置敏感池化单元尺寸对结果的影响，可以看出1*1的尺寸，也就是对于一个ROI不分块，失败！3*3也就是分成左上左中左下九份效果还可以，7*7的效果最好。<br><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g2u90fvoklj20sf08fdim.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>之后又做了对比试验，与之前的网络做了对比。可以看出效果得到了现主的提升，在保证效果的同时，时间更短！<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2u90hothlj20rj08ln10.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NMT1VEX0o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="8参考文献"><a href="#8参考文献" class="headerlink" title="8参考文献"></a>8参考文献</h2><p>[1]小象学堂课程PPT<br>[2]R-FCN详解<br><a href="https://blog.csdn.net/WZZ18191171661/article/details/79481135">https://blog.csdn.net/WZZ18191171661/article/details/79481135</a><br>[3]解答关于R-FCN的所有疑惑（原创）<br><a href="https://www.jianshu.com/p/409fd61db9db">https://www.jianshu.com/p/409fd61db9db</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>目标检测CNN经典网络（三）Fast R-CNN ，Faster R-CNN</title>
      <link href="/posts/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%89%EF%BC%89Fast%20R-CNN%20%EF%BC%8CFaster%20R-CNN/"/>
      <url>/posts/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%89%EF%BC%89Fast%20R-CNN%20%EF%BC%8CFaster%20R-CNN/</url>
      
        <content type="html"><![CDATA[<p>继R-CNN与SPP-net之后又出现了Fast R-CNN与Faster R-CNN,比之前的网络有了更快的速度，其准确率也没有降低。并且把端到端的概念引入到目标检测中。<br><a id="more"></a></p><h2 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h2><p>FastR-CNN借鉴SPP-net思想加入ROI感兴趣池化，并将两个任务回归和分类同时进行，进行多任务训练。<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2surkjl1rj20kd08fjy3.jpg" alt="在这里插入图片描述"></p><h3 id="ROI池化"><a href="#ROI池化" class="headerlink" title="ROI池化"></a>ROI池化</h3><p>ROI感兴趣池化可以看作SPPpool的简化，下图可以看出，ROI只对感兴趣的区域做一次池化即可。<br>考虑到感兴趣区域（RoI）尺寸不一，但是输入图中后面FC层的大小是一个统一的固定值，因为ROI池化层的作用类似于SPP-net中的SPP层，即将不同尺寸的RoI feature map池化成一个固定大小的feature map。具体操作：假设经过RoI池化后的固定大小为是一个超参数，因为输入的RoI feature map大小不一样，假设为，需要对这个feature map进行池化来减小尺寸，那么可以计算出池化窗口的尺寸为：h/H,w/W，即用这个计算出的窗口对RoI feature map做max pooling，Pooling对每一个feature map通道都是独立的。</p><p><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2surmhqqfj20o509c0tp.jpg" alt="在这里插入图片描述"></p><h3 id="多任务损失函数"><a href="#多任务损失函数" class="headerlink" title="多任务损失函数"></a>多任务损失函数</h3><p>Fast R-CNN将两个任务并行运行到一起，其损失定义如下所示，考虑损失为分类损失和回归损失。<br><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g2surp10w1j20pl0ey44d.jpg" alt="在这里插入图片描述"></p><p>最终论文给出其实现的性能可以看下表，其将训练时间与测试时间大大缩短，尤其是单图的测试时间大大缩短，这功劳归结于一方面采用了先卷积后<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2surqgr4mj20if047aac.jpg" alt="在这里插入图片描述"></p><h2 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h2><p>Fast R-CNN存在的问题：存在瓶颈：选择性搜索，找出所有的候选框，这个也非常耗时。那我们能不能找出一个更加高效的方法来求出这些候选框呢？<br>解决：加入一个提取边缘的神经网络，也就说找到候选框的工作也交给神经网络来做了。（<strong>想较少测试的时间那就把任务交给深度学习，学习出一套参数可以以后一直用。</strong>）<br>给这么一个方法起了个名字叫做Region Proposal Network(RPN)。</p><h3 id="网络总图"><a href="#网络总图" class="headerlink" title="网络总图"></a>网络总图</h3><p>先看下面这张图，它是最终的测试网络。<br><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g2surrwa9nj20qt0d4ah2.jpg" alt="在这里插入图片描述"><br>通过上面这张图可以看出Faster R-CNN由四个部分组成：<br>1）卷积层(conv layers)，用于提取图片的特征，输入为整张图片，输出为提取出的特征称为feature maps<br>2）RPN网络(Region Proposal Network)，用于推荐候选区域，这个网络是用来代替之前的search selective的。输入为图片为featrue maps，输出为多个候选区域，这里的细节会在后面详细介绍。<br>3）RoI pooling，和Fast R-CNN一样，将不同大小的输入转换为固定长度的输出，输入输出和Fast R-CNN中RoI pooling一样。<br>4）分类和回归，这一层的输出是最终目的，输出候选区域所属的类，和候选区域在图像中的精确位置。</p><p>那么其实你可以看出来关键的部分在于候选区域的改动，那么我们主要说下候选区域的方法。</p><h3 id="RPN网络"><a href="#RPN网络" class="headerlink" title="RPN网络"></a>RPN网络</h3><p>首先作者自己设想原图上或者说featuremap上每个位置可能会产生k中可能的区域，下图所示，作者给出的方案具体来说就是每个位置可能会出现三种面积可能，三种长宽表示样式。三种面积分别是128×128，256×256,512×512，每种面积又分成3种长宽比，分别是2:1,1:2,1:1 。呵呵一算是九种！所以它的k是9！<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2suruu6x0j20mu08mwjv.jpg" alt="在这里插入图片描述"><br>然后RPN网络是这么干的，先将一幅图片经过CNN网络得到第五个卷积层，然后将第五个卷积层用3*3卷积核卷积得到一个256通道的特征图，之后再分为两路，一路用1*1卷积降维到原尺寸下2*k个通道（这是干啥，这2*k个分别对应是/否为对的候选区域，总共有k个框，所以是2*k个），另一路用1*1的卷积降维到原尺寸下4*k个通道（这个就是左上角坐标，右下角坐标，k种）ok！<br>注意：这里尺寸没有变哎，因为每个位置都要输出这么个得分情况哎，我们最后确定比较好的中心位置哎还有它的尺寸。<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2surwcbiej20nc0e8acr.jpg" alt="在这里插入图片描述"></p><p>那么如果RPN一套神经网络，FastR-CNN一套网络好像也不行哦，训练费事哦。那么RPN网络和FastR-CNN是如何组合的是如何权值共享的呢？</p><h3 id="Faster-R-CNN训练"><a href="#Faster-R-CNN训练" class="headerlink" title="Faster R-CNN训练"></a>Faster R-CNN训练</h3><p>总结一下Faster R-CNN的训练过程如下所示：<br>（1）先再imagenet上预训练一个CNN模型，得到一个初始的RPN网络<br>（2）再另外训练一个imagenet模型CNN2，然后把在步骤1得到的Regionproposals用来训练FastR-CNN模型。<br>（3）有了一个比较好的FastR-CNN模型也就是步骤2的模型，我们把这个CNN部分固定再去矫正RPN网络，此时CNN部分就用CNN2（把CNN1直接丢掉了！）然后去调参RPN后面那一部分，调好了这时的RPN模型基本可以了。<br>（4）完事候选区域又变了，回去在调FastR-CNN模型，此时CNN部分不动了，这两个网络已经共享了！我们去调后面的全连接啥的。ok调好了就大功告成。<br>可以看出训练的时候费事，但是选练好了后都是神经网络，测试时间就大大减少。<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2surzbdxuj20p30ei0vv.jpg" alt="在这里插入图片描述"></p><p>Faster R-CNN的主要贡献是设计了提取候选区域的网络RPN，代替了费时的选择性搜索，使得检测速度大幅提高。<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2sus0uh5jj20mm03umxe.jpg" alt="在这里插入图片描述"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]第三十一节，目标检测算法之 Faster R-CNN算法详解<br><a href="https://www.cnblogs.com/zyly/p/9247863.html">https://www.cnblogs.com/zyly/p/9247863.html</a><br>[2]Faster R-CNN文章详细解读<br><a href="https://blog.csdn.net/liuxiaoheng1992/article/details/81843363">https://blog.csdn.net/liuxiaoheng1992/article/details/81843363</a><br>[3]【目标检测】Fast R-CNN论文详解（Fast R-CNN）<br><a href="https://www.jianshu.com/p/fbbb21e1e390">https://www.jianshu.com/p/fbbb21e1e390</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>目标检测CNN经典网络（二）SPPnet</title>
      <link href="/posts/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89SPPnet/"/>
      <url>/posts/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89SPPnet/</url>
      
        <content type="html"><![CDATA[<p>在上文介绍了R-CNN网络，可以看出其存在很多问题：卷积网络的重复计算造成计算量大耗时多，之后出现了SPPnet提出先卷积再进行框选目标区域的方法。<br><a id="more"></a></p><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>首先看下面这幅图，R-CNN中我们在卷积之前需要先选定预选框，然后可能大小尺寸不一，需要对其进行crop或者warp一下同意尺寸再进行卷积网络；SPPnet提出我们可以先对原图进行卷积神经网络，再利用预选框去找出对应的第五层卷积网络所对应的特征图（<strong>因为我们发现其实再训练卷积网络时，原图和每层的卷积图实际位置关系还是不变的</strong>）全连接层我们单独放在后面，在进入全连接层之前我们做了一个金字塔池化SSP（后面讲！）到统一尺寸。<br><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g2smbne71yj20fi09977s.jpg" alt="在这里插入图片描述"></p><h2 id="空间金字塔-最大池化"><a href="#空间金字塔-最大池化" class="headerlink" title="空间金字塔+最大池化"></a>空间金字塔+最大池化</h2><p>在图像处理中有个图像金字塔的思想可以采样图像到任意大小，这里借鉴这个思想，我们把卷积网络的输出得到的13*13*256特征提取三个不同尺寸，分别是1*1（也就是原图），2*2（原图分为四份），4*4（原图分为16份），然后对每一份选区最大的一个值代表该区域也就是最大池化（一份包含很多像素点啊）。最后得到16+4+1=21  *256 的特征！<br>这样不管上一层输出的尺寸多大，我们都能做这个变换！</p><blockquote><p>如果像上图那样将reponse map分成4x4 2x2 1x1三张子图，做max pooling后，出来的特征就是固定长度的(16+4+1)x256那么多的维度了。如果原图的输入不是224x224，出来的特征依然是(16+4+1)x256</p></blockquote><p>更加通用的认识可以认为：<br>输入尺寸在[180,224]之间，假设最后一个卷积层的输出大小为a×a，若给定金字塔层有n×n 个bins，进行滑动窗池化，窗口尺寸为win=⌈a/n⌉，步长为str=⌊a/n⌋，使用一个网络完成一个完整epoch的训练，之后切换到另外一个网络。只是在训练的时候用到多尺寸，测试时直接将SPPNet应用于任意尺寸的图像。<br><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g2smbopwbsj20fo0d3jtm.jpg" alt="在这里插入图片描述"><br>这样我们得到了统一尺寸的特征在进行后面的全连接层训练即可。</p><h2 id="空间金字塔在定位实验中的应用"><a href="#空间金字塔在定位实验中的应用" class="headerlink" title="空间金字塔在定位实验中的应用"></a>空间金字塔在定位实验中的应用</h2><p>在定位实验中，需要我们将原图上的ROI映射到featuremap中，具体可以参考我的另一篇文章<a href="https://blog.csdn.net/CLOUD_J/article/details/89917950">探讨卷积的感受视野以及sPPnet中ROI映射到featuremap</a><br>我详细介绍了ROI映射的方法。<br>对此，我们得到映射后的图片就可以在featuremap中找到对应的区域，然后再进行空间金字塔最大池化得到特征。金字塔用了{6x6 3x3 2x2 1x1}，共50个bin，分类器也是用了SVM。<br>最后得到了很大的提升，主要在于时间！<br><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g2smbq0emlj20d709odhj.jpg" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>R-CNN提取特征比较耗时，需要对每个warp的区域进行学习，而SPPNet只对图像进行一次卷积，之后使用SPPNet在特征图上提取特征。结合EdgeBoxes提取的proposal，系统处理一幅图像需要0.5s。<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2smcqldffj20pp0eoq98.jpg" alt="在这里插入图片描述"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]探讨卷积的感受视野以及sPPnet中ROI映射到featuremap<br><a href="https://blog.csdn.net/CLOUD_J/article/details/89917950">https://blog.csdn.net/CLOUD_J/article/details/89917950</a><br>[2]【目标检测】SPPNet算法详解<br><a href="https://blog.csdn.net/bryant_meng/article/details/78615353">https://blog.csdn.net/bryant_meng/article/details/78615353</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>探讨卷积的感受视野以及sPPnet中ROI映射到featuremap</title>
      <link href="/posts/%E6%8E%A2%E8%AE%A8%E5%8D%B7%E7%A7%AF%E7%9A%84%E6%84%9F%E5%8F%97%E8%A7%86%E9%87%8E%E4%BB%A5%E5%8F%8AsPPnet%E4%B8%ADROI%E6%98%A0%E5%B0%84%E5%88%B0featuremap/"/>
      <url>/posts/%E6%8E%A2%E8%AE%A8%E5%8D%B7%E7%A7%AF%E7%9A%84%E6%84%9F%E5%8F%97%E8%A7%86%E9%87%8E%E4%BB%A5%E5%8F%8AsPPnet%E4%B8%ADROI%E6%98%A0%E5%B0%84%E5%88%B0featuremap/</url>
      
        <content type="html"><![CDATA[<p>最近在学习目标检测sPPnet时看到ROI映射到featuremap中的方法，文中对此叙述较少，所以就此问题差了一些资料，在知乎上发现一片理解较好的文章(文末给出了参考文献)，于此做一总结。<br><a id="more"></a><br>先谈一下感受视野，在学习卷积的时候，我们比较熟悉的是上一层图映射到下一层之后的尺寸，很少谈及感受野，这其实是一个重要的概念。</p><h2 id="卷积中的感受视野"><a href="#卷积中的感受视野" class="headerlink" title="卷积中的感受视野"></a>卷积中的感受视野</h2><p>首先，我们知道上一层图的尺寸，去推测下一层的尺寸，如下公式即可，这个大家应该很熟悉<br>output field size = ( input field size - kernel size + 2*padding ) / stride + 1<br>(output field size 是卷积层的输出，input field size 是卷积层的输入，stride步长，padding填充像素，kernelsize卷积核尺寸)<br>随后，我们想如果知道后一层的尺寸，是不是就可以知道前一层的尺寸<br>答案必然是： input field size = （output field size - 1）<em> stride - 2</em>padding + kernel size<br>那么此时如果我们把最后一层的尺寸定为1，向前推是不是可以知道最后一层的一个小单位格子对应到原图的尺寸，也就是感受野了。</p><blockquote><p>卷积神经网络CNN中，某一层输出结果中一个元素所对应的输入层的区域大小，被称作感受野receptive field。感受野的大小是由kernel size，stride，padding , outputsize 一起决定的。</p></blockquote><p>我们可以看下面这张图更好的理解下<br>虽然原图很大，但我们考虑原图中的11*11的尺寸向后映射到map2变为7<em>7的尺寸，再向后映射到1</em>1.<br>7=(11-5)/1+1；<br>1=(7-7)/1+1；<br>是不是~~<br>之后我们反过来证明一下<br>最后一层向map2映射7 = (1-1)*1+7<br>map2向map1映射11 = (7-1)*1+5</p><p><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2slxokqvej20k00dtdkv.jpg" alt="在这里插入图片描述"><br>了解了感受野，我们再看一下坐标变换</p><h2 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h2><p>在感受野上面做坐标变换，实则是对中心位置做变换，如下图map3的一个点（位置为p3）它向上映射到map2的范围内中心位置是多少呢?<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2sly75bmlj208y05kgmm.jpg" alt="在这里插入图片描述"><br>我们可以用下面这个公式来理解<br>对于 Convolution/Pooling layer: $p_i = s_i \cdot p_{i+1} +( (k_i -1)/2 - padding)$（P代表位置，k表示卷积核大小，s代表步长）<br>对于Neuronlayer(ReLU/Sigmoid/..) : $p_i = p_{i+1}$</p><blockquote><p>在此画了一个图方便理解，下面一层的绿色点反映一个1*1的点中对应到上一层绿色点，他其实是在最左侧的基本格子向右平移p(p就是下面那层的坐标)个stride（本层的步长）所以这部分坐标就是$s_i \cdot p_{i+1}$<br>然后还差一个基本格子的半个坐标就用$( (k_i -1)/2 - padding)$来决定哈哈！完美！<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2slybqcfyj20ez0f612f.jpg" alt="在这里插入图片描述"></p></blockquote><p>我们最后再看一下下面这个图给出的计算！理解一下它的计算！<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2slyem4i2j20jd05jgmo.jpg" alt="在这里插入图片描述"></p><p>上面是感受野的映射公式，到了ROI对于上面的公式，何凯明在SPP-net中采用做了一个简化。其实就是巧妙的化简一下公式<br>$pi = s_i \cdot p_{i+1} +( (k_i -1)/2 - padding)$<br>令每一层的padding都为<br>$padding = \lfloor k_i /2 \rfloor<br>\Rightarrow$<br>$pi = s_i \cdot p_{i+1} +( (k_i -1)/2 -  \lfloor k_i /2 \rfloor)$<br>当$k_i$ 为奇数 $( (k_i -1)/2 -  \lfloor k_i /2 \rfloor) = 0$  所以 $p_i = s_i \cdot p_{i+1}$<br>当k_i 为偶数 $( (k_i -1)/2 -  \lfloor k_i /2 \rfloor) = -0.5$ 所以 $p_i = s_i \cdot p_{i+1} -0.5$<br>而 $p_i$ 是坐标值，不可能取小数 所以基本上可以认为$p_i = s_i \cdot p_{i+1}$。公式得到了化简：感受野中心点的坐标$p_i$只跟前一层 $p_{i+1}$ 有关。</p><h2 id="ROI映射变换"><a href="#ROI映射变换" class="headerlink" title="ROI映射变换"></a>ROI映射变换</h2><p>ROI映射的时候是将左上角和右小角映射到featuremap然后确定最后的区域。<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2slzgnf91j20na0cxgmu.jpg" alt="在这里插入图片描述"><br>考虑原图上的点不可能每一个点在featuremap中都有对应，所以我们就找最近的点。<br>例如图中左上角的点（x,y）映射到 feature map上的(x’,y’) ： 使得 (x’,y’) 在原始图上感受野（上图绿色框）的中心点 与（x,y）尽可能接近。<br>在上面每层都填充padding/2 得到的简化公式 ： $p_i = s_i \cdot p_{i+1}$<br>我们考虑从featuremap传到原图得到$p_0 = S \cdot p_{i+1}$ 其中 $(S = \prod_{0}^{i} s_i)$(所有步长量乘积~~)<br>呵呵简单了不少。把式子反过来就变为：$x’ =  \lfloor x/S \rfloor   ,\;y’ =  \lfloor y/S \rfloor$。<br>这样就实现了ROI坐标变换，sPPnet中改了一下：$x’ =  \lfloor x/S \rfloor +1  ,\;y’ =  \lfloor y/S \rfloor +1$,加了一个1，有什莫用呢？笔者认为相当于把得到的坐标向里面缩一下保证准确性。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]原始图片中的ROI如何映射到到feature map?<br><a href="https://zhuanlan.zhihu.com/p/24780433">https://zhuanlan.zhihu.com/p/24780433</a><br>[2]目标检测CNN经典网络（二）SPPnet<br><a href="https://blog.csdn.net/CLOUD_J/article/details/89893140">https://blog.csdn.net/CLOUD_J/article/details/89893140</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPPnet </tag>
            
            <tag> 感受野 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测CNN经典网络（一）R-CNN</title>
      <link href="/posts/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89R-CNN/"/>
      <url>/posts/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89R-CNN/</url>
      
        <content type="html"><![CDATA[<p>在早期计算机视觉研究时，人们很好的将CNN应用在目标分类的问题中，但是一直不能很好的解决目标检测的问题，目标检测不仅要分析出其是什么东西，而且还要回归出其位置。这是其在CNN训练的痛点。为此出现了R-CNN网络。<br><a id="more"></a></p><h2 id="R-CNN思路"><a href="#R-CNN思路" class="headerlink" title="R-CNN思路"></a>R-CNN思路</h2><p>R-CNN简单理解就是先训练一个CNN分类器，然后再对每幅图片挑选2000个预选区域，让这个预选区域经过R-CNN前向传播得到特征，特征先保留到硬盘中，此时与我们的标签进行对比，重叠率高的为正样本，重叠率低的为负样本，随后单独进行SVM训练。<br>R-CNN的整体思路如下：<br>（1）给定一张输入图片，从图片中提取 2000 个类别独立的候选区域。<strong>（selective search）</strong><br>（2）对于每个区域利用CNN网络抽取一个固定长度的特征向量。<strong>（这个CNN是提前训练好的一个网络）</strong><br>（3）再对每个区域所对应的特征向量利用 SVM 进行目标分类。<br><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g2rey2e41rj20ir0drjya.jpg" alt="在这里插入图片描述"></p><h2 id="候选区域寻找selective-search"><a href="#候选区域寻找selective-search" class="headerlink" title="候选区域寻找selective search"></a>候选区域寻找selective search</h2><p>关于候选区域的选择有多种方法，最简单的方法为滑窗法，就是以一定间距不断横纵遍历得到所有的窗口，但是所有区域都遍历，而且有时候物体不一样大？这就太浪费时间了。<br>论文章所采用的方法是选择搜索法。<br>算法具体如下图所示<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2rexwevloj20jn0grjwj.jpg" alt="在这里插入图片描述"><br>step0：生成区域集R。</p><p>step1：计算区域集R里每个相邻区域的相似度S={s1,s2,…}<br>//循环以下步骤<br>step2：找出相似度最高的两个区域，将其合并为新集，添加进R<br>step3：从S中移除所有与step2中有关的子集<br>step4：计算新集与所有子集的相似度<br>step5：S若为空则跳出循环，否则跳至step2</p><p><strong>相似度计算</strong><br>那么关键点在于相似度怎么判断？<br>图像之间的特征有很多，颜色？纹理特征？尺寸等？对于相似度的判断，选择性搜索考虑了颜色、纹理、尺寸和空间交叠这4个参数。<br><strong>1、颜色特征</strong><br>将色彩空间转为HSV，每个通道下以bins=25计算直方图，这样每个区域的颜色直方图有25*3=75个区间。 对直方图除以区域尺寸做归一化后使用下式计算相似度：<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2rfnt2p9bj208h0203yg.jpg" alt="在这里插入图片描述"><br>上式如何理解？简单说一下，我们归一化后每个通道的数据后，一维特征向量的和为1.0，比较两个区域的特征向量每一位，把每一位的最小值加起来。如果全都一样那么结果肯定是1啊！如果不一样，每一位都取最小值，那就肯定比1小啊！哈哈就是这么理解。</p><p><strong>2、纹理相似度（texture similarity）</strong></p><p>论文这里的纹理采用SIFT-Like特征，采用方差为1的高斯微分在8个方向做梯度统计，然后将统计结果（尺寸与区域大小一致）以bins=10计算直方图。直方图区间数为8<em>3</em>10=240（使用RGB色彩空间）。计算公式如下所示：<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2rfsef786j206n01fdfm.jpg" alt="在这里插入图片描述"></p><p><strong>3、尺度相似度</strong><br>尺度相似度其实是实现优先合并小的区域，也就是减少大区域合并小区域。<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2rfwamwqgj207u016mwy.jpg" alt="在这里插入图片描述"><br><strong>4、交叠相似度（shape compatibility measure）</strong><br>上述完成后，要看一下两个区域是否爱挨着，如果距离十万八千里，那就没有合并的必要。如何计算？先找一个外接矩形把它框起来，如果两个矩形相距较远，则外接矩形就很大，所以我们设计这样的指标，其指标是合并后的区域的Bounding Box（能够框住区域的最小矩形BBij）减去两个矩形的尺寸，得到相对差距。其计算方式：<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2rfzhewa3j20ap0160sj.jpg" alt="在这里插入图片描述"><br><strong>候选区域排序</strong><br>相似度计算后还有一个问题，如何对候选区域排序呢，通过上述的步骤我们能够得到很多很多的区域，但是显然不是每个区域作为目标的可能性都是相同的，因此我们需要衡量这个可能性，这样就可以根据我们的需要筛选区域建议个数啦。</p><p>这篇文章做法是，给予最先合并的图片块较大的权重，比如最后一块完整图像权重为1，倒数第二次合并的区域权重为2以此类推。但是当我们策略很多，多样性很多的时候呢，这个权重就会有太多的重合了，排序不好搞啊。文章做法是给他们乘以一个随机数，毕竟3分看运气嘛，然后对于相同的区域多次出现的也叠加下权重，毕竟多个方法都说你是目标，也是有理由的嘛。这样我就得到了所有区域的目标分数，也就可以根据自己的需要选择需要多少个区域了。</p><h2 id="CNN网络训练"><a href="#CNN网络训练" class="headerlink" title="CNN网络训练"></a>CNN网络训练</h2><p>上述过程我们得到了大量候选区域（每个候选区域都提供了矩形框的位置情况），怎么训练呢？<br><strong>第一步、数据标注</strong>：我们对于每张图片标注一下boundbox四维向量和所属类别编号。<br><strong>第二步、预训练</strong>：论文在大型辅助训练集ILSVRC2012分类数据集（<strong>分类数据集没有约束框数据，每幅图片对应一个类别标签</strong>）上预训练了CNN。预训练采用了Caffe的CNN库。<br><strong>第三步、微调CNN</strong>：<br><strong>特定领域的参数调优</strong><br>第一步训练了一个分类器，但是我们要做的是目标检测，而且我们换了另一套数据集，所以为了让我们的CNN适应新的任务（即<strong>检测任务</strong>）和新的领域（变形后的<strong>候选窗口</strong>）。我们只使用变形后的<strong>候选区域</strong>对CNN参数进行SGD训练。<br><strong>1、网络修改</strong>：ImageNet是用了专用的1000-way分类层，这里我们换成21-way分类层，（其中20是VOC的类别数，1代表背景），卷积部分都没有改变。<br><strong>2、数据集</strong>选择性搜索算法会提取一些候选区域，如何区分正例，负例？这里我们考虑如果其和真实标注的框的<strong>IoU&gt;= 0.5</strong>就认为是正例，否则就是负例。OK这样前面选择性搜索的框到了后面就利用IOU自动标注，然后去softmax训练<br><strong>这样就训练了一个比较适合我们的候选框的分类器。<br>完美！</strong><br><del>但是好像不好耶，重合度0.5就是正例，那不是好多一半框选目标就被认为合格了，一张图片会有好多的框合格对！那么你会想我们去把阈值调高点，不久解决了！这里作者考虑如果IOU太高那样正例就太少了，负例太多，譬如对于一张图片的2000候选框，1张合格，1999张不合格；那么训练会过拟合的！所以考虑这个，这里作者降低了IOU阈值（后面也有说）那么作者咋解决的？第四步</del>~~<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2rnj9kpndj20p80eigsy.jpg" alt="在这里插入图片描述"><br><strong>第四步、多目标分类器</strong><br>这里作者就又搞了20个SVM分类器，上面第三步训练好了CNN了，我们把所有的图片走一遍CNN把最后的特征留下，不训练，把它保留当成特征，去训练SVM。这里把IOU&lt;0.3的认为是负样本。</p><p>另外样本数据很大，每幅图片都对应着很多的候选区域特征emmm这里论文采用了hard negative mining method<br>训练时有时模型会把重叠率低的也当成正样本，这就属于顽固负样本，需要继续投进去训练。</p><blockquote><p>【难负例挖掘算法，用途就是正负例数量不均衡，而负例分散代表性又不够的问题，hard negative就是每次把那些顽固的棘手的错误,再送回去继续练,练到你的成绩不再提升为止.这一个过程就叫做’hard negative mining‘】</p></blockquote><p><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2rnjdi08fj20os0dpgsz.jpg" alt="在这里插入图片描述"></p><p>这里你会想到为啥不直接CNN时直接搞一个分类器，还用啥SVM？<br>对于这个问题我也有所疑惑，然后查了一下，大概这么解释还可以理清。</p><blockquote><p>因为svm训练和cnn训练过程的正负样本定义方式各有不同，导致最后采用CNN softmax输出比采用svm精度还低。事情是这样的，cnn在训练的时候，对训练数据做了比较宽松的标注，比如一个bounding box可能只包含物体的一部分，那么我也把它标注为正样本，用于训练cnn；采用这个方法的主要原因在于因为CNN容易过拟合，所以需要大量的训练数据，所以在CNN训练阶段我们是对Bounding box的位置限制条件限制的比较松(IOU只要大于0.5都被标注为正样本了)；然而svm训练的时候，因为svm适用于少样本训练，所以对于训练样本数据的IOU要求比较严格，我们只有当bounding box把整个物体都包含进去了，我们才把它标注为物体类别，然后训练svm。一旦CNN f7层特征被提取出来，那么我们将为每个物体累训练一个svm分类器。当我们用CNN提取2000个候选框，可以得到2000<em>4096这样的特征向量矩阵，然后我们只需要把这样的一个矩阵与svm权值矩阵4096</em>N点乘(N为分类类别数目，因为我们训练的N个svm，每个svm包好了4096个W)，就可以得到结果了。</p><h2 id="Bounding-box回归"><a href="#Bounding-box回归" class="headerlink" title="Bounding-box回归"></a>Bounding-box回归</h2><p>上面完成了分类，但其实回归效果不是很好，作者又在第五层卷积层采用了Bounding-box回归对候选区域做了修正，提高了边框的回归效果。</p></blockquote><p>下图，绿色的框表示Ground Truth, 红色的框为Selective Search提取的Region Proposal。那么很明显框定位不准(IoU&lt;0.5)，  如果我们能对红色的框进行微调， 使得经过微调后的窗口跟Ground Truth 更接近， 这样岂不是定位会更准确。 确实，Bounding-box regression 就是用来微调这个窗口的。<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2rpqa2zgwj20d40cxjrk.jpg" alt="在这里插入图片描述"><br>那么怎么变换呢?我们可以简单的看出可以通过平移、伸缩两种操作来实现。<br>如下图所示，我们需要目标框的四维向量和合格的预选区域的向量，然后要训练一个线形回归模型，下图左边那个公式，这里计算损失公式如右下角所示。训练好后就可以用来预测了。<br>具体哪个BoundingBox模型可以参考参考文献来学习。<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2rpqn5f8oj20p30d4gth.jpg" alt="在这里插入图片描述"></p><h2 id="测试环节非极大值抑制-Non-Maximum-Suppression-NMS"><a href="#测试环节非极大值抑制-Non-Maximum-Suppression-NMS" class="headerlink" title="测试环节非极大值抑制(Non-Maximum Suppression, NMS)"></a>测试环节非极大值抑制(Non-Maximum Suppression, NMS)</h2><p>训练好了怎么测试？<br>测试阶段，在测试图像上使用selective search抽取2000个推荐区域（实验中，我们使用了选择性搜索的快速模式）。然后变形每一个推荐区域，再通过CNN前向传播计算出特征。然后我们使用对每个类别训练出的SVM给整个特征向量中的每个类别单独打分。<br>然后给出一张图像中所有的打分区域，然后使用NMS（每个类别是独立进行的），拒绝掉一些和高分区域的IOU大于阈值的候选框。</p><blockquote><p>非极大值抑制<br>给出一张图片和上面许多物体检测的候选框（即每个框可能都代表某种物体），但是这些框很可能有互相重叠的部分，我们要做的就是只保留最优的框。假设有N个框，每个框被分类器计算得到的分数为Si, 1&lt;=i&lt;=N。<br>0、建造一个存放待处理候选框的集合H，初始化为包含全部N个框；建造一个存放最优框的集合M，初始化为空集。<br>1、将所有集合 H 中的框进行排序，选出分数最高的框 m，从集合 H 移到集合 M；<br>2、遍历集合 H 中的框，分别与框 m 计算交并比（Interection-over-union，IoU），如果高于某个阈值（一般为0~0.5），则认为此框与 m 重叠，将此框从集合 H 中去除。<br>3、回到第1步进行迭代，直到集合 H 为空。集合 M 中的框为我们所需。</p></blockquote><p>用下面这张图可以看懂测试的流程。</p><p><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g2rnpry3mzj20o00dk7bl.jpg" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇论文虽然已经算是早起的目标检测的论文，但依然被新手所研究，算是目标检测的开篇之作把！他给出了目标检测的一个最简单的思路，但是费时费力。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]【深度学习】R-CNN 论文解读及个人理解<br><a href="https://blog.csdn.net/briblue/article/details/82012575">https://blog.csdn.net/briblue/article/details/82012575</a><br>[2]R-CNN论文详解（论文翻译）<br><a href="https://blog.csdn.net/v1_vivian/article/details/78599229">https://blog.csdn.net/v1_vivian/article/details/78599229</a><br>[3]选择性搜索（selective search）<br><a href="https://blog.csdn.net/guoyunfei20/article/details/78723646">https://blog.csdn.net/guoyunfei20/article/details/78723646</a><br>[4]第三十三节，目标检测之选择性搜索-Selective Search<br><a href="https://www.cnblogs.com/zyly/p/9259392.html">https://www.cnblogs.com/zyly/p/9259392.html</a><br>[5]边框回归：BoundingBox-Regression(BBR)<br><a href="https://blog.csdn.net/v1_vivian/article/details/80292569">https://blog.csdn.net/v1_vivian/article/details/80292569</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>候选区域寻找选择性寻找selective search</title>
      <link href="/posts/%E5%80%99%E9%80%89%E5%8C%BA%E5%9F%9F%E5%AF%BB%E6%89%BE%E9%80%89%E6%8B%A9%E6%80%A7%E5%AF%BB%E6%89%BEselective%20search/"/>
      <url>/posts/%E5%80%99%E9%80%89%E5%8C%BA%E5%9F%9F%E5%AF%BB%E6%89%BE%E9%80%89%E6%8B%A9%E6%80%A7%E5%AF%BB%E6%89%BEselective%20search/</url>
      
        <content type="html"><![CDATA[<p>目标检测时需要筛选候选区域，常见的方法有滑窗法，选择搜索法。本文简单介绍一下候选区域寻找的方法。<br><a id="more"></a></p><h2 id="候选区域寻找selective-search"><a href="#候选区域寻找selective-search" class="headerlink" title="候选区域寻找selective search"></a>候选区域寻找selective search</h2><p>关于候选区域的选择有多种方法，最简单的方法为滑窗法，就是以一定间距不断横纵遍历得到所有的窗口，但是所有区域都遍历，而且有时候物体不一样大？这就太浪费时间了。<br>论文章所采用的方法是选择搜索法。<br>算法具体如下图所示<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2rexwevloj20jn0grjwj.jpg" alt="在这里插入图片描述"><br>step0：生成区域集R。</p><p>step1：计算区域集R里每个相邻区域的相似度S={s1,s2,…}<br>//循环以下步骤<br>step2：找出相似度最高的两个区域，将其合并为新集，添加进R<br>step3：从S中移除所有与step2中有关的子集<br>step4：计算新集与所有子集的相似度<br>step5：S若为空则跳出循环，否则跳至step2</p><p><strong>相似度计算</strong><br>那么关键点在于相似度怎么判断？<br>图像之间的特征有很多，颜色？纹理特征？尺寸等？对于相似度的判断，选择性搜索考虑了颜色、纹理、尺寸和空间交叠这4个参数。<br><strong>1、颜色特征</strong><br>将色彩空间转为HSV，每个通道下以bins=25计算直方图，这样每个区域的颜色直方图有25*3=75个区间。 对直方图除以区域尺寸做归一化后使用下式计算相似度：<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2rfnt2p9bj208h0203yg.jpg" alt="在这里插入图片描述"><br>上式如何理解？简单说一下，我们归一化后每个通道的数据后，一维特征向量的和为1.0，比较两个区域的特征向量每一位，把每一位的最小值加起来。如果全都一样那么结果肯定是1啊！如果不一样，每一位都取最小值，那就肯定比1小啊！哈哈就是这么理解。</p><p><strong>2、纹理相似度（texture similarity）</strong></p><p>论文这里的纹理采用SIFT-Like特征，采用方差为1的高斯微分在8个方向做梯度统计，然后将统计结果（尺寸与区域大小一致）以bins=10计算直方图。直方图区间数为8<em>3</em>10=240（使用RGB色彩空间）。计算公式如下所示：<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2rfsef786j206n01fdfm.jpg" alt="在这里插入图片描述"></p><p><strong>3、尺度相似度</strong><br>尺度相似度其实是实现优先合并小的区域，也就是减少大区域合并小区域。<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2rfwamwqgj207u016mwy.jpg" alt="在这里插入图片描述"><br><strong>4、交叠相似度（shape compatibility measure）</strong><br>上述完成后，要看一下两个区域是否爱挨着，如果距离十万八千里，那就没有合并的必要。如何计算？先找一个外接矩形把它框起来，如果两个矩形相距较远，则外接矩形就很大，所以我们设计这样的指标，其指标是合并后的区域的Bounding Box（能够框住区域的最小矩形BBij）减去两个矩形的尺寸，得到相对差距。其计算方式：<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2rfzhewa3j20ap0160sj.jpg" alt="在这里插入图片描述"><br><strong>候选区域排序</strong><br>相似度计算后还有一个问题，如何对候选区域排序呢，通过上述的步骤我们能够得到很多很多的区域，但是显然不是每个区域作为目标的可能性都是相同的，因此我们需要衡量这个可能性，这样就可以根据我们的需要筛选区域建议个数啦。</p><p>这篇文章做法是，给予最先合并的图片块较大的权重，比如最后一块完整图像权重为1，倒数第二次合并的区域权重为2以此类推。但是当我们策略很多，多样性很多的时候呢，这个权重就会有太多的重合了，排序不好搞啊。文章做法是给他们乘以一个随机数，毕竟3分看运气嘛，然后对于相同的区域多次出现的也叠加下权重，毕竟多个方法都说你是目标，也是有理由的嘛。这样我就得到了所有区域的目标分数，也就可以根据自己的需要选择需要多少个区域了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]选择性搜索（selective search）<br><a href="https://blog.csdn.net/guoyunfei20/article/details/78723646">https://blog.csdn.net/guoyunfei20/article/details/78723646</a><br>[2]第三十三节，目标检测之选择性搜索-Selective Search<br><a href="https://www.cnblogs.com/zyly/p/9259392.html">https://www.cnblogs.com/zyly/p/9259392.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 选择性搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分类CNN经典网络（四）CNN总结</title>
      <link href="/posts/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BBCCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89CNN%E6%80%BB%E7%BB%93/"/>
      <url>/posts/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BBCCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89CNN%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>前面我们分析了CNN的经典网络模型，在此对CNN设计的一些技巧做一些总结。</p><a id="more"></a><p><strong>1、避免遇到瓶颈</strong><br>HxW逐渐变小<br>C逐渐变大<br>缓慢！<br><strong>2、计算量控制（卷积核控制）</strong><br>减小计算量我们可以改变的因素有<br>输入特征数量（但是一般不好控制）<br>输出的特征（与分类有关）<br>卷积核（我们需要去改变的）<br>A考虑小卷积表达大卷积等方法。<br>B考虑1<em>1降维再3</em>3<br>C并联<br><strong>3、感受视野要足够大</strong><br>这样才能捕捉更大尺寸的内容，为此考虑可以用小卷积和来表达大卷积核。这样既能降低参数，提高视野，而且还用了更多的非线性激活。</p><p><strong>4、通道拆分并联</strong><br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2f4s1zvgtj20kx0axtbu.jpg" alt="**4、通道拆分、分组卷积**"></p><p><strong>关键词：<br>卷积的视野<br>计算量、参数量<br>网络的表现能力</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 图像分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图像分类CCNN经典网络（三）ResNet</title>
      <link href="/posts/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BBCCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%89%EF%BC%89ResNet/"/>
      <url>/posts/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BBCCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%89%EF%BC%89ResNet/</url>
      
        <content type="html"><![CDATA[<p>众所周知，网络的层数越低，网络的性能会越来越好。恰面我们看到了经典的四个网络架构，层数最多的也就22层。是不是可以造出更深的网络来呢？为此很多人继续去做实验，人们发现网络性能没有提高反而降低了，考虑其原因可能是梯度爆炸或者梯度消失等，为此有人提出了残差网络的思想。</p><a id="more"></a><p>在前面两篇文章总结了经典的CNN四个模型，其网络层次如下所示：<br><img src="http://wx2.sinaimg.cn/large/e8c7da07ly1g2exfdt940j20d4094aao.jpg" alt="在这里插入图片描述"><br>众所周知，网络的层数越低，网络的性能会越来越好。恰面我们看到了经典的四个网络架构，层数最多的也就22层。是不是可以造出更深的网络来呢？为此很多人继续去做实验，人们发现网络性能没有提高反而降低了，考虑其原因可能是梯度爆炸或者梯度消失等，为此有人提出了残差网络的思想。</p><p><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2exffd4ayj20fo0svafw.jpg" alt="在这里插入图片描述"></p><h2 id="ResNet残差网络"><a href="#ResNet残差网络" class="headerlink" title="ResNet残差网络"></a>ResNet残差网络</h2><p>那么我们作这样一个假设：假设现有一个比较浅的网络（Shallow Net）已达到了饱和的准确率，这时在它后面再加上几个恒等映射层（Identity mapping，也即y=x，输出等于输入），这样就增加了网络的深度，并且起码误差不会增加，也即更深的网络不应该带来训练集上误差的上升。而这里提到的使用恒等映射直接将前一层输出传到后面的思想，便是著名深度残差网络ResNet的灵感来源。</p><p>ResNet的主要思想在于残差的思想，如下图所示：<br>我总结了两方面理解这个思想，emmm不知道对不对，欢迎指正。<br>（1）我们先看这个结构，如果说浅层网络已经训练的比较好了，深层网络要做的就是保持这个效果，保持效果即使要用一个恒等映射，也就是我们的残差网络H=F+X，这个等式如果我们让F=0，则H=X就能恒等映射浅层网络的东西了，所以残差网络训练到后期就会训练F=0这个过程。</p><p><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2exhka50dj20ej09idgs.jpg" alt="在这里插入图片描述"></p><p>（2）那么对于一个数据集，我们不太清楚训练多少层比较好，但是我们知道一个浅层的网络达到比较好的笑过后，再往后加网络层数不知道效果如何，但是如果加一个恒等映射的话应该是保持浅层的效果的！get到。<br>（3）好，那么我们就构造一个深层次的带残差的网络当训练到一定时间后，浅层的网络会优化的很好，深层的网络会逐渐地调节使F趋于0.<br>（4）残差对于收敛速度的影响<br>X是求和前网络映射，H是从输入到求和后的网络映射。比如把5映射到5.1，那么引入残差前是F’(5)=5.1，引入残差后是H(5)=5.1, H(5)=F(5)+5, F(5)=0.1。这里的F’和F都表示网络参数映射，引入残差后的映射对输出的变化更敏感。比如s输出从5.1变到5.2，映射F’的输出增加了1/51=2%，而对于残差结构输出从5.1到5.2，映射F是从0.1到0.2，增加了100%。明显后者输出变化对权重的调整作用更大，所以效果更好。残差的思想都是去掉相同的主体部分，从而突出微小的变化。</p><p>好了，之后又对残差网络做了优化，两层的残差网络参数量太大，下图右侧为三层的残差网络，其先降维，然后再卷积，再升维。<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2exutfuiaj20fi06vt9g.jpg" alt="在这里插入图片描述"><br>左图参数量3x3x256x64x2（？？对不对）<br>右图1x1x256x64+3x3x64x64+1x1x64x256=69632的参数量。<br><strong>参数量大大减小！</strong></p><h2 id="ResNeXt"><a href="#ResNeXt" class="headerlink" title="ResNeXt"></a>ResNeXt</h2><p>ResNeXt是再残差网络上做了一定的修改，它是借鉴了Lenet的思想，将卷积网络按照通道拆分开，如下图所示。<br>左图为ResNet，右图为RexNext。它考虑左边是直接串联完成了所有的步骤先降维得到64通道再用3<em>3卷积核卷积再升维度。右边是分为并联的几个小块，分别降维到4个通道，然后卷积3</em>3，这时参量才3<em>3</em>4<em>4</em>32个相比于3<em>3</em>64*64小多了emmm，案后再升维度，再组合到一起。也是一个很好的思想。</p><p><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2f555xyhdj20kk089adi.jpg" alt="在这里插入图片描述"><br>如下展示了对ResNet与ResNeXt的对比，其在没有提高参数量的同时提高了预测的正确率。<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2f5bk16c8j20ee0dkn2w.jpg" alt="在这里插入图片描述"><br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2f5eat2l3j20ad04lq46.jpg" alt="在这里插入图片描述"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]大话深度残差网络（DRN）ResNet网络原<br><a href="https://blog.csdn.net/rogerchen1983/article/details/79353972">https://blog.csdn.net/rogerchen1983/article/details/79353972</a><br>[2]浅析深度ResNet有效的原理<br><a href="https://blog.csdn.net/u014296502/article/details/80438616">https://blog.csdn.net/u014296502/article/details/80438616</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 图像分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图像分类CNN经典网络（二）GoogLeNet</title>
      <link href="/posts/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BBCCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89GoogLeNet/"/>
      <url>/posts/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BBCCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89GoogLeNet/</url>
      
        <content type="html"><![CDATA[<p>在GoogLeNet之前，人们一直想着去创造更深层的网络去改善CNN模型，但是这样会导致参数量不断增大也不一定有一个很好的效果；随着网络层数增加可能会导致梯度消失现象。</p><a id="more"></a><h2 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h2><p>在GoogLeNet之前，人们一直想着去创造更深层的网络去改善CNN模型，但是这样会导致参数量不断增大也不一定有一个很好的效果；随着网络层数增加可能会导致梯度消失现象。</p><hr><p><strong>*小贴士：梯度消失是什么样？</strong><br>在我们卷积网络中层数不断增加时可能会导致梯度消失的情况，比如如果我们选区sigmoid激活函数，其导数的最大值为0.25，如果层数增大，可能会导致随着后向传播，浅层的网络梯度不断减小，对于参数的更改也就变动十分小，甚至没有。当然产生梯度消失的原因不只这一个，这个是由于激活函数的硬伤导致的，可以换用relu、leakrelu、elu等激活函数。也可以加入Batchnorm。*</p><hr><h3 id="V1版本"><a href="#V1版本" class="headerlink" title="V1版本"></a>V1版本</h3><p><strong>1、Inception结构</strong><br>GoogLeNet提出了一种<strong>Inception</strong>结构来解决这个问题。<br>下图为google团队提出的早起的inception基础结构，该结构将CNN中常用的卷积（1x1，3x3，5x5）、池化操作（3x3）堆叠在一起（卷积池化后的尺寸是一样的，然后把其通道叠在一起即可），一方面增加了网络的宽度，另一方面也增加了网络对尺度的适应性。<strong>(不需要我们去实验选择用什么卷积核，让网络自己去优化抉择哪一个卷积层好。)</strong></p><p><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2eon8at8vj20fh07f3za.jpg" alt="在这里插入图片描述"><br>然而这个Inception原始版本，所有的卷积核都在上一层的所有输出上来做，而那个5x5的卷积核所需的计算量就太大了，造成了特征图的厚度很大，为了避免这种情况，在3x3前、5x5前、max pooling后分别加上了1x1的卷积核，以起到了降低特征图厚度的作用，这也就形成了Inception v1的网络结构，如下图所示：</p><p><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2eona5vcvj20fh086wfg.jpg" alt="在这里插入图片描述"></p><hr><p><strong>*小贴士：1x1的卷积层作用是什么？</strong><br>1x1的卷积层有降低维度的作用，比如上一层网络的输出为100x100x100，如果我们直接用5x5x50去卷积，参数量为100x5<br>x5x50=125000。如果我们先用1x1x50的卷积降维得到100x100x50再进行5x5x50卷积，参数量为100x1x1x50+50x5x5x50=67500，减少了两倍。所以这样加入一个1x1的卷积层能够在降低维度的情况下又能使用5x5的卷积层。*</p><hr><p><strong>思考：为什么VGG通常作为最基础的网络架构，Inception这么好不能作为基础？</strong><br>答：主要在于Inception训练好它会更加的适用于某一个场景数据，当换了场景可能需要修改许多参数；而VGG做出的网络更具有普遍性。</p><p><strong>2、GAP全局平均池化</strong><br>第二个问题是如何处理全连接层权重过大，这里googLeNet提出了全局平均池化的方法，就是把得到的最后特征，每一层求平均后用一个点代替原来一层的特征，这样就减少了大量的全连接层参数。比如特征为7*7*1024此时要得到1*4096的特征，那就得用7*7*1024*4096参数，如果先全局平均池化的话即先得到1*1*1024的特征，再用1*1*1024*4096即可。</p><p><strong>3、辅助分类器</strong><br>当网络层数过长时会存在 梯度消失的现象，googLeNet引入了两个辅助分类器，它感觉可能在某一层会出现梯度消失时，在这里加了一个分类器，最后的分类结果会有一个权重考虑，最终分类器全重大0.5，两个辅助分类器03。这样也类似于一个模型融合提高了系统的泛化能力。也给系统增加了额外的梯度。<br><img src="https://ws3.sinaimg.cn/large/e8c7da07ly1g2eotvtxsoj20j20cpgq1.jpg" alt="20190424164352733"><br>最终V1版本的googLeNet模型结构图<img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2eoqmh8ccj20ps0f5n0o.jpg" alt="在这里插入图片描述"><br>GoogLeNet网络结构明细表解析如下：<br>0、输入<br>原始输入图像为224x224x3，且都进行了零均值化的预处理操作（图像每个像素减去均值）。<br>1、第一层（卷积层）<br>使用7x7的卷积核（滑动步长2，padding为3），64通道，输出为112x112x64，卷积后进行ReLU操作<br>经过3x3的max pooling（步长为2），输出为((112 - 3+1)/2)+1=56，即56x56x64，再进行ReLU操作<br>2、第二层（卷积层）<br>使用3x3的卷积核（滑动步长为1，padding为1），192通道，输出为56x56x192，卷积后进行ReLU操作<br>经过3x3的max pooling（步长为2），输出为((56 - 3+1)/2)+1=28，即28x28x192，再进行ReLU操作<br>3a、第三层（Inception 3a层）<br>分为四个分支，采用不同尺度的卷积核来进行处理<br>（1）64个1x1的卷积核，然后RuLU，输出28x28x64<br>（2）96个1x1的卷积核，作为3x3卷积核之前的降维，变成28x28x96，然后进行ReLU计算，再进行128个3x3的卷积（padding为1），输出28x28x128<br>（3）16个1x1的卷积核，作为5x5卷积核之前的降维，变成28x28x16，进行ReLU计算后，再进行32个5x5的卷积（padding为2），输出28x28x32<br>（4）pool层，使用3x3的核（padding为1），输出28x28x192，然后进行32个1x1的卷积，输出28x28x32。<br>将四个结果进行连接，对这四部分输出结果的第三维并联，即64+128+32+32=256，最终输出28x28x256<br>3b、第三层（Inception 3b层）<br>（1）128个1x1的卷积核，然后RuLU，输出28x28x128<br>（2）128个1x1的卷积核，作为3x3卷积核之前的降维，变成28x28x128，进行ReLU，再进行192个3x3的卷积（padding为1），输出28x28x192<br>（3）32个1x1的卷积核，作为5x5卷积核之前的降维，变成28x28x32，进行ReLU计算后，再进行96个5x5的卷积（padding为2），输出28x28x96<br>（4）pool层，使用3x3的核（padding为1），输出28x28x256，然后进行64个1x1的卷积，输出28x28x64。<br>将四个结果进行连接，对这四部分输出结果的第三维并联，即128+192+96+64=480，最终输出输出为28x28x480</p><p>第四层（4a,4b,4c,4d,4e）、第五层（5a,5b）……，与3a、3b类似，在此就不再重复。</p><h3 id="V2版本"><a href="#V2版本" class="headerlink" title="V2版本"></a>V2版本</h3><p>V2版本做了一些小的改动<br><strong>BatchNormalization</strong><br>        以往的神经网络，我们会对数据的输入做归一化处理，降低数据之间的差异性，来提高网络的收敛速度。BatchNormalization提出普通的网络的隐含层的输出也可以加入标准化，这样也能提高网络的收敛速度，我参考了文献中的几篇博客对BN说明如下：</p><p>在我们训练时，隐含层可能训练到后期，输出的数据可能偏向于某一侧，导致sigmoid激活函数梯度减小甚至消失，导致其收敛速度大大减小，这时我们用一个均值方差归一化做处理是数据集中到正态分布中间来，便能提高收敛的速度。<br><strong>但是这样是不是有了一个问题？？</strong><br>所有数据都归一到中间，中间部位其实是趋于一个线形函数的，那么就导致非线性的操作消失了，<strong>模型的表达能力变差</strong>。这是我们不想要的！<br>BN的一个精髓就出来了，他引入一个偏移，让数据便宜一下到非线性区域。<br><strong>核心思想应该是想找到一个线性和非线性的较好平衡点，既能享受非线性的较强表达能力的好处，又避免太靠非线性区两头使得网络收敛速度太慢。</strong><br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2eoqqrn5lj20mz0a1jsz.jpg" alt="在这里插入图片描述"></p><p>整理后BN算法大致思想如下图所示，求取上一级输出的平均值与方差，对所有数据做归一化处理，但是这样搞完后，数据都偏移了，所以这里还要加入一个尺度变换纠正偏移。<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2eosg6oa8j20hs09xgoh.jpg" alt="在这里插入图片描述"></p><h3 id="V3版本"><a href="#V3版本" class="headerlink" title="V3版本"></a>V3版本</h3><p>V3版本相比之前增加了卷积拆解的思想。具体怎么说呢？</p><p><strong>大卷积拆解为小卷积</strong><br>在实际我们设计网络时，用大的卷积核会有比较好的视野，每一个点所综合考虑的因素多一些，但是这样的话，参数量就会提升。为此V2提出了一种将n<em>n的卷积核拆解为1</em>n后再n<em>1卷积的方法，实验证明这个方法在卷积核复杂的时候比较好用（12&lt;n&lt;18）<br>（下图为参考文献中的一个图，之前VGG中提出过用两个3</em>3代替5*5的网络。）<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2eou5nws0j20bu1a0q58.jpg" alt="在这里插入图片描述"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]大话CNN经典模型：GoogLeNet（从Inception v1到v4的演进）<a href="https://my.oschina.net/u/876354/blog/1637819">https://my.oschina.net/u/876354/blog/1637819</a><br>[2]神经网络中的梯度消失<a href="https://www.cnblogs.com/mengnan/p/9480804.html">https://www.cnblogs.com/mengnan/p/9480804.html</a><br>[3]【深度学习】深入理解Batch Normalization批标准<a href="https://www.cnblogs.com/guoyaohua/p/8724433.html">https://www.cnblogs.com/guoyaohua/p/8724433.html</a><br>[4]【深度学习】批归一化（Batch Normalization）<br><a href="https://www.cnblogs.com/skyfsm/p/8453498.html">https://www.cnblogs.com/skyfsm/p/8453498.html</a><br>[5]</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 图像分类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图像分类CNN经典网络（一）AlexNet与VGG</title>
      <link href="/posts/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BBCCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89AlexNet%E4%B8%8EVGG/"/>
      <url>/posts/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BBCCNN%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89AlexNet%E4%B8%8EVGG/</url>
      
        <content type="html"><![CDATA[<p>本篇文章总结了CNN领域用于目标检测的两个网络AlexNet与VGGNet。</p><a id="more"></a><p>在图像分类领域，CNN有了很好的应用，下图展示了2012年之后的一些经典的网络架构。<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2ewwv1pktj20ns0eutau.jpg" alt="在这里插入图片描述"><br>本篇文章总结了CNN领域用于图像分类的两个网络AlexNet与VGGNet。</p><h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><p>AlexNet是打开卷积神经网络大门的第一个作品，它重新将卷积神经网络带入计算机视觉的科研中。他给出了卷积神经网络在目标检测中的基本思想。<br>主要特点有：<br>1、ReLU、双GPU运算：提高训练速度。（应用于所有卷积层和全连接层）<br>2、重叠pool池化层：提高精度，不容易产生过度拟合。（应用在第一层，第二层，第五层后面）<br>3、局部响应归一化层(LRN)：提高精度。（应用在第一层和第二层后面）<br>4、Dropout：减少过度拟合。（应用在前两个全连接层）<br><img src="http://wx3.sinaimg.cn/large/e8c7da07ly1g2eox01jh1j20nx07rn0q.jpg" alt="在这里插入图片描述"></p><h2 id="VGGNet"><a href="#VGGNet" class="headerlink" title="VGGNet"></a>VGGNet</h2><p>VGGNet由牛津大学计算机视觉组合和Google DeepMind公司研究员一起研发的深度卷积神经网络。它探索了卷积神经网络的<strong>深度和其性能</strong>之间的关系，通过反复的堆叠3<em>3的小型卷积核和2</em>2的最大池化层，成功的构建了16~19层深的卷积神经网络。VGGNet获得了ILSVRC 2014年比赛的亚军和定位项目的冠军，在top5上的错误率为7.5%。</p><p>VGGNet的网络结构如下图所示。VGGNet包含很多级别的网络，深度从11层到19层不等，比较常用的是VGGNet-16和VGGNet-19。VGGNet把网络分成了5段，每段都把多个3*3的卷积网络串联在一起，每段卷积后面接一个最大池化层，最后面是3个全连接层和一个softmax层。</p><p><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2eox333slj20dw0g1gn8.jpg" alt="在这里插入图片描述"><br>我们以VGG16做一个分析<br>下图给出了VGG16的一个内存占用和参数量的分析。<br><img src="http://wx4.sinaimg.cn/large/e8c7da07ly1g2eox53ohyj20fi0cddn9.jpg" alt="在这里插入图片描述"></p><p>VGG特点总结如下：</p><p>1、<strong>至今，VGGNet仍然是现如今搭建基本的CNN网络的基本网络，很多网络构建初期都是在VGG的基础上搭建。</strong><br>2、<strong>网络在创新上提出了用小的卷积核代替大卷积的思想。用两个3*3的卷积核去替代5*5的卷积核，用三个3*3的卷积核代替7*7的卷积核。</strong><br>如何理解？<br>可以看下图原来一个5<em>5的区域要用一个核卷积，如今先用个3</em>3的核来卷积得到第二层的图，图纸考虑是步长为1的情况，此时最底层移动三次可以把5*5的区域遍历到，然后得到第二层3*3的图。然后再用3<em>3的核对第二层卷积得到顶层一个。这样就达到用用两个3\</em>3的卷积核去替代5*5的卷积核。很巧妙！！<br><img src="http://wx1.sinaimg.cn/large/e8c7da07ly1g2eox724fnj20820483ze.jpg" alt="在这里插入图片描述"><br><strong>使用尺寸小的卷积的好处？<br>（1）更少的参数量；<br>（2）更多的非线性变换，使得CNN对特征的学习能力更强表达能力增强；<br>（3）隐式的正则化效果（收敛速度要快）。</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]AlexNet详细解读<br><a href="https://blog.csdn.net/qq_24695385/article/details/80368618">https://blog.csdn.net/qq_24695385/article/details/80368618</a><br>[2]VGGNet介绍<br><a href="https://blog.csdn.net/u013181595/article/details/80974210">https://blog.csdn.net/u013181595/article/details/80974210</a><br>[3]卷积神经网络的网络结构——VGGNet<br><a href="https://www.imooc.com/article/34700">https://www.imooc.com/article/34700</a><br>[4]大话CNN经典模型：<br><a href="https://my.oschina.net/u/876354/blog/1634322">https://my.oschina.net/u/876354/blog/1634322</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 图像分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AlexNet </tag>
            
            <tag> VGG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础学习（三）面向对象</title>
      <link href="/posts/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/posts/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>本篇文章介绍python的类，面向对象的思想。</p><a id="more"></a><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。</p><p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。</p><p>对象可以包含任意数量和类型的数据。</p><p>python类相比其他的不同有以下几个特点：<br>1、self参数作为对象参数，class里面每个函数都会有一个参数self（后面详细介绍）<br>2、<strong>init</strong>初始化函数，类似于构造函数。<br>3、多了一些内置的方法，我们都可以给他重构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">"""一个简单的类实例"""</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">x = MyClass()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 访问类的属性和方法</span></span><br><span class="line">print(<span class="string">"MyClass 类的属性 i 为："</span>, x.i)</span><br><span class="line">print(<span class="string">"MyClass 类的方法 f 输出为："</span>, x.f())</span><br></pre></td></tr></table></figure><h2 id="类的属性方法"><a href="#类的属性方法" class="headerlink" title="类的属性方法"></a>类的属性方法</h2><p><strong>属性就类似于C++中类的成员变量，有私有有共有。python也是一样。</strong><br><strong>私有属性</strong><br>私有属性变量前面有两个下划线。例如__count代表一个私有成员。公有属性没有前置下划线。例如count、a。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">__age = <span class="number">12</span><span class="comment">#私有成员</span></span><br><span class="line">name = <span class="string">"Jack"</span><span class="comment">#公有成员</span></span><br></pre></td></tr></table></figure></p><p><strong>方法类似于C++中的函数。python的方法需要传入一个self代表某个类，调用的时候A.function1(b,c)其中A就是哪个self无需在括号里传值。如下例子</strong><br>定义了两个函数一个时getname一个时setname，<br>getname设置参数为self，调用时直接A.get_name()就能获取到它的年龄，函数体里面改变成员变量用self.name即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">__age = <span class="number">12</span><span class="comment">#私有成员</span></span><br><span class="line">name = <span class="string">"Jack"</span><span class="comment">#公有成员</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.name</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self,str)</span>:</span></span><br><span class="line">self.name = str</span><br><span class="line">People A</span><br><span class="line">A.name()</span><br></pre></td></tr></table></figure><p><strong>私有方法</strong><br><strong>private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.</strong>private_methods。</p><p><strong>专用方法</strong><br>在类中有一系列专用方法，一般的类都会有的方法，也是类特有的方法，一般用到比较多的时构造函数init，在c++中也有，做初始化处理。再有就是打印函数用来打印结果repr。这些函数我们都可以重新构造。</p><p><strong>__init<strong> : 构造函数，在生成对象时调用<br>__del</strong> : 析构函数，释放对象时使用<br>__repr<strong> : 打印，转换<br>__setitem</strong> : 按照索引赋值<br>__getitem<strong>: 按照索引获取值<br>__len</strong>: 获得长度<br>__cmp<strong>: 比较运算<br>__call</strong>: 函数调用<br>__add<strong>: 加运算<br>__sub</strong>: 减运算<br>__mul<strong>: 乘运算<br>__truediv</strong>: 除运算<br>__mod<strong>: 求余运算<br>__pow</strong>: 乘方</strong></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承也是类中的一个重要概念，在开发程序的过程中，如果我们定义了一个类A，然后又想新建立另外一个类B，但是类B的大部分内容与类A的相同时我们不可能从头开始写一个类B，这就用到了类的继承的概念。通过继承的方式新建类B，让B继承A，B会‘遗传’A的所有属性(数据属性和函数属性)，实现代码重用python也有继承这个规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(BaseClassName1)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>在子类中可以重写方法，则调用字类时运行字类的新方法。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装与扩展性<br>封装在于明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者的代码；而外部使用用者只知道一个接口(函数)，只要接口（函数）名、参数不变，使用者的代码永远无需改变。这就提供一个良好的合作基础——或者说，只要接口这个基础约定不变，则代码改变不足为虑。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态指的是一类事物有多种形态</p><p>动物有多种形态：人，狗，猪</p><h2 id="（附录）面向对象常用术语"><a href="#（附录）面向对象常用术语" class="headerlink" title="（附录）面向对象常用术语"></a>（附录）面向对象常用术语</h2><p>抽象/实现</p><p>抽象指对现实世界问题和实体的本质表现,行为和特征建模,建立一个相关的子集,可以用于 绘程序结构,从而实现这种模型。抽象不仅包括这种模型的数据属性,还定义了这些数据的接口。</p><p>对某种抽象的实现就是对此数据及与之相关接口的现实化(realization)。现实化这个过程对于客户 程序应当是透明而且无关的。 </p><p>封装/接口</p><p>封装描述了对数据/信息进行隐藏的观念,它对数据属性提供接口和访问函数。通过任何客户端直接对数据的访问,无视接口,与封装性都是背道而驰的,除非程序员允许这些操作。作为实现的 一部分,客户端根本就不需要知道在封装之后,数据属性是如何组织的。在Python中,所有的类属性都是公开的,但名字可能被“混淆”了,以阻止未经授权的访问,但仅此而已,再没有其他预防措施了。这就需要在设计时,对数据提供相应的接口,以免客户程序通过不规范的操作来存取封装的数据属性。</p><p>注意：封装绝不是等于“把不想让别人看到、以后可能修改的东西用private隐藏起来”</p><p>真正的封装是，经过深入的思考，做出良好的抽象，给出“完整且最小”的接口，并使得内部细节可以对外透明</p><p>（注意：对外透明的意思是，外部调用者可以顺利的得到自己想要的任何功能，完全意识不到内部细节的存在）</p><p>合成</p><p>合成扩充了对类的 述,使得多个不同的类合成为一个大的类,来解决现实问题。合成 述了 一个异常复杂的系统,比如一个类由其它类组成,更小的组件也可能是其它的类,数据属性及行为, 所有这些合在一起,彼此是“有一个”的关系。</p><p>派生/继承/继承结构</p><p>派生描述了子类衍生出新的特性,新类保留已存类类型中所有需要的数据和行为,但允许修改或者其它的自定义操作,都不会修改原类的定义。<br>继承描述了子类属性从祖先类继承这样一种方式<br>继承结构表示多“代”派生,可以述成一个“族谱”,连续的子类,与祖先类都有关系。</p><p>泛化/特化</p><p>基于继承<br>泛化表示所有子类与其父类及祖先类有一样的特点。<br>特化描述所有子类的自定义,也就是,什么属性让它与其祖先类不同。</p><p>多态与多态性</p><p>多态指的是同一种事物的多种状态：水这种事物有多种不同的状态：冰，水蒸气</p><p>多态性的概念指出了对象如何通过他们共同的属性和动作来操作及访问,而不需考虑他们具体的类。</p><p>冰，水蒸气，都继承于水，它们都有一个同名的方法就是变成云，但是冰.变云(),与水蒸气.变云()是截然不同的过程，虽然调用的方法都一样</p><p>自省/反射</p><p>自省也称作反射，这个性质展示了某对象是如何在运行期取得自身信息的。如果传一个对象给你,你可以查出它有什么能力,这是一项强大的特性。如果Python不支持某种形式的自省功能,dir和type内建函数,将很难正常工作。还有那些特殊属性,像<strong>dict</strong>,<strong>name</strong>及<strong>doc</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]菜鸟教程面向对象<a href="http://www.runoob.com/python3/python3-class.html">http://www.runoob.com/python3/python3-class.html</a><br>[2]面向对象介绍<a href="https://www.cnblogs.com/wangmo/p/7751199.html">https://www.cnblogs.com/wangmo/p/7751199.html</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python基础学习（二）错误与异常</title>
      <link href="/posts/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8/"/>
      <url>/posts/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>本节介绍以下python中的错误与异常，以及学会如何去自定义一个异常，这样有助于我们之后的调试。</p><a id="more"></a><h3 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h3><p>在编写程序时可能会出现一些语法错误，这时系统会提示语法错误，比如类型错误，无效参数等，如下给出一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">while</span> <span class="literal">True</span> print(<span class="string">'Hello world'</span>)</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in ?</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span> print(<span class="string">'Hello world'</span>)</span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>在运行时有时会发生一些异常，比如分母作为0了，以下给出一个抛出异常的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="number">10</span> * (<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in ?</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p>常见的错误及异常关键词如下：</p><p>KeyboardInterrupt    用户中断执行(通常是输入^C)<br>Exception    常规错误的基类<br>StopIteration    迭代器没有更多的值<br>GeneratorExit    生成器(generator)发生异常来通知退出<br>StandardError    所有的内建标准异常的基类<br>FloatingPointError    浮点计算错误<br>OverflowError    数值运算超出最大限制<br>ZeroDivisionError    除(或取模)零 (所有数据类型)<br>SyntaxError    Python 语法错误<br>TypeError    对类型无效的操作<br>ValueError    传入无效的参数</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>有时，对于异常我们可以加以限制，比如需要用户输入一个数，但是用户输入错误，抛出一个异常，系统可能中断，但这里我们可以采用一个异常处理，当抛出异常时重新让用户输入信息并给与提示。</p><p>这里就用到try语句，他可以尝试执行一句话如果抛出异常，则根据其异常的类别不同执行不同的语句。如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#运行代码</span></span><br><span class="line"><span class="keyword">except</span> &lt;异常名字<span class="number">1</span>&gt;：</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果在try代码引发了'异常名字1'异常，则执行这条语句</span></span><br><span class="line"><span class="keyword">except</span> &lt;异常名字<span class="number">2</span>&gt;，&lt;数据&gt;:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果引发了'异常名字2'异常，并且获得附加的数据</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果没有异常发生</span></span><br></pre></td></tr></table></figure><p>另外这里也可以不带异常名字，直接发生异常后执行一段代码。</p><p>下面给出一个让用户输入一个数字的代码，这里有个强制转换，如果转换失败应该会报出valueerror则打印输入错误。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = int(input(<span class="string">"Please enter a number: "</span>))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        print(<span class="string">"Oops!  That was no valid number.  Try again   "</span>)</span><br></pre></td></tr></table></figure></p><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>上述为检测一个异常的做法，在调试过程中，我们也可以自主的抛出异常，比如执行到某段程序，我们去测一下是否如我们所想像，如果不是我们想要的就让他抛出一个异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">raise</span> NameError(<span class="string">'HiThere'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in ?</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure><p>raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。</p><p>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">raise</span> NameError(<span class="string">'HiThere'</span>)</span><br><span class="line">    <span class="keyword">except</span> NameError:</span><br><span class="line">        print(<span class="string">'An exception flew by!'</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">   </span><br><span class="line">An exception flew by!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 2, in ?</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><p>我们也可以定义一个自己的异常类，其作为Exception的类的继承，可以设置参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span><span class="params">(Exception)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    self.value = value</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> repr(self.value)</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1]菜鸟教程python3错误与异常<a href="http://www.runoob.com/python3/python3-errors-execptions.html">http://www.runoob.com/python3/python3-errors-execptions.html</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python基础学习（一）基本语法</title>
      <link href="/posts/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/posts/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>学习一门语言都要有一个helloworld，都要了解最基础的输入输出、注释、变量类型等基本的语法，对于其他的语法都是paper tiger。话不多说，我们一起来瞅瞅~~<br><a id="more"></a></p><h2 id="Python基础学习（一）基本语法"><a href="#Python基础学习（一）基本语法" class="headerlink" title="Python基础学习（一）基本语法"></a>Python基础学习（一）基本语法</h2><p>学习一门语言都要有一个helloworld，都要了解最基础的输入输出、注释、变量类型等基本的语法，对于其他的语法都是paper tiger。话不多说，我们一起来瞅瞅~~</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>1、编程规范性</strong><br>python语言与之前的C语言、CPP语言最直观的表现在于其没有分号，它以缩进，对齐来实现其结构，所以python对编程的规范要求比较高，如下我们展示python的一段编程。<br>for，if等以冒号代替花括号；<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">print(it)</span><br><span class="line">print(<span class="string">"end"</span>)</span><br></pre></td></tr></table></figure><br><strong>2、没有主函数</strong><br>如上所示，写下的代码都可以运行，无需掉主函数。</p><p><strong>3、语句太长，换行</strong><br>语句太长可以用 \ 反斜杠换行，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">            img3 = cv.rectangle(img1,(x,y),(x+w,y+w),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">            img4 = cv.putText(img3,<span class="string">'prepare %s picture'</span>\ <span class="comment">#这里换行</span></span><br><span class="line">            %str(count+<span class="number">1</span>),(<span class="number">20</span>,<span class="number">80</span>),\<span class="comment">#这里换行</span></span><br><span class="line">            cv.FONT_HERSHEY_PLAIN,<span class="number">2</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">            f = cv.resize(img2[y:y+h,x:x+w],(<span class="number">200</span>,<span class="number">200</span>))</span><br><span class="line">            cv.imshow(<span class="string">'13'</span>,img4)</span><br></pre></td></tr></table></figure><h3 id="打印函数"><a href="#打印函数" class="headerlink" title="打印函数"></a>打印函数</h3><p>print函数是最基本的应用，python3中有括号，python2中没有括号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;hello,world!&quot;)</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>python的注释用#表示，如果对多行注释的话，可以用’’’在两个’’’之间的被注释掉。另外也可以改为”””三个双引号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">本案例用来说明注释的作用。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> range(<span class="number">9</span>):<span class="comment">#循环九次</span></span><br><span class="line">print(it)<span class="comment">#打印it</span></span><br><span class="line">print(<span class="string">"end"</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">程序结束</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>python中数字有四种类型：整数、布尔型、浮点数和复数。<br>int (整数), 如 1<br>bool (布尔), 如 True。<br>float (浮点数), 如 1.23、3E-2<br>complex (复数), 如 1 + 2j、 1.1 + 2.2j</p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p><strong>读取键盘输入</strong><br>读取键盘输入可以用input语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = input(<span class="string">"请输入字符串"</span>)</span><br><span class="line">print(str1)</span><br></pre></td></tr></table></figure><p><strong>字符串格式化输出</strong><br>字符串格式化输出类似于C语言的格式化输出。<br>用print打印一个字符串，可以在后面跟上%，后面存入前面%对应的变量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3.1415926</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">c = <span class="number">1.21</span></span><br><span class="line">print(<span class="string">'常量 PI 的值近似为：%5.3f。'</span> %a)</span><br><span class="line">print(<span class="string">'b = %d,c = %.1f'</span> %(b,c))</span><br></pre></td></tr></table></figure><br>注意：其中格式化输出符号如下表所示，另外.1代表保留一位小数。5.3代表至少占5个字符3位小数。<br><img src="https://ws3.sinaimg.cn/large/e8c7da07ly1g1zofm4l6wj2055096t8r.jpg" alt="201904121027375"><br><strong>新版格式化输出</strong><br>新版格式化输出类似，采用{}表示一个字段，用.format()的参数替代.<br>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;&#125;网址： "&#123;&#125;!"'</span>.format(<span class="string">'菜鸟教程'</span>, <span class="string">'www.runoob.com'</span>))</span><br><span class="line">菜鸟教程网址： <span class="string">"www.runoob.com!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;0&#125; 和 &#123;1&#125;'</span>.format(<span class="string">'Google'</span>, <span class="string">'Runoob'</span>))</span><br><span class="line">Google 和 Runoob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;1&#125; 和 &#123;0&#125;'</span>.format(<span class="string">'Google'</span>, <span class="string">'Runoob'</span>))</span><br><span class="line">Runoob 和 Google</span><br></pre></td></tr></table></figure><p>也可以在{}中加入关键字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'站点列表 &#123;0&#125;, &#123;1&#125;, 和 &#123;other&#125;。'</span>.format(<span class="string">'Google'</span>,\</span><br><span class="line">&gt;<span class="string">'Runoob'</span>,other=<span class="string">'Taobao'</span>))</span><br><span class="line">站点列表 Google, Runoob, 和 Taobao。</span><br></pre></td></tr></table></figure><p>可选项 ‘:’ 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3.1415926</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">c = <span class="number">1.21</span></span><br><span class="line">print(<span class="string">'常量 PI 的值近似为：&#123;0:.3f&#125;'</span>.format(a))</span><br><span class="line">print(<span class="string">'b = %d,c = %.1f'</span> %(b,c))</span><br></pre></td></tr></table></figure><br>如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。</p><p>最简单的就是传入一个字典, 然后使用方括号 ‘[]’ 来访问键值 :<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = &#123;<span class="string">'Google'</span>: <span class="number">1</span>, <span class="string">'Runoob'</span>: <span class="number">2</span>, <span class="string">'Taobao'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Runoob: &#123;0[Runoob]:d&#125;; Google: &#123;0[Google]:d&#125;; Taobao: &#123;0[Taobao]:d&#125;'</span>.format(table))</span><br><span class="line">Runoob: <span class="number">2</span>; Google: <span class="number">1</span>; Taobao: <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><p>python可以导入自带库或者自己写的库，用到import语句。<br>将整个模块(somemodule)导入，格式为： import somemodule<br>从某个模块中导入某个函数或者某个类，格式为： from somemodule import somefunction<br>从某个模块中导入多个函数或者多个类，格式为： from somemodule import firstfunc, secondfunc, thirdfunc<br>将某个模块中的全部函数导入，格式为： from somemodule import *</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv <span class="comment">#导入CV2库并给他换了个名字</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> os,sys</span><br><span class="line"><span class="keyword">from</span> CS231N_Data <span class="keyword">import</span> load_CIFAR10<span class="comment">#从我的CS231N_Data文件中导入load_CIFAR10类</span></span><br><span class="line"><span class="keyword">from</span> neural_net <span class="keyword">import</span> TwoLayerNet</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>玉渊潭樱花之旅</title>
      <link href="/posts/%E7%8E%89%E6%B8%8A%E6%BD%AD%E6%A8%B1%E8%8A%B1%E4%B9%8B%E6%97%85/"/>
      <url>/posts/%E7%8E%89%E6%B8%8A%E6%BD%AD%E6%A8%B1%E8%8A%B1%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p>三月初春<br>在北京待的第二个春天，想起去年我还在考研复试，如今已经在北京待了一年了，今年春天来得比较早，玉渊潭的樱花又开了，老司机当然要去看看了，赏花是每年不能错过的节目。<br><a id="more"></a><br>主演：🧑&amp;👩<br>地点：玉渊潭公园🌸<br>时间：2019.3.17</p><h2 id="线路"><a href="#线路" class="headerlink" title="线路"></a>线路</h2><p><strong>地铁</strong>：清早乘坐2号线转1号线可以到木樨地站，下车步行800米可以到达东门，或者做地铁4号线转9号线可以到达白堆子站，下车步行600米可以到达北门。</p><p><strong>公交</strong>：每个地方不一样哈，自己找路吧</p><h2 id="皂片发来"><a href="#皂片发来" class="headerlink" title="皂片发来"></a>皂片发来</h2><p>国人旅游就是牌照，嘿嘿，咱也不例外，我们俩说是来观景，拍照倒是消耗了许久，对这一片竹子林照了好久~~<br><br><br><img src="https://ws1.sinaimg.cn/large/e8c7da07ly1g17dl3ge4ej21400u0q9a.jpg" alt="image"></p><h3 id="桃花-amp-樱花篇"><a href="#桃花-amp-樱花篇" class="headerlink" title="桃花&amp;樱花篇"></a>桃花&amp;樱花篇</h3><p>首先，来几张花照，今天还没有到花的旺盛季节，人比较少，还比较好拍~<br><img src="https://ws3.sinaimg.cn/large/e8c7da07ly1g17dkq2aodj20u0140tc3.jpg" alt="image"><br><br><br><img src="https://wx4.sinaimg.cn/large/e8c7da07ly1g17dmr5p9fj20u0140gp1.jpg" alt="image"><br>还有些含苞未放的花骨朵。<br><br><br><img src="https://wx3.sinaimg.cn/large/e8c7da07ly1g17dn1wkcaj21400u047b.jpg" alt="image"><br>在樱花下少不了一张合照来记录~~<br><br><br><img src="https://ws1.sinaimg.cn/large/e8c7da07ly1g17dnso0b3j20u0140q69.jpg" alt="image"></p><h3 id="相机摆拍篇"><a href="#相机摆拍篇" class="headerlink" title="相机摆拍篇"></a>相机摆拍篇</h3><p>一直看网上有相机摆拍的照片，今天让我们也来玩耍一下，拍的不好，嘿嘿第一次，以后会拍好的。<br>让我聚焦你认真的时刻<br><br><br><img src="https://wx3.sinaimg.cn/large/e8c7da07ly1g17dnak8vxj21400u0q73.jpg" alt="image"><br>嘿嘿，我也假装拍照一下~~<br><br><br><img src="https://wx1.sinaimg.cn/large/e8c7da07ly1g17dnjyydcj20u0140n0l.jpg" alt="image"></p><h3 id="蓝天篇"><a href="#蓝天篇" class="headerlink" title="蓝天篇"></a>蓝天篇</h3><p>北京的蓝天是真的美，也许是在一段时间雾霾后出现蓝天映衬的，反正是好看。<br><br><br><img src="https://ws1.sinaimg.cn/large/e8c7da07ly1g17dlquen5j22o03k0npm.jpg" alt="image"><br><br><br><img src="https://wx4.sinaimg.cn/large/e8c7da07ly1g17dlrq76nj20u0140jts.jpg" alt="image"></p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>工作之余多出去走走~~爱上生活</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 玉渊潭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow学习总结（二）用Tensorflow实现一个全卷积神经网络</title>
      <link href="/posts/Tensorflow%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E7%94%A8Tensorflow%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%85%A8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%20-%20%E5%89%AF%E6%9C%AC/"/>
      <url>/posts/Tensorflow%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%E7%94%A8Tensorflow%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%85%A8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%20-%20%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>学习完CS231N一系列课程后，我们都书写了自己的深层卷积网络，代码量不多。这里我们使用google的tensorflow框架去写一个卷积神经网络，并去把卷积网路中的优化一步一步复现出来。</p><a id="more"></a><p>搭建一个卷积神经网络，需要包括以下几个部分：</p><ol><li><strong>数据输入</strong></li><li><strong>前向传播</strong></li><li><strong>损失计算+正则化优化</strong></li><li><strong>网络优化</strong></li><li><strong>测试</strong></li></ol><h2 id="一、数据输入"><a href="#一、数据输入" class="headerlink" title="一、数据输入"></a>一、数据输入</h2><p>数据输入，定义变量我们定义了两个输入数据的占位，方便之后运行时传入即可。然后定义了隐含层的参数输出层的参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入数据</span></span><br><span class="line">   X = tf.placeholder(tf.float32,[<span class="literal">None</span>,INPUT_NODE],name = <span class="string">"x-input"</span>)</span><br><span class="line">   y_ = tf.placeholder(tf.float32,[<span class="literal">None</span>,OUTPUT_NODE],name = <span class="string">"y-output"</span>)</span><br><span class="line">   <span class="comment">#隐藏层参数</span></span><br><span class="line">   weight1 = tf.Variable(tf.truncated_normal([INPUT_NODE,LAYER1_NODE],stddev = <span class="number">0.1</span>))</span><br><span class="line">   b1 = tf.Variable(tf.constant(<span class="number">0.1</span>,shape = [LAYER1_NODE]))</span><br><span class="line">   <span class="comment">#输出层参数</span></span><br><span class="line">   weight2 = tf.Variable(tf.truncated_normal([LAYER1_NODE,OUTPUT_NODE],stddev = <span class="number">0.1</span>))</span><br><span class="line">   b2 = tf.Variable(tf.constant(<span class="number">0.1</span>,shape = [OUTPUT_NODE]))</span><br><span class="line">   <span class="comment">#定义step</span></span><br><span class="line">   global_step = tf.Variable(<span class="number">0</span>,trainable=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></p><h2 id="二、前向传播"><a href="#二、前向传播" class="headerlink" title="二、前向传播"></a>二、前向传播</h2><p>前向传播比价简单<br>1、矩阵相乘matmul<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = tf.matmul(X,weight1)</span><br></pre></td></tr></table></figure><br>2、激活函数<br>激活函数有很多种类<br>RELU激活函数tf.nn.relu()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer1 = tf.nn.relu(tf.matmul(X,weight1) + b1)</span><br></pre></td></tr></table></figure><br>3、一个两层的神经网络<br>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#前向传播</span></span><br><span class="line">   <span class="comment">#计算得分</span></span><br><span class="line">   layer1 = tf.nn.relu(tf.matmul(X,weight1) + b1)</span><br><span class="line">   y = tf.matmul(layer1,weight2) + b2</span><br></pre></td></tr></table></figure></p><h2 id="三、损失计算-正则化优化"><a href="#三、损失计算-正则化优化" class="headerlink" title="三、损失计算+正则化优化"></a>三、损失计算+正则化优化</h2><p>经过前向传播我们得到了传播后的分数，之后我们需要计算它的损失，一部分是得分的损失，一部分是权重的正则损失。</p><h3 id="softmax回归-交叉熵损失"><a href="#softmax回归-交叉熵损失" class="headerlink" title="softmax回归+交叉熵损失"></a>softmax回归+交叉熵损失</h3><p>在计算损失之前，我们先对结果进行分类回归，一般对于多分类问题，我们采用softmax分类器进行回归，softmax可以将分数转变为概率的形式，就可以反应每个数据归属于每个类别的概率。然后我们采用交叉熵（cross_entropy）来计算损失。<br>tensorflow中提供了tf.nn.sparse_softmax_cross_entropy_with_logits函数来计算损失，其输入有两个参数logits是回归结果，label是标签。<br>logits填入待取log的概率化数据。格式为[N,C]，其中N代表样本数量，C代表最后的划分类别数。<br>label填入标签数据，格式为[N,1]，其中N代表样本数量，每一行只有一个结果，取值0-C。<br>这里我们用的数据集样本标签和logits格式是一样的，所以我们引用tf.argmax选取每一行的最大值所代表的编号，得到[N,1]类型结果。<br>计算完后我们将所有损失加起来取平均。如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算损失</span></span><br><span class="line">   cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(logits = y, labels=tf.argmax(y_,<span class="number">1</span>))</span><br><span class="line">   cross_entropy_mean = tf.reduce_mean(cross_entropy)</span><br></pre></td></tr></table></figure></p><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>有时候我们的数据量少，参数多的时候可能会出现过拟合现象，我们一般采取正则化的方式来优化，过拟合的原因在于权重参数可能在调解过程中变得过于复杂去适应我们的训练数据，就好比我们有五个不等式方程，我们去改善它的5*5个系数，使他对于我们的数据都能正确，如果一次取样10个数据，我们可能获得等式的25个唯一参数，很好的去适应这10个数据，但换一组数据它就不是那么好，在控制中就是鲁棒性不是太好。<br>所以我们引入一个刻画权重参数复杂程度的指标J(θ)，然后用一个系数乘以它，来调节它对整个损失的影响比例。这就是正则化<br>一般我们采用L1、L2损失函数，在tensorflow中为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regular = tf.contrib.layers.l2_regularizer(REGULARZATION_RATE)(weight)</span><br></pre></td></tr></table></figure><br>把L2改为L1就代表L1正则化。可以看出后面有两个括号，第一个括号参数为正则化系数，第二个为权重。也可以改写为下面的代码，先声明一个具有某个正则化系数的函数regular，然后在计算W1与W2时可以直接用regular(W1)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#正则化损失</span></span><br><span class="line">regular = tf.contrib.layers.l2_regularizer(REGULARZATION_RATE)</span><br><span class="line">regularization = regular(weight1) + regular(weight2)</span><br></pre></td></tr></table></figure><br>PS：两个正则化的对比：L1正则化会让参数变得稀疏（指会有更多参数变为0），而L2正则化则不会（因为参数的平方后会让小的参数变得更小，大的参数变得更大，同样起到了特征选取的功能，而不会让参数变为0）。其次是L1正则化计算不可导，而L2的正则化损失函数可导。</p><p>下面给出整体的损失计算代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算损失</span></span><br><span class="line">   cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(logits = y, labels=tf.argmax(y_,<span class="number">1</span>))</span><br><span class="line">   cross_entropy_mean = tf.reduce_mean(cross_entropy)</span><br><span class="line">   <span class="comment">#正则化损失</span></span><br><span class="line">   regular = tf.contrib.layers.l2_regularizer(REGULARZATION_RATE)</span><br><span class="line">   regularization = regular(weight1) + regular(weight2)</span><br><span class="line">   <span class="comment">#总损失</span></span><br><span class="line">   loss = cross_entropy_mean + regularization</span><br></pre></td></tr></table></figure></p><h2 id="四、网络优化Optimizer"><a href="#四、网络优化Optimizer" class="headerlink" title="四、网络优化Optimizer"></a>四、网络优化Optimizer</h2><p>计算完损失之后需要进行网络优化，网络优化也就是通过不停改变参数把损失值降低，一般我们多采用随机梯度下降法，</p><h3 id="Optimizer优化"><a href="#Optimizer优化" class="headerlink" title="Optimizer优化"></a>Optimizer优化</h3><p>1、梯度下降法<br>一般我们常用的优化算法为梯度下降法，也就是每次计算出梯度后对每一个参数进行线形调节X = X + learning_rate * Gradient<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.train.GradientDescentOptimizer(learning_rate)<span class="comment">#梯度下降法类</span></span><br></pre></td></tr></table></figure><br>这种优化算法存在一些问题，可能会出现有好几个波谷，但是梯度下降一直在一个波谷里面来回动荡。这会导致梯度下降法有时不能找到最优解，只能找到一个极值点。再者梯度下降法对所有数据进行运算，耗时太长。<br>每一个优化方法类下都有一个minimize函数，对某个值进行最小化优化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_ = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss)</span><br></pre></td></tr></table></figure></p><p>2、随机梯度下降法（SGD）<br>考虑梯度下降法优化速度慢的问题，后来有人提出随机梯度下降法，我们每次训练可以不训练所有的数据，可以只取一个小的batch数据进行训练，这样每次训练的速度就会加快，然后我们每次取样的batch不一样，这样就保证稳定性了。<br>代码可以和上面一样，考虑每次训练取样batch即可。</p><p>更多的优化算法在我另一篇博客中介绍。</p><p>在这之后我们在考虑一个学习率的问题，学习率在一开始可能需要大一点比价好，加快收敛速度，但是在后期，就需要慢下来，因为幅度大的话可能在两边来回晃，很难收敛。</p><h3 id="学习率优化问题"><a href="#学习率优化问题" class="headerlink" title="学习率优化问题"></a>学习率优化问题</h3><p>这里给出一个<strong>指数衰减法</strong>的方法。让学习率以指数方式慢慢衰减。这里我抓取一张常用的图，tensorflow提供两个衰减情况，一个是连续衰减，一个是梯度衰减，如下图所示。<br><img src="https://wx2.sinaimg.cn/large/e8c7da07ly1g17dit90yzj20r10cpgru.jpg" alt="image"><br>tensorflow给出以下函数expoential_decay，参数有四个，基础学习率，全局步数，衰减步数，衰减率。其公式为：<br>learning_rate = LEARNING_RATE_BASE * LEARNING_RATE_DECAY^(global_step/decay_step)<br>含义很明白，当全局步数达到衰减步数时学习率变为基础学习率的基础上乘以衰减率，如果是连续衰减时，在这过程中则一直变化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#学习率更新</span></span><br><span class="line">    learning_rate = tf.train.exponential_decay(LEARNING_RATE_BASE,global_step,\</span><br><span class="line">   decay_step,LEARNING_RATE_DECAY)</span><br></pre></td></tr></table></figure></p><h2 id="五、测试结果"><a href="#五、测试结果" class="headerlink" title="五、测试结果"></a>五、测试结果</h2><p>在进行一段时间训练后我们希望输出以测试集的正确性，利用tf.equal得到两组数据是否i相等，然后求结果的平均值，如下所示。<br>tf.cast可以将其转换类型，因为equal返回的时bool型。故我们将其转换为float32再求平均数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">correct_prediction = tf.equal(tf.argmax(y,<span class="number">1</span>),tf.argmax(y_,<span class="number">1</span>))</span><br><span class="line">   show_result = tf.reduce_mean(tf.cast(correct_prediction,tf.float32))</span><br></pre></td></tr></table></figure><h2 id="六、运行"><a href="#六、运行" class="headerlink" title="六、运行"></a>六、运行</h2><p>首先开启一个会话，然后初始化所有变量，然后准备一个字典型数据，mnist数据集给了一个取样函数next_batch直接取样即可，然后运行_train把数据送进去。当运行100次时打印数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment">#初始化数据</span></span><br><span class="line">    tf.global_variables_initializer().run()</span><br><span class="line">    <span class="comment">#验证集数据</span></span><br><span class="line">    validate_feed = &#123;X:mnist.validation.images,y_:mnist.validation.labels&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> range(TRAINING_STEPS):</span><br><span class="line">        XS,YS = mnist.train.next_batch(BATCH_SIZE)<span class="comment">#取样数据</span></span><br><span class="line">        sess.run(train_,feed_dict=&#123;X:XS,y_:YS&#125;)</span><br><span class="line">        <span class="keyword">if</span> it % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#打印数据</span></span><br><span class="line">            result = sess.run(show_result,feed_dict=validate_feed)</span><br><span class="line">            print(<span class="string">"After %d training step(s),validation accuracy is %g"</span>%(it,result))</span><br></pre></td></tr></table></figure><br>主函数我们编写如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">'./'</span>, one_hot=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#mnist = input_data.read_data_sets("/",one_hot = True)</span></span><br><span class="line"></span><br><span class="line">print(mnist.train.num_examples)</span><br><span class="line">print(mnist.train.images[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">train(mnist)</span><br></pre></td></tr></table></figure><br>注意：这里我们是在本地存了一些数据，如有需要可以从我的github获取<br><a href="https://github.com/Harryjun/CNN_MNIST_tensorflow1">用Tensorflow搭建两层神经网络训练MNIST数据集</a></p><p>最后结果如下所示<br><img src="https://ws1.sinaimg.cn/large/e8c7da07ly1g17djk44akj20dl09n76w.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> TensorFlow </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
